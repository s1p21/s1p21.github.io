<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="面试-全, 前端 vue js ts react node">
    <meta name="description" content="css1.定位、布局不同定位的区别，两栏布局、三栏布局，flex布局必会 两栏布局:浮动布局、flex 三栏布局:双飞翼布局 三栏都采用左浮动

 #main{
  background-color:aqua;
  width:100%;
">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>面试-全 | s1p21的blog</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//css/matery.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//css/my.css">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//css/post.css">




    
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//css/reward.css">
    



    <script src="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="s1p21的blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">s1p21的blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">s1p21的blog</div>
        <div class="logo-desc">
            
            前端技术栈 微信公众号：前端技术宅博客
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/s1p21/hexo" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/s1p21/hexo" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//medias/featureimages/6.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">面试-全</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E9%9D%A2%E8%AF%95/">
                                <span class="chip bg-color">面试</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2025-09-19
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h3 id="css"><a href="#css" class="headerlink" title="css"></a>css</h3><h4 id="1-定位、布局"><a href="#1-定位、布局" class="headerlink" title="1.定位、布局"></a>1.定位、布局</h4><p>不同定位的区别，两栏布局、三栏布局，flex布局必会<br> 两栏布局:浮动布局、flex<br> 三栏布局:双飞翼布局 三栏都采用左浮动</p>
<pre class=" language-css"><code class="language-css">
 <span class="token selector"><span class="token id">#main</span></span><span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span>aqua<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">100%</span><span class="token punctuation">;</span>
  <span class="token property">float</span><span class="token punctuation">:</span>left<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token id">#left</span></span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">200</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span>yellow<span class="token punctuation">;</span>
  <span class="token property">float</span><span class="token punctuation">:</span>left<span class="token punctuation">;</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span>-<span class="token number">100%</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token id">#right</span></span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">300</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span>orange<span class="token punctuation">;</span>
  <span class="token property">float</span><span class="token punctuation">:</span>left<span class="token punctuation">;</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span>-<span class="token number">300</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token id">#content</span></span><span class="token punctuation">{</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span><span class="token number">200</span>px<span class="token punctuation">;</span>
  <span class="token property">margin-right</span><span class="token punctuation">:</span><span class="token number">300</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

 
 &lt;!--中间栏写在最前面-->
&lt;div id = <span class="token string">"main"</span>>
  &lt;div id=<span class="token string">"content"</span>>&lt;/div>
&lt;/div>
&lt;div id = <span class="token string">"left"</span>>
&lt;/div>

&lt;div id = <span class="token string">"right"</span>>
&lt;/div>
</code></pre>
<p>CSS三列布局</p>
<ul>
<li>float布局：左边左浮动，右边右浮动，中间margin：0 100px;</li>
<li>Position布局: 左边left：0; 右边right：0; 中间left: 100px; right: 100px;</li>
<li>table布局: 父元素 display: table; 左右 width: 100px; 三个元素display: table-cell;</li>
<li>弹性(flex)布局:父元素 display: flex; 左右 width: 100px;</li>
<li>网格（gird）布局：</li>
</ul>
<h4 id="2-对于一些常见css的书写-比如文本溢出显示省略号"><a href="#2-对于一些常见css的书写-比如文本溢出显示省略号" class="headerlink" title="2. 对于一些常见css的书写:比如文本溢出显示省略号"></a>2. 对于一些常见css的书写:比如文本溢出显示省略号</h4><pre class=" language-css"><code class="language-css">
<span class="token property">text-overflow</span><span class="token punctuation">:</span>ellipsis

#多行
<span class="token property">display</span><span class="token punctuation">:</span>-webkit-box
<span class="token property">-webkit-line-clamp</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">;</span>
</code></pre>
<h4 id="3-link和-import的区别"><a href="#3-link和-import的区别" class="headerlink" title="3. link和@import的区别"></a>3. link和@import的区别</h4><ul>
<li>link的功能比较多，可以定义RSS、Rel等作用，而@import只能用于加载css</li>
<li>解析到link时，同步加载引到的css，而@import引到的css等到页面加载完成后才被加载</li>
<li>@import 需要ES5 以上</li>
<li>link可以js动态导入，@import不行</li>
</ul>
<h4 id="4-flex"><a href="#4-flex" class="headerlink" title="4. flex"></a>4. flex</h4><ul>
<li>flex-direction</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content (多轴线的对齐方式)</li>
<li>flex-wrap</li>
</ul>
<p>子 </p>
<ul>
<li>flex： 0 1 auto</li>
<li>表示flex-grow 为0 flex-shrink 为1 flex basis为auto</li>
<li>align-self</li>
</ul>
<h4 id="5-垂直居中和水平居中"><a href="#5-垂直居中和水平居中" class="headerlink" title="5.垂直居中和水平居中"></a>5.垂直居中和水平居中</h4><ul>
<li>line-height</li>
<li>absolute+ margin(负值)</li>
<li>absolute + margin auto</li>
<li>absolute + translate</li>
<li>Flex + align-items</li>
<li>Flex + margin auto</li>
<li>Flex + align-self</li>
<li>grid +align-items</li>
<li>calc</li>
</ul>
<h4 id="6-BFC"><a href="#6-BFC" class="headerlink" title="6. BFC"></a>6. BFC</h4><p>BFC（Block formatting context），即块级格式化上下文，它作为HTML页面上的一个独立渲染区域，只有区域内元素参与渲染，且不会影响其外部元素。简单来说，可以将 BFC 看做是一个“围城”，外面的元素进不来，里面的元素出不去<br>形成BFC的条件:</p>
<p>1、浮动元素，float 除 none 以外的值；<br>2、定位元素，position（absolute，fixed）；<br>3、display 为以下其中之一的值 inline-block，table-cell，table-caption；<br>4、overflow 除了 visible 以外的值（hidden，auto，scroll）；</p>
<p>BFC 一般用来解决以下几个问题<br>边距重叠问题<br>消除浮动问题<br>自适应布局问题</p>
<h3 id="js"><a href="#js" class="headerlink" title="js"></a>js</h3><hr>
<p>title: 面试-JS<br>date: 2022-11-29 17:13:37<br>tags: [面试, JS]</p>
<hr>
<h4 id="1-js-垃圾回收机制"><a href="#1-js-垃圾回收机制" class="headerlink" title="1.  js 垃圾回收机制"></a>1.  js 垃圾回收机制</h4><p>答:js 的内存泄漏可以通过三个:闭包、全局变量、对象属性循环使用、DOM 节点删除时未解绑事件、计时器引用未及时删除</p>
<p>垃圾回收机制:手动回收和自动回收、自动回收分为对调用栈的数据回收、对调用堆的数据回收、<br>调用栈的数据回收基于 ESP（记录当前执行状态的指针）来销毁保存在栈的执行上下文；<br>调用堆的数据回收:v8 把堆分为<code>新生代</code>和<code>老生代</code>,新生代存放的是生存时间短的对象，老生代存放生存时间长的对象<br>执行流程:</p>
<ol>
<li>标记活动对象和非活动对象</li>
<li>回收非活动对象占据的内存</li>
<li>内存整理。整理内存碎片</li>
</ol>
<p>新生代的垃圾回收，将新生代空间内存分为两个区域，一半是对象区域，一半是空闲区域，当对象区域写满后，需要执行一次垃圾清理操作。在垃圾回收过程中，对使用对象进行标记。在垃圾清理阶段，把存活的对象复制到空闲区域，并有序排列这些对象。同时经过两次垃圾回收依然还存活的对象，将放置在老生区中</p>
<p>老生代的垃圾回收，使用标记清除。通过遍历调用栈，能够到达的元素称为活动对象，没有对象的可以判断为垃圾数据，进行标记。之后进行垃圾清除，这个是直接删除标记数据。清除之后，产生大量不连续的内存碎片，于是产生了标记-整理的过程。对所有的可以活动的对象向一端移动，清理边界以外的内存，从而占据连续的内存块。</p>
<h4 id="2-模块化"><a href="#2-模块化" class="headerlink" title="2. 模块化"></a>2. 模块化</h4><p>AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块 CMD推崇就近依赖，只有在用到某个模块的时候再去require<br>CommonJS通过同步的方式加载模块，其输出的模块是一个拷贝对象，所以修改原的模块不会对被引入的模块内部产生影响，且模块在代码运行的时候加载<br>es6模块是在代码编译时输出接口即编译时加载，es6是通过命令来指定导出和加载，且导出的是模块中的只读引用，如果原始模块中的值被改变了，那么加载的值也会随之改变，所以是动态引用</p>
<h5 id="CommonJS-与-ESM-的区别"><a href="#CommonJS-与-ESM-的区别" class="headerlink" title="CommonJS 与 ESM 的区别"></a>CommonJS 与 ESM 的区别</h5><p>实际开发中，经常会将 ESM 和 CommonJS 混用，因此有必要了解它们之间的区别。</p>
<h6 id="动态与静态"><a href="#动态与静态" class="headerlink" title="动态与静态"></a>动态与静态</h6><p>CommonJS中对模块依赖的解决是“动态的”，而ESM是静态的。所谓动态，是指模块依赖关系的建立发生在代码运行阶段；而静态是指模块依赖关系的建立发生在代码编译阶段。</p>
<p>CommonJS在运行时才会加载模块，确定模块依赖关系。因此可以在任意地方导入模块，甚至可以通过if语句来判断是否加载某个模块。</p>
<p>ESM的导入、导出语句都是声明式的，导入和导出语句必须位于模块的顶层作用域。它是一种静态的模块结构，在编译阶段就可以分析出模块的依赖关系。相比CommonJS，其具有以下优势：</p>
<p>死代码检测和排除。可以减小打包资源体积。</p>
<p>模块变量类型检查。</p>
<p>编译器优化。CommonJS中不论采用那种方式，本质上导入的都是一个对象。而ESM中，可以直接导入变量，减少了引用层级，程序效率更高。</p>
<h6 id="值拷贝和动态映射"><a href="#值拷贝和动态映射" class="headerlink" title="值拷贝和动态映射"></a>值拷贝和动态映射</h6><p>导入一个模块时，CommonJS中获取的是一份值的拷贝，而在ESM中，获取的是值的动态映射，并且这个映射是只读的。</p>
<p>浏览器中 ES6 的模块化支持、node 采用 commonJS 的模块化支持</p>
<ul>
<li>es6 <code>import/export</code></li>
<li>commonjs <code>require/module.exports/exports</code></li>
<li>amd <code>require/defined</code></li>
</ul>
<p><code>require</code> 与<code>import</code>的区别:</p>
<ul>
<li><code>require</code>支持动态导入,<code>import</code>不支持</li>
</ul>
<h4 id="3-原型和原型链"><a href="#3-原型和原型链" class="headerlink" title="3. 原型和原型链"></a>3. 原型和原型链</h4><p>原型关系：</p>
<ul>
<li>每个 class 都有显示原型 prototype</li>
<li>每个实例都有隐式原型 _ proto_</li>
<li>实例的* proto*指向对应 class 的 prototype</li>
</ul>
<p>原型: 在 JS 中，每当定义一个对象（函数也是对象）时，对象中都会包含一些预定义的属性。其中每个函数对象都有一个 prototype 属性，这个属性指向函数的原型对象。</p>
<p>原型链：函数的原型链对象 constructor 默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针<strong>proto</strong>,该指针是指向上一层的原型对象，而上一层的原型对象的结构依然类似。因此可以利用<strong>proto</strong>一直指向 Object 的原型对象上，而 Object 原型对象用 Object.prototype.** proto** = null 表示原型链顶端。如此形成了 js 的原型链继承。同时所有的 js 对象都有 Object 的基本防范</p>
<p>特点: JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p>
<h5 id="ES5与ES6继承的区别"><a href="#ES5与ES6继承的区别" class="headerlink" title="ES5与ES6继承的区别"></a>ES5与ES6继承的区别</h5><p>ES5的继承是先创建子类的实例, 然后再创建父类的方法添加到this上.</p>
<p>ES6的继承是先创建父类的实例对象this(必须先调用super方法), 再调用子类的构造函数修改this.</p>
<p>通过关键字class定义类, extends关键字实现继承. 子类必须在constructor方法中调用super方法否则创建实例报错. 因为子类没有this对象, 而是使用父类的this, 然后对其进行加工</p>
<p>super关键字指代父类的this, 在子类的构造函数中, 必须先调用super, 然后才能使用this</p>
<h4 id="执行上下文和闭包"><a href="#执行上下文和闭包" class="headerlink" title="执行上下文和闭包"></a>执行上下文和闭包</h4><p>执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。 执行上下文的生命周期包括三个阶段：创建阶段→执行阶段→回收阶段，我们重点介绍创建阶段。</p>
<p>闭包就是能够读取其他函数内部变量的函数。在 js 中只有函数内部的子函数才能读取局部变量。所以可以简单的理解为：定义在内部函数的函数。</p>
<p>用途主要有两个：</p>
<p>1）使用闭包可以访问函数中的变量。</p>
<p>2）让变量值始终保持在内存中。</p>
<h4 id="4-介绍节流防抖原理、区别以及应用"><a href="#4-介绍节流防抖原理、区别以及应用" class="headerlink" title="4.介绍节流防抖原理、区别以及应用"></a>4.介绍节流防抖原理、区别以及应用</h4><p>节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次。</p>
<p>防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如 1 秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待 1 秒，直到能最终执行！</p>
<p>使用场景：<br>节流：滚动加载更多、搜索框搜的索联想功能、高频点击、表单重复提交……<br>防抖：搜索框搜索输入，并在输入完以后自动搜索、手机号，邮箱验证输入检测、窗口大小 resize 变化后，再重新渲染。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 节流</span>
<span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> lastTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> nowTime <span class="token operator">=</span> Data<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nowTime <span class="token operator">-</span> lastTime <span class="token operator">></span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      lastTime <span class="token operator">=</span> nowTime<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//  防抖</span>
<span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">clearTimeOut</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    timer <span class="token operator">=</span> <span class="token function">setTimeOut</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="5-函数式编程"><a href="#5-函数式编程" class="headerlink" title="5. 函数式编程"></a>5. 函数式编程</h4><ul>
<li>纯函数(确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维护；</li>
</ul>
<p>优势:</p>
<ul>
<li>完全独立，与外部解耦；</li>
<li>高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳定；</li>
<li>可测试性极强；</li>
</ul>
<p>条件:</p>
<ul>
<li>不修改参数；</li>
<li>不依赖、不修改任何函数外部的数据；</li>
<li>完全可控，参数一样，返回值一定一样: 例如函数不能包含 new Date()或者 Math.rando()等这种不可控因素；</li>
<li>引用透明；</li>
</ul>
<h4 id="6-call、-apply-和-bind-的区别"><a href="#6-call、-apply-和-bind-的区别" class="headerlink" title="6. call、 apply 和 bind 的区别"></a>6. call、 apply 和 bind 的区别</h4><p>全局环境下this指向window，箭头函数的this永远指向创建当前词法环境时的this，作为构造函数时，函数中的this指向实例对象<br>执行上下文在被执行的时候才会创建，创建执行上下文时才会绑定this，所以this的指向永远是在执行时确定</p>
<p>call( this,a,b,c ) 在第一个参数之后的，后续所有参数就是传入该函数的值。apply( this,[a,b,c] ) 只有两个参数，第一个是对象，第二个是数组，这个数组就是该函数的参数。</p>
<p>bind 除了返回是函数以外，它的参数和 call 一样。</p>
<p>共同之处：都可以用来代替另一个对象调用一个方法，将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 实现bind</span>
Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">mybind</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> fun  <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">function</span> <span class="token function">bound</span><span class="token punctuation">(</span><span class="token operator">...</span>args2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> self <span class="token operator">=</span> <span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">bound</span><span class="token operator">?</span><span class="token keyword">this</span><span class="token punctuation">:</span>context
        <span class="token keyword">return</span> fun<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>args<span class="token punctuation">.</span><span class="token function">contact</span><span class="token punctuation">(</span>args2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
    bound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>fun<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
    <span class="token keyword">return</span> bound
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 实现call</span>
Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">mycall</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    context<span class="token punctuation">.</span>fun <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">return</span> context<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 实现apply</span>
Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myapply <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    context<span class="token punctuation">.</span>fun <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> context<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<h4 id="7-reduce-参数"><a href="#7-reduce-参数" class="headerlink" title="7. reduce 参数"></a>7. reduce 参数</h4><p>arr.reduce(callback,[initialValue])</p>
<p>callback （执行数组中每个值的函数，包含四个参数）</p>
<p>1、previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））<br>2、currentValue （数组中当前被处理的元素）<br>3、index （当前元素在数组中的索引）<br>4、array （调用 reduce 的数组）</p>
<p>initialValue （作为第一次调用 callback 的第一个参数。）</p>
<p>手写reduce</p>
<pre class=" language-js"><code class="language-js">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myReduce <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span>initialValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> pre<span class="token punctuation">,</span>index
  <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>initalValue <span class="token operator">===</span> undefined<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pre <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    index <span class="token operator">=</span> <span class="token number">1</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    pre <span class="token operator">=</span> initialValue
    index <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span>index<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pre <span class="token operator">=</span> fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span>pre<span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> pre

<span class="token punctuation">}</span>
</code></pre>
<h4 id="8-深拷贝"><a href="#8-深拷贝" class="headerlink" title="8. 深拷贝"></a>8. 深拷贝</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> deepClone<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">function</span> <span class="token function">isObject</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> typeOf data <span class="token operator">===</span><span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> data <span class="token operator">!==</span><span class="token keyword">null</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">function</span> clone <span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isObject</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> cloneTarget <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
            map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> cloneTarget<span class="token punctuation">)</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                cloneTarget<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">clone</span><span class="token punctuation">(</span>target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> cloneTarget
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> target
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token function">clone</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="9-new-关键字做了什么"><a href="#9-new-关键字做了什么" class="headerlink" title="9. new 关键字做了什么"></a>9. new 关键字做了什么</h4><p>做了四件事，1，创建空对象，2，将空对象的<code>__proto__</code>指向构造函数的<code>prototype</code>3，构造函数的 this 作用域赋给新对象，4，返回原始值需要忽略，返回对象需要正常处理</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">_new</span><span class="token punctuation">(</span>constructor<span class="token punctuation">,</span> <span class="token operator">...</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 创建一个空对象</span>
  <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 空对象的`__proto__`指向构造函数的`prototype`, 为这个新对象添加属性</span>
  obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 构造函数的作用域赋给新对象</span>
  <span class="token keyword">var</span> res <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 返回新对象.如果没有显式return语句，则返回this</span>
  <span class="token keyword">return</span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">"[object Object]"</span> <span class="token operator">?</span> res <span class="token punctuation">:</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="10-判断类型-三种方式"><a href="#10-判断类型-三种方式" class="headerlink" title="10. 判断类型 三种方式"></a>10. 判断类型 三种方式</h4><p>typeOf、  instanceOf、Object.prototype.toString.call()<br>typeOf 不能区分Array和Object<br>instanceOf 不能区分基本类型</p>
<h4 id="11-手动实现一个-instanceOf"><a href="#11-手动实现一个-instanceOf" class="headerlink" title="11. 手动实现一个 instanceOf"></a>11. 手动实现一个 instanceOf</h4><p>instanceOf 基于原型链</p>
<pre class=" language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">isInstanceOf</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> fun<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> fun <span class="token operator">!==</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">"arg2 fun is not a function"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>child <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>__proto__ <span class="token operator">!==</span> fun<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">isInstanceOf</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>__proto__<span class="token punctuation">,</span> fun<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="12-观察者模式和发布订阅模式"><a href="#12-观察者模式和发布订阅模式" class="headerlink" title="12. 观察者模式和发布订阅模式"></a>12. 观察者模式和发布订阅模式</h4><p>观察者模式是一对多的依赖关系，他表示多个观察者对象同时监听某一个主题对象，当这个主题对象发生变化时，会通知所有观察者，使他们能够自我更新<br>发布-订阅者模式引入了第三方组件，叫做信息中介，它将订阅者和发布者联系起来，当发布者发生变化时，由信息中介通知订阅者，并进行更新。</p>
<ul>
<li>观察者模式</li>
</ul>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 被观察者</span>
<span class="token keyword">class</span> <span class="token class-name">Subject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
    <span class="token function">add</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">notiify</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>ob<span class="token operator">=</span><span class="token operator">></span>ob<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 观察者</span>
<span class="token keyword">class</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">update</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>发布-订阅模式</li>
</ul>
<pre class=" language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">PubSub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>handles<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>

    <span class="token function">subscribe</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>handles<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>handles<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>handles<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token function">publish</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>handles<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>handles<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fn<span class="token operator">=</span><span class="token operator">></span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="13-虚拟-DOM-和真实-DOM-的转换"><a href="#13-虚拟-DOM-和真实-DOM-的转换" class="headerlink" title="13. 虚拟 DOM 和真实 DOM 的转换"></a>13. 虚拟 DOM 和真实 DOM 的转换</h4><p>虚拟DOM缺点：在首次渲染时，多了一层虚拟DOM的计算，影响性能</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">VDom</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> data<span class="token punctuation">,</span> value<span class="token punctuation">,</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag <span class="token operator">&amp;&amp;</span> tag<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 节点名</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 属性</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 文本数据</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 节点类型</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">appendChild</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// nodeName：node的名字，如果是element那名字是大写的,其他的名字前面写上#。</span>

  <span class="token comment" spellcheck="true">// nodeType：node的类型，一般用数字表示，1表示element(也可以用Node.ELEMENT_NODE来表示)，3表示text(Node.TEXT_NODE)。</span>
  <span class="token comment" spellcheck="true">// 如果是element，那么nodeName === tagName</span>
  <span class="token comment" spellcheck="true">// 如果是text，那么nodeName = #text， tagName = undefined</span>

  <span class="token comment" spellcheck="true">// nodeValue：当前节点的值，对于text, comment节点来说, nodeValue返回该节点的文本内容，对于 attribute 节点来说, 返回该属性的属性值，而对于document和element节点来说，返回null</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">getVnode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> nodeType <span class="token operator">=</span> node<span class="token punctuation">.</span>nodeType<span class="token punctuation">;</span>
  <span class="token keyword">let</span> _vnode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nodeType <span class="token operator">===</span> <span class="token string">"element"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> tag <span class="token operator">=</span> node<span class="token punctuation">.</span>nodeName<span class="token punctuation">;</span>
    <span class="token keyword">let</span> attrs <span class="token operator">=</span> node<span class="token punctuation">.</span>attributes<span class="token punctuation">;</span>
    <span class="token keyword">let</span> _attrObj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> attrs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      _attrObj<span class="token punctuation">[</span>attrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>nodeName<span class="token punctuation">]</span> <span class="token operator">=</span> attrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>nodeValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    _vnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VDom</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> _attrObj<span class="token punctuation">,</span> undefined<span class="token punctuation">,</span> nodeType<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> children <span class="token operator">=</span> node<span class="token punctuation">.</span>childNodes<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      _vnode<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token function">getVNode</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nodeType <span class="token operator">===</span> <span class="token string">"text"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    _vnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VDom</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> nodeName<span class="token punctuation">,</span> undefined<span class="token punctuation">,</span> node<span class="token punctuation">.</span>nodeValue<span class="token punctuation">,</span> nodeType<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> _vnode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>虚拟 DOM 转化成 DOM</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">parseVNode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> type <span class="token operator">=</span> vnode<span class="token punctuation">.</span>type<span class="token punctuation">;</span>
  <span class="token keyword">let</span> rdom <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> <span class="token string">"element"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    rdom <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> attrs <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> attrs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      rdom<span class="token punctuation">.</span><span class="token function">setArribute</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> attrs<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> children <span class="token operator">=</span> vnode<span class="token punctuation">.</span>children<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      rdom<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token function">parseNode</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> <span class="token string">"text"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    rdom <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> rdom<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="15-node-的eventloop"><a href="#15-node-的eventloop" class="headerlink" title="15. node 的eventloop"></a>15. node 的eventloop</h4><p> node的 事件循环有times, pending callbacks(I/o callbacks, idle prepare), poll,check,close callbacks</p>
<ul>
<li>times 执行setTimeOut 和setTimeInterval</li>
<li>check 直接执行setTimeImmediate</li>
</ul>
<h4 id="16-ajax"><a href="#16-ajax" class="headerlink" title="16. ajax"></a>16. ajax</h4><p>readyState 0 表示 请求还未初始化，尚未调用 open() 方法。<br>1 表示 已建立服务器链接，open() 方法已经被调用。<br>2 表示 请求已接受，send() 方法已经被调用，并且头部和状态已经可获得。<br>3 表示 正在处理请求，下载中； responseText 属性已经包含部分数据。<br>4 表示 完成，下载操作已完成。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">ajax</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> method<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> method<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
      xhr<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span>
          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">404</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'404'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'请求数据失败'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre>
<h4 id="17-flutter-的生命周期"><a href="#17-flutter-的生命周期" class="headerlink" title="17. flutter 的生命周期"></a>17. flutter 的生命周期</h4><p>分为两种情况，<br>一个是statelessWidget 其生命周期是constructor、build、deactive、dispose<br>另外一个是statefulWidget，其生命周期是constructor、initState、didChangeDependencies,build、didUpdate Widget、deactive、dispose</p>
<h4 id="18-js-加载的async-和defer的区别"><a href="#18-js-加载的async-和defer的区别" class="headerlink" title="18. js 加载的async 和defer的区别"></a>18. js 加载的async 和defer的区别</h4><p>async script标签设置了这个值，则说明引入的js需要<strong>异步加载和执行</strong><br>在有async的情况下脚本异步加载和执行，并且不会阻塞页面加载，但是也并不会保证其加载的顺序，如果多个async优先执行，则先加载好的js文件，所以使用此方式加载的js文件最好不要包含其他依赖</p>
<p>defer<br>果使用此属性，也将会使js异步加载执行，且会在文档被解析完成后执行，这样就不会阻塞页面加载，但是它将会按照原来的执行顺序执行，对于有依赖关系的也可使用’</p>
<p>如果只有async，那么脚本在下载完成后异步执行。<br>如果只有defer，那么脚本会在页面解析完毕之后执行。</p>
<h4 id="19-虚拟列表"><a href="#19-虚拟列表" class="headerlink" title="19. 虚拟列表"></a>19. 虚拟列表</h4><p>可见区域</p>
<ul>
<li>列表高度是固定的，条数计算</li>
</ul>
<pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> height <span class="token operator">=</span> <span class="token number">60</span>
<span class="token keyword">const</span> bufferSize <span class="token operator">=</span> <span class="token number">5</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>visibleCount <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>clientHeight<span class="token operator">||</span>window<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>height<span class="token punctuation">)</span> <span class="token operator">/</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<ul>
<li>列表高度不固定<br>通过观察者方式，来观察元素是否进入视口。我们会对固定元素的第一个和最后一个分别打上标签，例如把第一个元素的id设置为top，把最后一个元素的id值设置为bottom。<br>此时调用异步的api：IntersectionObserver，他能获取到进入到视口的元素，判断当前进入视口的元素是最后个元素，则说明内容是往上滚的，如果进入视口的是第一个元素，则说明内容是往下滚的。<br>我们依次保存下当前第一个元素距离顶部的高度和距离底部的高度，赋值给滚动内容元素的paddingTop和paddingBottom，这样内容区域的高度就不会坍塌，依旧保持这传统滚动元素充满列表时的内容高度:</li>
</ul>
<h4 id="20-node-的多个通信"><a href="#20-node-的多个通信" class="headerlink" title="20. node 的多个通信"></a>20. node 的多个通信</h4><p>通过socket 和HTTP进行通信<br>同一台电脑通信可以通过IPC进行通信<br>PM2 监听node的原理：<br>pm2包括 Satan进程、God Deamon守护进程、进程间的远程调用rpc、cluster等几个概念<br>1.Satan.js提供了程序的退出、杀死等方法，因此它是魔鬼；God.js 负责维护进程的正常运行，当有异常退出时能保证重启，所以它是上帝。作者这么命名，我只能说一句：oh my god。<br>God进程启动后一直运行，它相当于cluster中的Master进程，守护者worker进程的正常运行。</p>
<p>2.rpc（Remote Procedure Call Protocol）是指远程过程调用，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。同一机器不同进程间的方法调用也属于rpc的作用范畴。</p>
<p>3.代码中采用了axon-rpc 和 axon 两个库，基本原理是提供服务的server绑定到一个域名和端口下，调用服务的client连接端口实现rpc连接。后续新版本采用了pm2-axon-rpc 和 pm2-axon两个库，绑定的方法也由端口变成.sock文件，因为采用port可能会和现有进程的端口产生冲突。</p>
<p>每次命令行的输入都会执行一次satan程序。如果God进程不在运行，首先需要启动God进程。然后根据指令，satan通过rpc调用God中对应的方法执行相应的逻辑。<br>God在初次执行时会配置cluster，同时监听cluster中的事件：<br>在God启动后， 会建立Satan和God的rpc链接，然后调用prepare方法。prepare方法会调用cluster.fork，完成集群的启动.</p>
<h4 id="21-性能指标："><a href="#21-性能指标：" class="headerlink" title="21. 性能指标："></a>21. 性能指标：</h4><ul>
<li>FP（首次绘制）</li>
<li>FCP（首次内容绘制 First contentful paint）</li>
<li>LCP（最大内容绘制时间 Largest contentful paint）</li>
<li>FPS（每秒传输帧数）</li>
<li>CLS (累积布局偏移)</li>
<li>TTI（页面可交互时间 Time to Interactive）</li>
<li>HTTP 请求响应时间</li>
<li>DNS 解析时间</li>
<li>TCP 连接时间</li>
</ul>
<h4 id="22-interface-和-type-、-泛型位置"><a href="#22-interface-和-type-、-泛型位置" class="headerlink" title="22. interface 和 type 、 泛型位置"></a>22. interface 和 type 、 泛型位置</h4><p>interface 只能定义对象类型。type声明可以声明任何类型。</p>
<p>interface 能够声明合并，两个相同接口会合并。Type声明合并会报错<br>type可以类型推导</p>
<p>// 定义callback遍历方法 两种方式 应该采用哪一种？<br><code>type Callback = &lt;T&gt;(item: T) =&gt; void</code><br>// 第二种声明方式<br><code>type Callback&lt;T&gt; = (item: T) =&gt; void;</code></p>
<p>当泛型出现在内部时，比接口本身并不具备任何泛型定义。而接口代表的函数则会接受一个泛型定义。换句话说接口本身不需要泛型，而在实现使用接口代表的函数类型时需要声明该函数接受一个泛型参数。</p>
<p>当泛型出现在接口中时，比如Callback<t> 代表的是使用接口时需要传入泛型的类型.</t></p>
<h4 id="24-箭头函数"><a href="#24-箭头函数" class="headerlink" title="24 箭头函数"></a>24 箭头函数</h4><p>this的作用域<br>但是没有prototype属性没有构造器特性，所以也就没有所谓的constructor，就不能作为构造器使用。<br>箭头函数的作用域不能通过.call、.apply、.bind等语法来改变，这使得箭头函数的上下文将永久不变<br>箭头函数不能使用关键字arguments来访问，只能通过定义的命名参数来访问。</p>
<h4 id="25-JS-设计模式"><a href="#25-JS-设计模式" class="headerlink" title="25 JS 设计模式"></a>25 JS 设计模式</h4><ul>
<li>单例模式</li>
<li>工厂模式</li>
<li>装饰器模式</li>
<li>观察者模式</li>
<li>发布-订阅者模式</li>
<li>策略模式</li>
<li>访问者模式（bable插件）</li>
</ul>
<p>装饰器模式<br>在不改变对象自身的基础上，动态地给某个对象添加一些额外的职责</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fuc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>before <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>beFn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    beFn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 先执行插入到前面的方法，类似于二叉树的前序遍历</span>
    <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 后执行当前的方法</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>afFn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    self<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 先执行当前的方法</span>
    <span class="token keyword">return</span> afFn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 后执行插入到后面的方法</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">fuc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">fuc3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">fuc4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

fuc <span class="token operator">=</span> fuc<span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span>fuc1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span>fuc4<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">after</span><span class="token punctuation">(</span>fuc3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">fuc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>访问者模式<br>在不改变该对象的前提下访问其结构中元素的新方法</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 元素类</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> chinese<span class="token punctuation">,</span> math<span class="token punctuation">,</span> english<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>chinese <span class="token operator">=</span> chinese<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>math <span class="token operator">=</span> math<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>english <span class="token operator">=</span> english<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">accept</span><span class="token punctuation">(</span>visitor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    visitor<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 访问者类</span>
<span class="token keyword">class</span> <span class="token class-name">ChineseTeacher</span> <span class="token punctuation">{</span>
  <span class="token function">visit</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`语文 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>student<span class="token punctuation">.</span>chinese<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MathTeacher</span> <span class="token punctuation">{</span>
  <span class="token function">visit</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`数学 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>student<span class="token punctuation">.</span>math<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">EnglishTeacher</span> <span class="token punctuation">{</span>
  <span class="token function">visit</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`英语 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>student<span class="token punctuation">.</span>english<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 实例化元素类</span>
<span class="token keyword">const</span> student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 实例化访问者类</span>
<span class="token keyword">const</span> chineseTeacher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChineseTeacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> mathTeacher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MathTeacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> englishTeacher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EnglishTeacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 接受访问</span>
student<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>chineseTeacher<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 语文90</span>
student<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>mathTeacher<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 数学80</span>
student<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>englishTeacher<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 英语60</span>
</code></pre>
<h3 id="26-async-await"><a href="#26-async-await" class="headerlink" title="26. async await"></a>26. async await</h3><p>作用：用同步方式，执行异步操作</p>
<p>总结</p>
<p>1）async函数是generator（迭代函数）的语法糖</p>
<p>2）async函数返回的是一个Promise对象，有无值看有无return值</p>
<p>3）await关键字只能放在async函数内部，await关键字的作用 就是获取Promise中返回的resolve或者reject的值</p>
<p>4）async、await要结合try/catch使用，防止意外的错误</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">generatorToAsync</span><span class="token punctuation">(</span>generatorFn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> gen <span class="token operator">=</span> generatorFn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// gen有可能传参</span>

    <span class="token comment" spellcheck="true">// 返回一个Promise</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>

      <span class="token keyword">function</span> <span class="token function">go</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> res
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
          res <span class="token operator">=</span> gen<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 这里有可能会执行返回reject状态的Promise</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 报错的话会走catch，直接reject</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">// 解构获得value和done</span>
        <span class="token keyword">const</span> <span class="token punctuation">{</span> value<span class="token punctuation">,</span> done <span class="token punctuation">}</span> <span class="token operator">=</span> res
        <span class="token keyword">if</span> <span class="token punctuation">(</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment" spellcheck="true">// 如果done为true，说明走完了，进行resolve(value)</span>
          <span class="token keyword">return</span> <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token comment" spellcheck="true">// 如果done为false，说明没走完，还得继续走</span>

          <span class="token comment" spellcheck="true">// value有可能是：常量，Promise，Promise有可能是成功或者失败</span>
          <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>val <span class="token operator">=</span><span class="token operator">></span> <span class="token function">go</span><span class="token punctuation">(</span><span class="token string">'next'</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">,</span> err <span class="token operator">=</span><span class="token operator">></span> <span class="token function">go</span><span class="token punctuation">(</span><span class="token string">'throw'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>

      <span class="token function">go</span><span class="token punctuation">(</span><span class="token string">"next"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 第一次执行</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> asyncFn <span class="token operator">=</span> <span class="token function">generatorToAsync</span><span class="token punctuation">(</span>gen<span class="token punctuation">)</span>

<span class="token function">asyncFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
<h4 id="27-实现一个批量请求函数"><a href="#27-实现一个批量请求函数" class="headerlink" title="27.实现一个批量请求函数"></a>27.实现一个批量请求函数</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>idArray<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token function">request</span><span class="token punctuation">(</span>idArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`id</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>res<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">的请求已经处理完毕,当前并发为</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>pool<span class="token punctuation">.</span>length<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            pool<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>pool<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>promise<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        pool<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//这里是重点，当满了就阻塞</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pool<span class="token punctuation">.</span>length<span class="token operator">==</span>max<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span>pool<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="28-Promise-then-第二个参数和catch的区别是什么"><a href="#28-Promise-then-第二个参数和catch的区别是什么" class="headerlink" title="28.Promise then 第二个参数和catch的区别是什么"></a>28.Promise then 第二个参数和catch的区别是什么</h3><p>主要区别就是，如果在then的第一个函数里抛出了异常，后面的catch能捕获到，而then的第二个函数捕获不到。<br>then的第二个参数和catch捕获错误信息的时候会就近原则，如果是promise内部报错，reject抛出错误后，then的第二个参数和catch方法都存在的情况下，只有then的第二个参数能捕获到，如果then的第二个参数不存在，则catch方法会捕获到。</p>
<h3 id="29-promise-finally-方法实现"><a href="#29-promise-finally-方法实现" class="headerlink" title="29. promise finally 方法实现"></a>29. promise finally 方法实现</h3><p>调用当前 Promise 的 then 方法返回一个新的 Promise 对象（保证链式调用）<br>调用 Promise 中的 resolve 方法进行返回</p>
<pre class=" language-js"><code class="language-js">
Promise<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token keyword">finally</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
    <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> err<span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="30-sleep函数的多种实现"><a href="#30-sleep函数的多种实现" class="headerlink" title="30. sleep函数的多种实现"></a>30. sleep函数的多种实现</h3><p>JS没有语言内置的休眠（sleep or wait）函数，所谓的sleep只是实现一种延迟执行的效果<br>等待指定时间后再执行对应方法</p>
<ul>
<li>循环阻止</li>
<li>定时器</li>
<li>promise</li>
<li>async await的promise实现</li>
</ul>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">sleep1</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> start <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start <span class="token operator">&lt;</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">continue</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 方式二： 定时器</span>
<span class="token keyword">function</span> <span class="token function">sleep2</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 方式三：promise</span>
<span class="token keyword">function</span> <span class="token function">sleep3</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 方式四：async await</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">sleep4</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"fn"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>

<span class="token function">sleep1</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">sleep2</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">sleep3</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">sleep4</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="手写map"><a href="#手写map" class="headerlink" title="手写map"></a>手写map</h3><pre class=" language-js"><code class="language-js">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>selfMap <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> content<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// map中的第二个参数作为fn函数的this</span>
  <span class="token comment" spellcheck="true">// Array.prototype.slice.call将类数组转化为数组，同Array.from, this为调用的数组（arr）</span>
  <span class="token keyword">let</span> arr <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> mappedArr <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建一个空数组</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 判断稀疏数组，跳过稀疏数组中的空值</span>
    <span class="token comment" spellcheck="true">// 稀疏数组：数组中元素的个数小于数组的长度，比如Array(2) 长度为2的稀疏数组</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>arr<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
    mappedArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> mappedArr<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">selfMap</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> item <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [2, 4, 6]</span>
</code></pre>
<h3 id="前端错误捕获"><a href="#前端错误捕获" class="headerlink" title="前端错误捕获"></a>前端错误捕获</h3><p>错误信息分为以下几种：</p>
<ul>
<li>JS 代码运行错误、语法错误等</li>
<li>异步错误等</li>
<li>静态资源加载错误</li>
<li>接口请求报错</li>
</ul>
<p>try/catch 只能捕获常规的运行错误，语法错误和异步错误无法捕获<br>window.onerror 可以捕获常规的错误、异步错误、但不能捕获资源错误<br>window.addEventListener 当静态资源加载失败时，会触发error事件<br>promise错误，无法被以上几种捕获，可通过unhandledrejection 事件来处理</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// unhandledrejection 可以捕获Promise中的错误 ✅</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"unhandledrejection"</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"捕获到异常"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// preventDefault阻止传播，不会在控制台打印</span>
  e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>vue 错误 window.onerror 和 error 事件不能捕获到常规的代码错误,vue 通过 Vue.config.errorHander 来捕获异常：</p>
<pre class=" language-js"><code class="language-js">Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>errorHandler <span class="token operator">=</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> vm<span class="token punctuation">,</span> info<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'进来啦~'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>React 错误<br>从 react16 开始，官方提供了 ErrorBoundary 错误边界的功能，被该组件包裹的子组件，render 函数报错时会触发离当前组件最近父组件的ErrorBoundary，生产环境，一旦被 ErrorBoundary 捕获的错误，也不会触发全局的 window.onerror 和 error 事件<br>react项目中，可以在 componentDidCatch 中将捕获的错误上报</p>
<p>跨域问题：如果当前页面中，引入了其他域名的JS资源，如果资源出现错误，error 事件只会监测到一个 script error 的异常。是由于浏览器基于安全考虑，故意隐藏了其它域JS文件抛出的具体错误信息，这样可以有效避免敏感信息无意中被第三方(不受控制的)脚本捕获到，因此，浏览器只允许同域下的脚本捕获具体的错误信息</p>
<p>接口错误<br>1）拦截XMLHttpRequest请求示例：</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">xhrReplace</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token string">"XMLHttpRequest"</span> <span class="token keyword">in</span> window<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> originalXhrProto <span class="token operator">=</span> XMLHttpRequest<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 重写XMLHttpRequest 原型上的open方法</span>
  <span class="token function">replaceAop</span><span class="token punctuation">(</span>originalXhrProto<span class="token punctuation">,</span> <span class="token string">"open"</span><span class="token punctuation">,</span> originalOpen <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 获取请求的信息</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_xhr <span class="token operator">=</span> <span class="token punctuation">{</span>
        method<span class="token punctuation">:</span> <span class="token keyword">typeof</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">"string"</span> <span class="token operator">?</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        url<span class="token punctuation">:</span> args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        startTime<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        type<span class="token punctuation">:</span> <span class="token string">"xhr"</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">// 执行原始的open方法</span>
      originalOpen<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 重写XMLHttpRequest 原型上的send方法</span>
  <span class="token function">replaceAop</span><span class="token punctuation">(</span>originalXhrProto<span class="token punctuation">,</span> <span class="token string">"send"</span><span class="token punctuation">,</span> originalSend <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 当请求结束时触发，无论请求成功还是失败都会触发</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"loadend"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> <span class="token punctuation">{</span> responseType<span class="token punctuation">,</span> response<span class="token punctuation">,</span> status <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> endTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_xhr<span class="token punctuation">.</span>reqData <span class="token operator">=</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_xhr<span class="token punctuation">.</span>status <span class="token operator">=</span> status<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"json"</span><span class="token punctuation">,</span> <span class="token string">"text"</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>responseType<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>_xhr<span class="token punctuation">.</span>responseText <span class="token operator">=</span>
            <span class="token keyword">typeof</span> response <span class="token operator">===</span> <span class="token string">"object"</span> <span class="token operator">?</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span> <span class="token punctuation">:</span> response<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 获取接口的请求时长</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_xhr<span class="token punctuation">.</span>elapsedTime <span class="token operator">=</span> endTime <span class="token operator">-</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_xhr<span class="token punctuation">.</span>startTime<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 上报xhr接口数据</span>
        <span class="token function">reportData</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_xhr<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">// 执行原始的send方法</span>
      originalSend<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/**
 * 重写指定的方法
 * @param { object } source 重写的对象
 * @param { string } name 重写的属性
 * @param { function } fn 拦截的函数
 */</span>
<span class="token keyword">function</span> <span class="token function">replaceAop</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> name<span class="token punctuation">,</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>source <span class="token operator">===</span> undefined<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token keyword">in</span> source<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> original <span class="token operator">=</span> source<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> wrapped <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> wrapped <span class="token operator">===</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      source<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> wrapped<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>拦截fetch为例</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fetchReplace</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token string">"fetch"</span> <span class="token keyword">in</span> window<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 重写fetch方法</span>
  <span class="token function">replaceAop</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> <span class="token string">"fetch"</span><span class="token punctuation">,</span> originalFetch <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> config<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> sTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">const</span> method <span class="token operator">=</span> <span class="token punctuation">(</span>config <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>method<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token string">"GET"</span><span class="token punctuation">;</span>
      <span class="token keyword">let</span> handlerData <span class="token operator">=</span> <span class="token punctuation">{</span>
        type<span class="token punctuation">:</span> <span class="token string">"fetch"</span><span class="token punctuation">,</span>
        method<span class="token punctuation">,</span>
        reqData<span class="token punctuation">:</span> config <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>body<span class="token punctuation">,</span>
        url
      <span class="token punctuation">}</span><span class="token punctuation">;</span>

      <span class="token keyword">return</span> originalFetch<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> <span class="token punctuation">[</span>url<span class="token punctuation">,</span> config<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
        res <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
          <span class="token comment" spellcheck="true">// res.clone克隆，防止被标记已消费</span>
          <span class="token keyword">const</span> tempRes <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">const</span> eTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          handlerData <span class="token operator">=</span> <span class="token punctuation">{</span>
            <span class="token operator">...</span>handlerData<span class="token punctuation">,</span>
            elapsedTime<span class="token punctuation">:</span> eTime <span class="token operator">-</span> sTime<span class="token punctuation">,</span>
            status<span class="token punctuation">:</span> tempRes<span class="token punctuation">.</span>status
          <span class="token punctuation">}</span><span class="token punctuation">;</span>
          tempRes<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
            handlerData<span class="token punctuation">.</span>responseText <span class="token operator">=</span> data<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 上报fetch接口数据</span>
            <span class="token function">reportData</span><span class="token punctuation">(</span>handlerData<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

          <span class="token comment" spellcheck="true">// 返回原始的结果，外部继续使用then接收</span>
          <span class="token keyword">return</span> res<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
          <span class="token keyword">const</span> eTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          handlerData <span class="token operator">=</span> <span class="token punctuation">{</span>
            <span class="token operator">...</span>handlerData<span class="token punctuation">,</span>
            elapsedTime<span class="token punctuation">:</span> eTime <span class="token operator">-</span> sTime<span class="token punctuation">,</span>
            status<span class="token punctuation">:</span> <span class="token number">0</span>
          <span class="token punctuation">}</span><span class="token punctuation">;</span>
          <span class="token comment" spellcheck="true">// 上报fetch接口数据</span>
          <span class="token function">reportData</span><span class="token punctuation">(</span>handlerData<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">throw</span> err<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="首屏加载时间计算"><a href="#首屏加载时间计算" class="headerlink" title="首屏加载时间计算"></a>首屏加载时间计算</h3><p>首屏加载时间和首页加载时间不一样，首屏指的是屏幕内的dom渲染完成的时间<br>比如首页很长需要好几屏展示，这种情况下屏幕以外的元素不考虑在内<br>计算首屏加载时间流程</p>
<p>1）利用MutationObserver监听document对象，每当dom变化时触发该事件</p>
<p>2）判断监听的dom是否在首屏内，如果在首屏内，将该dom放到指定的数组中，记录下当前dom变化的时间点</p>
<p>3）在MutationObserver的callback函数中，通过防抖函数，监听document.readyState状态的变化</p>
<p>4）当document.readyState === ‘complete’，停止定时器和取消对document的监听</p>
<p>5）遍历存放dom的数组，找出最后变化节点的时间，用该时间点减去performance.timing.navigationStart 得出首屏的加载时间</p>
<h3 id="图片打点上报的优势："><a href="#图片打点上报的优势：" class="headerlink" title="图片打点上报的优势："></a>图片打点上报的优势：</h3><p>1）支持跨域，一般而言，上报域名都不是当前域名，上报的接口请求会构成跨域<br>2）体积小且不需要插入dom中<br>3）不需要等待服务器返回数据<br>图片打点缺点是：url受浏览器长度限制</p>
<h3 id="浏览器事件循环机制"><a href="#浏览器事件循环机制" class="headerlink" title="浏览器事件循环机制"></a>浏览器事件循环机制</h3><p>事件循环其实就是在事件驱动模式中来管理和执行事件的一套流程。包括两种，一种是事件驱动，另外一种是状态驱动或数据驱动。<br>在事件驱动中，当有事件触发后，被触发的事件会按顺序暂时存在一个队列中，待 JS 的同步任务执行完成后，会从这个队列中取出要处理的事件并进行处理</p>
<p>JS 按顺序执行执行栈中的方法，每次执行一个方法时，会为这个方法生成独有的执行环境（上下文 context)，待这个方法执行完成后，销毁当前的执行环境，并从栈中弹出此方法（即消费完成），然后继续下一个方法。在事件驱动的模式下，至少包含了一个执行循环来检测任务队列是否有新的任务。通过不断循环去取出异步回调来执行，这个过程就是事件循环，而每一次循环就是一个事件周期或称为一次 tick。</p>
<p>事件循环的过程中，执行栈在同步代码执行完成后，优先检查微任务队列是否有任务需要执行，如果没有，再去宏任务队列检查是否有任务执行，如此往复。微任务一般在当前循环就会优先执行，而宏任务会等到下一次循环，因此，微任务一般比宏任务先执行，并且微任务队列只有一个，宏任务队列可能有多个。另外我们常见的点击和键盘等事件也属于宏任务。<br>根据任务的种类不同，可以分为微任务（micro task）队列和宏任务（macro task）队列。<br>常见宏任务：setTimeout() setInterval()<br>常见微任务：promise.then() MutaionObserver nextTick</p>
<h3 id="关于SVG-和-Canvas-的区别。"><a href="#关于SVG-和-Canvas-的区别。" class="headerlink" title="关于SVG 和 Canvas 的区别。"></a>关于SVG 和 Canvas 的区别。</h3><p>1、SVG 不能绘制图片，而 canvas 可以。SVG是通过 XML 绘制，而Canvas通过 js 绘制<br>2、Canvas绘制的方式，是通过 js 逐像素渲染的。也就是说，它绘制一个复杂的图形和一个简单的图形的性能是差不多的。<br>SVG 是通过 XML 的方式渲染。它的本质是DOM，而复杂的图形，就会降低其渲染性能。<br>3、Canvas 是依赖分辨率，是一种标量图。所以在放缩的时候，存在失真的问题。<br>SVG 绘制的时候，不依赖分辨率，是一种矢量图。所以当SVG放缩的时候，不会使得图像失真。<br>4、SVG 适合带有大型渲染区域的应用程序：比如谷歌地图、百度地图。</p>
<h3 id="promise和async-x2F-await-的区别"><a href="#promise和async-x2F-await-的区别" class="headerlink" title="promise和async/await 的区别"></a>promise和async/await 的区别</h3><p>唯一的区别在于 <code>promise</code> 和 <code>async/await</code> 的执行上下文。</p>
<p>当创建 Promise 并启动异步操作时，创建 Promise 后的代码会继续同步执行。当 Promise 被解析或拒绝时，附加的回调函数会被添加到微任务队列中。微任务队列会在当前任务完成后，但在下一个任务从任务队列中处理出来之前进行处理。这意味着在创建 Promise 之后的任何代码都将在执行附加到 Promise 的回调函数之前执行。</p>
<p>另一方面，在使用 async/await 时， await 关键字会使 JavaScript 引擎暂停执行 async 函数，直到 Promise 解析或被拒绝。当 async 函数等待 Promise 解析时，它不会阻塞调用栈，因此可以执行任何其他同步代码。一旦 Promise 解析完毕， async 函数将继续执行，并返回 Promise 的结果。如果被拒绝，则会抛出一个错误值。</p>
<h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><h4 id="loader-和plugin的区别"><a href="#loader-和plugin的区别" class="headerlink" title="loader 和plugin的区别"></a>loader 和plugin的区别</h4><p>loader即为文件加载器，操作的是文件，将文件A通过loader转换成文件B，是一个单纯的文件转化过程。<br>plugin即为插件，是一个扩展器，丰富webpack本身，增强功能 ，针对的是在loader结束之后，webpack打包的整个过程，他并不直接操作文件，而是基于事件机制工作，监听webpack打包过程中的某些节点，执行广泛的任务。</p>
<ul>
<li>Loader 特性:</li>
</ul>
<ul>
<li>链式传递，按照配置时相反的顺序链式执行;</li>
<li>基于 Node 环境，拥有 较高权限，比如文件的增删查改; 可同步也可异步;</li>
</ul>
<ul>
<li>编写原则:</li>
</ul>
<ul>
<li>单一原则: 每个 Loader 只做一件事;</li>
<li>链式调用: Webpack 会按顺序链式调用每个 Loader;</li>
<li>统一原则: 遵循 Webpack 制定的设计规则和结构，输入与输出均为字符串，各个 Loader 完全独立，即插即用;</li>
</ul>
<ul>
<li>plugin<br>在编译的整个生命周期中，Webpack 会触发许多事件钩子， Plugin 可以监听这些事件，根据需求在相应的时间点对打包内容进行定向的修改。</li>
</ul>
<p>Plugin的组成部分<br>1）Plugin的本质是一个 node 模块，这个模块导出一个JavaScript 类<br>2）它的原型上需要定义一个apply 的方法<br>3）通过compiler获取webpack内部的钩子，获取webpack打包过程中的各个阶段<br>钩子分为同步和异步的钩子，异步钩子必须执行对应的回调<br>4）通过compilation操作webpack内部实例特定数据<br>5）功能完成后，执行webpack提供的cb回调</p>
<ul>
<li>事件流机制<br>Webpack 就像工厂中的一条产品流水线。原材料经过 Loader 与 Plugin 的一道道处理，最后输出结果。</li>
</ul>
<ul>
<li>通过链式调用，按顺序串起一个个 Loader;</li>
<li>通过事件流机制，让 Plugin 可以插入到整个生产过程中的每个步骤中;</li>
</ul>
<p>Webpack 事件流编程范式的核心是基础类<code> Tapable</code> ，是一种 观察者模式 的实现事件的订阅与广播:<br>Webpack 中两个最重要的类 <code>Compiler</code> 与 <code>Compilation</code> 便是继承于 Tapable，也拥有这样的事件流机制。</p>
<ul>
<li>Compiler: 可以简单的理解为 Webpack 实例，它包含了当前 Webpack 中的所有配置信息，如 options， loaders, plugins 等信息，全局唯一，只在启动时完成初始化创建，随着生命周期逐一传递; </li>
<li>Compilation: 可以称为 编译实例。当监听到文件发生改变时，Webpack 会创建一个新的 Compilation 对象，开始一次新的编译。它包含了当前的输入资源，输出资源，变化的文件等，同时通过它提供的 api，可 以监听每次编译过程中触发的事件钩子;</li>
</ul>
<p>区别:</p>
<ul>
<li>Compiler 全局唯一，且从启动生存到结束;</li>
<li>Compilation 对应每次编译，每轮编译循环均会重新创建;</li>
</ul>
<h5 id="常用-Plugin"><a href="#常用-Plugin" class="headerlink" title="常用 Plugin:"></a>常用 Plugin:</h5><ul>
<li>UglifyJsPlugin: 压缩、混淆代码;</li>
<li>Optimization.splitChunks: 代码分割;</li>
<li>ProvidePlugin: 自动加载模块;</li>
<li>html-webpack-plugin: 加载 html 文件，并引入 css / js 文件; </li>
<li>extract-text-webpack-plugin / mini-css-extract-plugin: 抽离样式，生成 css 文件; </li>
<li>DefinePlugin: 定义全局变量;</li>
<li>optimize-css-assets-webpack-plugin: CSS 代码去重; </li>
<li>webpack-bundle-analyzer: 代码分析;</li>
<li>compression-webpack-plugin: 使用 gzip 压缩 js 和 css; </li>
<li>happypack: 使用多进程，加速代码构建; </li>
<li>EnvironmentPlugin: 定义环境变量;</li>
</ul>
<h4 id="优化技巧"><a href="#优化技巧" class="headerlink" title="优化技巧"></a>优化技巧</h4><p>缓存、加快打包速度、缩小打包体积</p>
<ol>
<li>缓存，比如bable-loader 添加cacheDirectory为true来开启缓存</li>
</ol>
<pre class=" language-js"><code class="language-js"><span class="token punctuation">{</span>
    test<span class="token punctuation">:</span> <span class="token regex">/\.js$/</span><span class="token punctuation">,</span>
    loader<span class="token punctuation">:</span> <span class="token string">'babel-loader'</span><span class="token punctuation">,</span>
    options<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      cacheDirectory<span class="token punctuation">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre>
<p>cacheLoader</p>
<ol start="2">
<li>加快打包速度<br>多核打包，比如使用happyPack/Thread-loader/Parallel-Webpack<br>高效编译，对于JS的编译选用不同的编译器，比如ESBuild 基于Go语言开发的JavaScript Bundler 和SWC 基于Rust的JavaScript Compiler(其生态中也包含打包工具spack), 目前为Next.JS/Parcel/Deno等前端圈知名项目使用</li>
</ol>
<p>3、缩小打包体积</p>
<ul>
<li>使用Tree-shaking、减少打包代码</li>
<li>对于大的模块引入thread-loader</li>
<li>对于不常用的变更抽离出去 ，一种是使用webpack-dll-plugin,在首次构建时候将这些静态依赖打包，另外一种是使用Externals，将这些不常用的静态资源抽离，并用cdn方式引用他们</li>
<li>compression-webpack-plugin 压缩js和css代码</li>
</ul>
<h4 id="什么是Tree-Shark"><a href="#什么是Tree-Shark" class="headerlink" title="什么是Tree-Shark"></a>什么是Tree-Shark</h4><p>摇树优化 (Tree-shaking)，这是一种形象比喻。我们把打包后的代码比喻成一棵树，这里其实表示的就 是，通过工具 “摇” 我们打包后的 js 代码，将没有使用到的无用代码 “摇” 下来 (删除)。即 消除那些被 引用了但未被使用 的模块代码。<br>原理: 由于是在编译时优化，因此最基本的前提就是语法的静态分析，ES6的模块机制提供了这种可能性。不需要运行时，便可进行代码字面上的静态分析，确定相应的依赖关系。<br>问题: 具有副作用的函数无法被 tree-shaking。 在引用一些第三方库，需要去观察其引入的代码 量是不是符合预期; 尽量写纯函数，减少函数的副作用; 可使用 webpack-deep-scope-plugin， 可以进行作用域分析，减少此类情况的发生，但仍需要注意;</p>
<h4 id="performance-对象api"><a href="#performance-对象api" class="headerlink" title="performance 对象api"></a>performance 对象api</h4><p>属性</p>
<ul>
<li>memory</li>
<li>navigation </li>
<li>timing<br><img src="https://img-blog.csdnimg.cn/20200717141446763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0ODE0MDU=,size_16,color_FFFFFF,t_70"></li>
</ul>
<p>方法</p>
<ul>
<li>getEntries() 这个函数返回的将是一个数组，包含了页面中所有的 HTTP 请求</li>
<li>now()  输出的是相对于 performance.timing.navigationStart(页面初始化) 的时间, Date.now() 输出的是 UNIX 时间，即距离 1970 的时间 </li>
<li>mark()  performance.mark() 标记各种时间戳（就像在地图上打点），保存为各种测量值（测量地图上的点之间的距离），便可以批量地分析这些数据了。</li>
</ul>
<p>后来 window.performance.timing 被废弃，通过 PerformanceObserver 旧的 api，返回的是一个 UNIX 类型的绝对时间，和用户的系统时间相关，分析的时候需要再次计算。而新的 api，返回的是一个相对时间，可以直接用来分析</p>
<h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3><p>开发过程中，代码发生变动后，webpack会重新编译，编译后浏览器替换修改的模块，局部更新，无需刷新整个页面</p>
<p>主要是通过websocket实现，建立本地服务和浏览器的双向通信。当代码变化，重新编译后，通知浏览器请求更新的模块，替换原有的模块<br>1） 通过webpack-dev-server开启server服务，本地server启动之后，再去启动websocket服务，建立本地服务和浏览器的双向通信<br>2） webpack每次编译后，会生成一个Hash值，Hash代表每一次编译的标识。本次输出的Hash值会编译新生成的文件标识，被作为下次热更新的标识<br>3）webpack监听文件变化（主要是通过文件的生成时间判断是否有变化），当文件变化后，重新编译<br>4）编译结束后，通知浏览器请求变化的资源，同时将新生成的hash值传给浏览器，用于下次热更新使用<br>5）浏览器拿到更新后的模块后，用新模块替换掉旧的模块，从而实现了局部刷新</p>
<h3 id="模块联邦"><a href="#模块联邦" class="headerlink" title="模块联邦"></a>模块联邦</h3><p>webpack5 模块联邦(Module Federation) 使 JavaScript应用，得以从另一个 JavaScript应用中动态的加载代码，实现共享依赖，用于前端的微服务化<br>比如项目A和项目B，公用项目C组件，以往这种情况，可以将C组件发布到npm上，然后A和B再具体引入。当C组件发生变化后，需要重新发布到npm上，A和B也需要重新下载安装<br>使用模块联邦后，可以在远程模块的Webpack配置中，将C组件模块暴露出去，项目A和项目B就可以远程进行依赖引用。当C组件发生变化后，A和B无需重新引用<br>模块联邦利用webpack5内置的ModuleFederationPlugin插件，实现了项目中间相互引用的按需热插拔</p>
<h3 id="一个简单的AST示例"><a href="#一个简单的AST示例" class="headerlink" title="一个简单的AST示例"></a>一个简单的AST示例</h3><p>let a = 1，转化成AST的结果</p>
<pre class=" language-js"><code class="language-js"><span class="token punctuation">{</span>
  <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"Program"</span><span class="token punctuation">,</span>
  <span class="token string">"start"</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token string">"end"</span><span class="token punctuation">:</span> <span class="token number">9</span><span class="token punctuation">,</span>
  <span class="token string">"body"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"VariableDeclaration"</span><span class="token punctuation">,</span>
      <span class="token string">"start"</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
      <span class="token string">"end"</span><span class="token punctuation">:</span> <span class="token number">9</span><span class="token punctuation">,</span>
      <span class="token string">"declarations"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">{</span>
          <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"VariableDeclarator"</span><span class="token punctuation">,</span>
          <span class="token string">"start"</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span>
          <span class="token string">"end"</span><span class="token punctuation">:</span> <span class="token number">9</span><span class="token punctuation">,</span>
          <span class="token string">"id"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
            <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"Identifier"</span><span class="token punctuation">,</span>
            <span class="token string">"start"</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span>
            <span class="token string">"end"</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span>
            <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"a"</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span>
          <span class="token string">"init"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
            <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"Literal"</span><span class="token punctuation">,</span>
            <span class="token string">"start"</span><span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">,</span>
            <span class="token string">"end"</span><span class="token punctuation">:</span> <span class="token number">9</span><span class="token punctuation">,</span>
            <span class="token string">"value"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
            <span class="token string">"raw"</span><span class="token punctuation">:</span> <span class="token string">"1"</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token string">"kind"</span><span class="token punctuation">:</span> <span class="token string">"let"</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token string">"sourceType"</span><span class="token punctuation">:</span> <span class="token string">"module"</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="koa和express的区别"><a href="#koa和express的区别" class="headerlink" title="koa和express的区别"></a>koa和express的区别</h3><p>express框架是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，主要基于 Connect 中间件，并且自身封装了路由、视图处理等功能。</p>
<p>koa是 Express 原班人马基于 ES6 新特性重新开发的框架，主要基于 co 中间件，框架自身不包含任何中间件，很多功能需要借助第三方中间件解决，但是由于其基于 ES6 generator 特性的异步流程控制，解决了 “callback hell” 和麻烦的错误处理问题。</p>
<p>相同点<br>两个框架都对http进行了封装。相关的api都差不多，同一批人所写。</p>
<p>不同点<br>express内置了许多中间件可供使用，而koa没有。</p>
<p>express包含路由，视图渲染等特性，而koa只有http模块。</p>
<p>express的中间件模型为线型，而koa的中间件模型为U型，也可称为洋葱模型构造中间件。</p>
<p>express通过回调实现异步函数，在多个回调、多个中间件中写起来容易逻辑混乱。</p>
<h3 id="node的错误监控"><a href="#node的错误监控" class="headerlink" title="node的错误监控"></a>node的错误监控</h3><p>try catch 通常用于捕获throw抛出的错误</p>
<p>callback(err, result)回调函数处理</p>
<p>Emitter.on的回调函数 on注册了事件和回调函数， 并且在emit触发事件后会执行回调函数，以达到捕获错误的解决方式。</p>
<p>process.on(“error”, function(err){})<br>错误异常有两种场景的出现：</p>
<p>一种是代码运行中throw new error没有被捕获，另一种是Promise的失败回调函数，没有对应的reject回调函数处理，针对这两种情况Nodejs都有默认的统一处理方式，就是给整个进程process对象监听相应的错误事件。<br>process.on(‘uncaughtException’,function(err){}) //监听未捕获的异常<br>process.on(‘unhandledRejection’,function(err,promise){}) //监听Promise没有被捕获的失败函数</p>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h4><p>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p>
<h4 id="http的请求报文和返回报文"><a href="#http的请求报文和返回报文" class="headerlink" title="http的请求报文和返回报文"></a>http的请求报文和返回报文</h4><ul>
<li>请求报文：</li>
</ul>
<ul>
<li>accept-charset</li>
<li>accept-encoding</li>
<li>accept-language</li>
<li>Host</li>
<li>User-agent</li>
<li>connection</li>
<li>cookie</li>
<li>If-Modified-Since</li>
</ul>
<ul>
<li>返回报文</li>
</ul>
<ul>
<li>server</li>
<li>content-type</li>
<li>content-encoding</li>
<li>content-language</li>
<li>keep-alive</li>
<li>ETag</li>
<li>cache-control</li>
<li>Expires</li>
<li>last-Modified</li>
<li>access-control-allow-origin：</li>
</ul>
<h4 id="tcp和udp-的区别"><a href="#tcp和udp-的区别" class="headerlink" title="tcp和udp 的区别"></a>tcp和udp 的区别</h4><p>tcp：面向连接、传输可靠，可用于传输大量数据,速度慢，建立连接需要开销较多<br>udp: 面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快 ,可能丢包</p>
<h4 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h4><p>多了一层SSL加密，<br>客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。服务器公钥放在数字证书中。</p>
<h4 id="http2-0-和http1-的区别"><a href="#http2-0-和http1-的区别" class="headerlink" title="http2.0 和http1 的区别"></a>http2.0 和http1 的区别</h4><ul>
<li>多路复用：相同域名多个请求，共享同一个TCP连接，降低了延迟</li>
<li>请求优先级：给每个request设置优先级</li>
<li>服务端推送：可以主动向客户端发送消息。</li>
<li>头部压缩：减少包的大小跟数量</li>
</ul>
<h4 id="tcp-三次握手"><a href="#tcp-三次握手" class="headerlink" title="tcp 三次握手"></a>tcp 三次握手</h4><p>客户端 发送SYN 包<br>服务端接受并发生SYN+ACK包<br>客户端接受ACK包并发送至服务端，建立连接</p>
<h4 id="tcp-四次挥手"><a href="#tcp-四次挥手" class="headerlink" title="tcp 四次挥手"></a>tcp 四次挥手</h4><p>客户端发出FIN包，进入FIN-WAIT<br>服务端发出确认报文 ACK 进入 CLOSE-WAIT<br>服务端发送连接释放报文，进入LAST-ACK<br>客户端发出ACK，等待2*MSL（最长报文段寿命）进入closed状态</p>
<h4 id="http-code"><a href="#http-code" class="headerlink" title="http code"></a>http code</h4><p>1xx：信息，请求收到，继续处理<br>2xx：成功，行为被成功地接受、理解和采纳<br>3xx：重定向，为了完成请求，必须进一步执行的动作<br>4xx：客户端错误，请求包含语法错误或者请求无法实现<br>5xx：服务器错误，服务器不能实现一种明显无效的请求 </p>
<p>200 OK：客户端请求成功<br>201 用户新建或修改数据成功<br>202 一个请求已经进入后台<br>204 No Content：无内容。服务器成功处理，但未返回内容。一般用在只是客户端向服务器发送信息，而服务器不用向客户端返回什么信息的情况。不会刷新页面。<br>206 Partial Content：服务器已经完成了部分GET请求（客户端进行了范围请求）。响应报文中包含Content-Range指定范围的实体内容</p>
<p>301 Moved Permanently：永久重定向，表示请求的资源已经永久的搬到了其他位置。</p>
<p>302 Found：临时重定向，表示请求的资源临时搬到了其他位置</p>
<p>303 See Other：临时重定向，应使用GET定向获取请求资源。303功能与302一样，区别只是303明确客户端应该使用GET访问</p>
<p>307 Temporary Redirect：临时重定向，和302有着相同含义。POST不会变成GET</p>
<p>304 Not Modified：表示客户端发送附带条件的请求（GET方法请求报文中的IF…）时，条件不满足。返回304时，不包含任何响应主体。虽然304被划分在3XX，但和重定向一毛钱关系都没有</p>
<p>400 Bad Request：客户端请求有语法错误，服务器无法理解。<br>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。<br>403 Forbidden：服务器收到请求，但是拒绝提供服务<br>404 Not Found：请求资源不存在。比如，输入了错误的url<br>415 Unsupported media type：不支持的媒体类型</p>
<p>500 Internal Server Error：服务器发生不可预期的错误。<br>502 网关错误<br>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常<br>504 网关超时<br>505 HTTP版本未被支持</p>
<h4 id="websocket的连接原理"><a href="#websocket的连接原理" class="headerlink" title="websocket的连接原理"></a>websocket的连接原理</h4><p>轮询<br>客户端通过一定的时间间隔以频繁请求的方式向服务器发送请求，来保持客户端和服务器端的数据同步。问题很明显，当客户端以固定频率向服务器端发送请求时，服务器端的数据可能并没有更新，带来很多无谓请求，浪费带宽，效率低下。</p>
<p>从上文可以看出，传统 Web 模式在处理高并发及实时性需求的时候，会遇到难以逾越的瓶颈，我们需要一种高效节能的双向通信机制来保证数据的实时传输。在此背景下，基于 HTML5 规范的、有 Web TCP 之称的 WebSocket 应运而生。</p>
<p>WebSocket 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯，它建立在 TCP 之上，同 HTTP 一样通过 TCP 来传输数据，但是它和 HTTP 最大不同是：</p>
<p>WebSocket 是一种双向通信协议，在建立连接后，WebSocket 服务器和 Browser/Client Agent 都能主动的向对方发送或接收数据，就像 Socket 一样；<br>WebSocket 需要类似 TCP 的客户端和服务器端通过握手连接，连接成功后才能相互通信。</p>
<h4 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h4><p>跨域是指一个域下的文档或脚本试图去请求另一个域下的资源</p>
<p>什么是同源策略？<br>同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。<br>同源策略限制以下几种行为：</p>
<ol>
<li>Cookie、LocalStorage 和 IndexDB 无法读取</li>
<li>DOM 和 Js对象无法获得</li>
<li>AJAX 请求不能发送</li>
</ol>
<p>跨域解决方案<br>1、 通过jsonp跨域<br>2、 document.domain + iframe跨域<br>3、 location.hash + iframe<br>4、 window.name + iframe跨域<br>5、 postMessage跨域<br>6、 跨域资源共享（CORS）<br>7、 nginx代理跨域<br>8、 nodejs中间件代理跨域<br>9、 WebSocket协议跨域</p>
<h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><p>预检请求是在进行跨域资源共享 CORS 时，由浏览器自动发起的一种 OPTIONS 请求。它的存在是为了保障安全，并允许服务器决定是否允许跨域请求。</p>
<p>跨域请求是指在浏览器中向不同域名、不同端口或不同协议的资源发送请求。出于安全原因，浏览器默认禁止跨域请求，只允许同源策略。而当网页需要进行跨域请求时，浏览器会自动发送一个预检请求，以确定是否服务器允许实际的跨域请求。</p>
<p>预检请求中包含了一些额外的头部信息，如 Origin 和 Access-Control-Request-Method 等，用于告知服务器实际请求的方法和来源。服务器收到预检请求后，可以根据这些头部信息，进行验证和授权判断。如果服务器认可该跨域请求，将返回一个包含 Access-Control-Allow-Origin 等头部信息的响应，浏览器才会继续发送实际的跨域请求。</p>
<p>使用预检请求机制可以有效地防范跨域请求带来的安全风险，保护用户数据和隐私。</p>
<h3 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h3><p>该安全策略的实现基于一个称作 Content-Security-Policy的 HTTP 首部。<br>可以移步MDN，有更加规范的解释。我在这里就是梳理一下吧。<br>CSP，即浏览器中的内容安全策略，它的核心思想大概就是服务器决定浏览器加载哪些资源，具体来说有几个功能</p>
<ul>
<li>限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；</li>
<li>禁止向第三方域提交数据，这样用户数据也不会外泄；</li>
<li>提供上报机制，能帮助我们及时发现 XSS 攻击。</li>
<li>禁止执行内联脚本和未授权的脚本；</li>
</ul>
<h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><h4 id="react生命周期"><a href="#react生命周期" class="headerlink" title="react生命周期"></a>react生命周期</h4><ul>
<li>constructor（并不属于生命周期 - 初始化 state，初始化参数）</li>
<li>static getDerivedStateFormPorps - 组件 props 变化时更新 state</li>
<li>componentDidMount - 网络请求，添加监听事件等</li>
<li>shouldComponentUpdate - 通过判断新传入的 props，优化性能，避免重复渲染</li>
<li>static getSnapshopBeforeUpdate - 很少用，组件更新之前捕获一些信息（例如滚动位置）</li>
<li>componentDidUpdate - 组件更新完成后的一些操作</li>
<li>componentWillUnmount - 卸载监听事件，卸载计时器等</li>
<li>componentDidUnmount()</li>
</ul>
<h4 id="react-Fiber"><a href="#react-Fiber" class="headerlink" title="react Fiber"></a>react Fiber</h4><p>React 的核心流程可以分为两个部分:</p>
<p>reconciliation (调度算法，也可称为 render):</p>
<p>更新 state 与 props；<br>调用生命周期钩子；<br>生成 virtual dom；</p>
<p>这里应该称为 Fiber Tree 更为符合；</p>
<p>通过新旧 vdom 进行 diff 算法，获取 vdom change；<br>确定是否需要重新渲染</p>
<ul>
<li>Render 阶段就是根据每个组件中的状态构建出一个新的 UI Tree，也叫WorkInProgress Tree，并为每一个结点对应的操作打上 EffectTag，即更新、删除、新增。全部构建完成后就进入下一阶段。</li>
</ul>
<p>commit:</p>
<ul>
<li>Commit 阶段就是将构建好的 WIP Tree 反应到浏览器中，即 React 为我们自动进行相应的 dom 操作，保持 UI 一致性。<br>如需要，则操作 dom 节点更新；</li>
</ul>
<p>要了解 Fiber，我们首先来看为什么需要它？</p>
<p>问题: 随着应用变得越来越庞大，整个更新渲染的过程开始变得吃力，大量的组件渲染会导致主进程长时间被占用，导致一些动画或高频操作出现卡顿和掉帧的情况。而关键点，便是 同步阻塞。在之前的调度算法中，React 需要实例化每个类组件，生成一颗组件树，使用 同步递归 的方式进行遍历渲染，而这个过程最大的问题就是无法 暂停和恢复。</p>
<p>解决方案: 解决同步阻塞的方法，通常有两种: 异步 与 任务分割。而 React Fiber 便是为了实现任务分割而诞生的。</p>
<p>简述:</p>
<p>在 React V16 将调度算法进行了重构， 将之前的 stack reconciler 重构成新版的 fiber reconciler，变成了具有链表和指针的 单链表树遍历算法。通过指针映射，每个单元都记录着遍历当下的上一步与下一步，从而使遍历变得可以被暂停和重启。<br>这里我理解为是一种 任务分割调度算法，主要是 将原先同步更新渲染的任务分割成一个个独立的 小任务单位，根据不同的优先级，将小任务分散到浏览器的空闲时间执行，充分利用主进程的事件循环机制。</p>
<p>核心:</p>
<p>Fiber 这里可以具象为一个 数据结构:</p>
<pre class=" language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name">Fiber</span> <span class="token punctuation">{</span>
    <span class="token keyword">constructor</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>instance <span class="token operator">=</span> instance
        <span class="token comment" spellcheck="true">// 指向第一个 child 节点</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>child <span class="token operator">=</span> child
        <span class="token comment" spellcheck="true">// 指向父节点</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">return</span> <span class="token operator">=</span> parent
        <span class="token comment" spellcheck="true">// 指向第一个兄弟节点</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>sibling <span class="token operator">=</span> previous
    <span class="token punctuation">}</span>	
<span class="token punctuation">}</span>
</code></pre>
<p>链表树遍历算法: 通过 节点保存与映射，便能够随时地进行 停止和重启，这样便能达到实现任务分割的基本前提；</p>
<p>1、首先通过不断遍历子节点，到树末尾；<br>2、开始通过 sibling 遍历兄弟节点；<br>3、return 返回父节点，继续执行2；<br>4、直到 root 节点后，跳出遍历；</p>
<p>任务分割，React 中的渲染更新可以分成两个阶段:</p>
<p>reconciliation 阶段: vdom 的数据对比，是个适合拆分的阶段，比如对比一部分树后，先暂停执行个动画调用，待完成后再回来继续比对。<br>Commit 阶段: 将 change list 更新到 dom 上，并不适合拆分，才能保持数据与 UI 的同步。否则可能由于阻塞 UI 更新，而导致数据更新和 UI 不一致的情况。</p>
<p>分散执行: 任务分割后，就可以把小任务单元分散到浏览器的空闲期间去排队执行，而实现的关键是两个新API: <code>requestIdleCallback</code> 与 <code>requestAnimationFrame</code></p>
<p>低优先级的任务交给<code>requestIdleCallback</code>处理，这是个浏览器提供的事件循环空闲期的回调函数，需要 pollyfill，而且拥有 deadline 参数，限制执行事件，以继续切分任务；<br>高优先级的任务交给<code>requestAnimationFrame</code>处理；</p>
<pre class=" language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// 类似于这样的方式</span>
<span class="token function">requestIdleCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span>deadline<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 当有空闲时间时，我们执行一个组件渲染；</span>
    <span class="token comment" spellcheck="true">// 把任务塞到一个个碎片时间中去；</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>deadline<span class="token punctuation">.</span><span class="token function">timeRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> deadline<span class="token punctuation">.</span>didTimeout<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nextComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        nextComponent <span class="token operator">=</span> <span class="token function">performWork</span><span class="token punctuation">(</span>nextComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>优先级策略: 文本框输入 &gt; 本次调度结束需完成的任务 &gt; 动画过渡 &gt; 交互反馈 &gt; 数据更新 &gt; 不会显示但以防将来会显示的任务</p>
<p>Fiber 其实可以算是一种编程思想，在其它语言中也有许多应用(Ruby Fiber)。核心思想是 任务拆分和协同，主动把执行权交给主线程，使主线程有时间空挡处理其他高优先级任务。</p>
<h4 id="react-优化"><a href="#react-优化" class="headerlink" title="react 优化"></a>react 优化</h4><p>pureComponent 浅比较<br>shouldComponentUpdate 深比较</p>
<p>hooks优化<br>React.memo<br>react.<br>useMemo useMemo 是一种缓存机制提速，当它的依赖未发生改变时，就不会触发重新计算。<br>useCallback  针对传入子组件的为函数，进行优化使用，因为函数式组件每次发生渲染，都会从头执行，两次的callBack函数发生了改变，导致子组件渲染。useCallback 针对函数进行记忆，从而避免触发渲染。</p>
<h4 id="setState-是异步还是同步的？"><a href="#setState-是异步还是同步的？" class="headerlink" title="setState 是异步还是同步的？"></a>setState 是异步还是同步的？</h4><p>在React管理的事件回调和生命周期中，是异步的，其他是同步的，因为来做批量更新，减少渲染。<br>但在函数式组件中不存在这个问题。因为函数组件中生成的函数是通过闭包引用了 state，而不是通过 this.state 的方式引用 state，所以函数组件的处理函数中 state 一定是旧值，不可能是新值。可以说函数组件已经将这个问题屏蔽掉了。</p>
<h4 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h4><p>state<br>Action<br>reducer 处理state</p>
<h4 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h4><p>纯函数<br>函数复合<br>数据不可变性<br>函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单元函数，组合调用操作数据流；<br>它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部 / 副作用；</p>
<h4 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h4><p>react 中的 HOC 高阶组件，就是一个函数，接受一个组件作为参数，返回一个新的组件<br>例如一个loading的高阶组件</p>
<pre class=" language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// high order component</span>
<span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span>
<span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">'axios'</span>

<span class="token keyword">interface</span> <span class="token class-name">ILoaderState</span> <span class="token punctuation">{</span>
  data<span class="token punctuation">:</span> <span class="token keyword">any</span><span class="token punctuation">,</span>
  isLoading<span class="token punctuation">:</span> <span class="token keyword">boolean</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">ILoaderProps</span> <span class="token punctuation">{</span>
  data<span class="token punctuation">:</span> <span class="token keyword">any</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> withLoader <span class="token operator">=</span> <span class="token operator">&lt;</span>P <span class="token keyword">extends</span> <span class="token class-name">ILoaderState</span><span class="token operator">></span><span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">:</span> React<span class="token punctuation">.</span>ComponentType<span class="token operator">&lt;</span>P<span class="token operator">></span><span class="token punctuation">,</span> url<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">LoaderComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token operator">&lt;</span>Partial<span class="token operator">&lt;</span>ILoaderProps<span class="token operator">></span><span class="token punctuation">,</span> ILoaderState<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">:</span> <span class="token keyword">any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
        data<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
        isLoading<span class="token punctuation">:</span> <span class="token keyword">false</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        isLoading<span class="token punctuation">:</span> <span class="token keyword">true</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
      axios<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
          data<span class="token punctuation">:</span> result<span class="token punctuation">.</span>data<span class="token punctuation">,</span>
          isLoading<span class="token punctuation">:</span> <span class="token keyword">false</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span> data<span class="token punctuation">,</span> isLoading <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state
      <span class="token keyword">return</span> <span class="token punctuation">(</span>
        <span class="token operator">&lt;</span><span class="token operator">></span>
          <span class="token punctuation">{</span> <span class="token punctuation">(</span>isLoading <span class="token operator">||</span> <span class="token operator">!</span>data<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">&lt;</span>p<span class="token operator">></span>data is loading<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span> <span class="token punctuation">:</span>
            <span class="token operator">&lt;</span>WrappedComponent <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props as P<span class="token punctuation">}</span> data<span class="token operator">=</span><span class="token punctuation">{</span>data<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
          <span class="token punctuation">}</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">></span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> withLoader
</code></pre>
<p>使用实例：</p>
<pre class=" language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name">IShowResult</span><span class="token punctuation">{</span>
    message<span class="token punctuation">:</span><span class="token keyword">string</span><span class="token punctuation">,</span>
    status<span class="token punctuation">:</span><span class="token keyword">string</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//定义一个组件</span>
<span class="token keyword">const</span> DogShow<span class="token punctuation">:</span>React<span class="token punctuation">.</span>FC<span class="token operator">&lt;</span><span class="token punctuation">{</span>data<span class="token punctuation">:</span>IShowResult<span class="token punctuation">}</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>data<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
        <span class="token operator">&lt;</span><span class="token operator">></span>
            <span class="token operator">&lt;</span>h2<span class="token operator">></span>show<span class="token punctuation">:</span><span class="token punctuation">{</span>data<span class="token punctuation">.</span>status<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>
            <span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token punctuation">{</span>data<span class="token punctuation">.</span>message<span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">></span>
        <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">></span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> App<span class="token punctuation">:</span>React<span class="token punctuation">.</span>FC<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//高阶组件，将一个组件用参数形式传入，然后经过包裹后返回一个新的组件，达到公用包裹组件的功能</span>
    <span class="token keyword">const</span> WrappedDogShow <span class="token operator">=</span> <span class="token function">withLoader</span><span class="token punctuation">(</span>DogShow<span class="token punctuation">,</span><span class="token string">'https://dog.ceo/api/breeds/image/random'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
        <span class="token operator">&lt;</span>WrappedDogShow<span class="token operator">/</span><span class="token operator">></span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="React-hooks"><a href="#React-hooks" class="headerlink" title="React hooks"></a>React hooks</h4><p>其实，React hooks 的问题也有很多，比如：</p>
<ul>
<li>Hook 是一个链表的结构，在循环，条件或嵌套函数中调用 Hook，会引发一些问题。</li>
<li>useEffect 的依赖容易造成心智负担，所有人阅读这段代码，都需要完整的阅读完这些依赖触发的地方</li>
<li>由于闭包的原因，useEffect 等内部捕获的，都是过时的变量。</li>
</ul>
<p>对 React Hooks 而言，调用必须放在最前面，而且不能被包含在条件语句里，这是因为 React Hooks 采用下标方式寻找状态，一旦位置不对或者 Hooks 放在了条件中，就无法正确找到对应位置的值。<br>所有 Hooks 都在渲染闭包中执行，每次重渲染都有一定性能压力，而且频繁的渲染会带来许多闭包，虽然可以依赖 GC 机制回收，但会给 GC 带来不小的压力。<br>需要用useCallback、useMemo 来做性能优化，两者的区别在于一个存储函数的本身(useCallback) 一个存储函数返回的值（useMemo）</p>
<p>useLayoutEffect<br>跟 useEffect 使用差不多，通过同步执行状态更新可解决一些特性场景下的页面闪烁问题<br>useLayoutEffect 会阻塞渲染，请谨慎使用</p>
<ul>
<li>DOM更新同步钩子。用法与useEffect类似，只是区别于执行时间点的不同。</li>
<li>useEffect属于异步执行，并不会等待 DOM 真正渲染后执行，而useLayoutEffect则会真正渲染后才触发；</li>
<li>可以获取更新后的 state；</li>
</ul>
<p>useReducer</p>
<p>接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法</p>
<ul>
<li>reducer 本质是一个纯函数，每次只返回一个值，那个值可以是数字，字符串，对象，数组或者对象，但是它总是一个值</li>
<li>React 会确保 dispatch 函数的标识是稳定的，并且不会在组件重新渲染时改变</li>
<li>useReducer 还能给那些会触发深更新的组件做性能优化，因为可以向子组件传递 dispatch 而不是回调函数</li>
<li>reducer 更适合去处理比较复杂的 state，来维护组件的状态</li>
</ul>
<p>类似于 Redux 思想的实现，但其并不足以替代 Redux，可以理解成一个组件内部的 redux:</p>
<ul>
<li>并不是持久化存储，会随着组件被销毁而销毁；</li>
<li>属于组件内部，各个组件是相互隔离的，单纯用它并无法共享数据；</li>
<li>配合useContext的全局性，可以完成一个轻量级的 Redux；(easy-peasy)</li>
</ul>
<p>useContext</p>
<ul>
<li>接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值</li>
<li>useContext 的参数必须是 context 对象本身</li>
<li>当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定</li>
<li>调用了 useContext 的组件总会在 context 值变化时重新渲染</li>
</ul>
<h4 id="React-diff"><a href="#React-diff" class="headerlink" title="React diff"></a>React diff</h4><p>要求：1、跨层级节点移动操作较少；2、相同类的两个组件会生成相似的树形结构；3、同一层的一组节点，通过唯一的key进行区分<br>树差异（Tree Diff）、组件差异（Component Diff）以及元素差异（Element Diff）<br>树差异 只比较同一层级，如果同一层级不同，直接先销毁再创建<br>组件差异 同一类型的组件，比较子树， 如果不是，直接替换<br>元素差异，直接通过唯一的key来辨别</p>
<h4 id="umi-amp-dva"><a href="#umi-amp-dva" class="headerlink" title="umi &amp; dva"></a>umi &amp; dva</h4><p>umi 企业级的前端开发框架，Umi 以路由为基础的，同时支持配置式路由和约定式路由，保证路由的功能完备，并以此进行功能扩展。然后配以生命周期完善的插件体系，覆盖从源码到构建产物的每个生命周期，支持各种功能扩展和业务需求。</p>
<p>特性：插件化、MFSU<br><img src="/images/umi.png"></p>
<p>dva 是基于redux的前端数据流方案<br>特性：</p>
<ul>
<li>易学易用</li>
</ul>
<p>特点：<br>modal、namespace、state、effect、reducer、subscription</p>
<ul>
<li>effect:以 key/value 格式定义 effect。用于处理异步操作和业务逻辑，不直接修改 state</li>
<li>reducer:以 key/value 格式定义 reducer。用于处理同步操作，唯一可以修改 state 的地方，由 action 触发</li>
<li>subscription:以 key/value 格式定义 subscription。subscription 是订阅，用于订阅一个数据源，然后根据需要 dispatch 相应的 action。在 app.start() 时被执行，数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等。</li>
</ul>
<h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><h4 id="vue-的双向绑定"><a href="#vue-的双向绑定" class="headerlink" title="vue 的双向绑定"></a>vue 的双向绑定</h4><p>vue2.x 中通过发布者-订阅者设计模式的方式实现，通过 get 和 set 方法，通过 Object.defineProperty() 实现数据劫持<br>有三个参数，对象，对象的属性，以及描述符对象<br>描述符对象： 数据属性：</p>
<ul>
<li>writable 可读写</li>
<li>enumerable 可迭代，表示是否可用 for in 循环</li>
<li>configurable 是否可删除</li>
<li>value 值</li>
</ul>
<p>访问器属性</p>
<ul>
<li>get</li>
<li>set</li>
</ul>
<p>同时需要遍历所有属性进行双向绑定</p>
<p>缺点：对于新增的属性无法监听，需要通过 vm.$set 方法新增属性；</p>
<p>vue3 中通过 proxy 的 api 来实现监听<br>proxy 有两个参数<br>target:要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）<br>handler:一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。</p>
<h4 id="vue-的生命周期"><a href="#vue-的生命周期" class="headerlink" title="vue 的生命周期"></a>vue 的生命周期</h4><p>vue2.x</p>
<p>beforeCreate<br>created<br>beforeMount<br>mounted<br>beforeUpdate<br>updated<br>beforeDestory<br>destoryed</p>
<p>加载渲染过程<br>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount-&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p>
<p>子组件更新过程<br>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p>
<p>父组件更新过程<br>父 beforeUpdate -&gt; 父 updated</p>
<p>销毁过程<br>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p>
<p>vue3<br>setup<br>onBeforeMount<br>onMounted<br>onBeforeUpdated<br>onUpdated<br>onBeforeUnmount<br>onUnmounted</p>
<h4 id="vuex-和-pinia"><a href="#vuex-和-pinia" class="headerlink" title="vuex 和 pinia"></a>vuex 和 pinia</h4><p>vuex 分为 State、Getter、Mutation、Action、Module<br>dispatch 方法操作-&gt;action-&gt;commit 方法-&gt;mutation<br>State 是状态，mapState 通常用来解决一个组件需要获取多个状态时的辅助函数；<br>Getter state 对象读取方法，用来计算 state 然后生成新的数据，相当于对于部分 state 重新封装了一层<br>Mutation 对 state 进行改变的唯一方法，其中 Mutation 必须是同步的<br>Action 是通过触发 Mutation 从而改变 state，可以包含任意异步操作，其中通过 store.dispatch 进行触发<br>Module 可以说是对 store 进行分割，每一个 module 拥有自己的 state，mutation，action，getter 等。命名空间使得模块的封装和复用更加方便<br>插件使用使得 vuex 扩展性更好，表单处理的双向绑定需要绑定事件或者通过计算属性的 setter 进行双向绑定</p>
<p>缺点：</p>
<ol>
<li>TS 支持不良好</li>
<li>不能同时支持 Composition API 和 Option API（vuex5 之后支持）</li>
</ol>
<p>pinia</p>
<ol>
<li>去掉了容易混淆的 mutation 和 action 概念，只保留了 action，action 中的函数可以是同步的也可以是异步的，并且可以直接调用 action 中的方法，不再需要 commit、dispatch 等方法，语法更简洁；</li>
<li>无需创建自定义复杂包装器来支持 TypeScript，所有内容都是类型化的，并且 API 的设计方式尽可能地利用了 TS 的类型推断；</li>
<li>不再有 modules 的嵌套结构。 Pinia 通过设计提供平面结构，同时仍然支持 Store 之间的交叉组合方式；</li>
<li>更加轻便 Pinia 大小约 1kb</li>
</ol>
<h4 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h4><p>在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。 nextTick 主要使用了宏任务和微任务。 根据执行环境分别尝试采用 Promise、MutationObserver、setImmediate，如果以上都不行则采用 setTimeout 定义了一个异步方法，多次调用 nextTick 会将方法存入队列中，通过这个异步方法清空当前队列。</p>
<ol>
<li>nextTick 是 Vue 提供的一个全局 API,是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用$nextTick，则可以在回调中获取更新后的 DOM；</li>
<li>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启 1 个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中-次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。nextTick 方法会在队列中加入一个回调函数，确保该函数在前面的 dom 操作完成后才调用；</li>
<li>比如，我在干什么的时候就会使用 nextTick，传一个回调函数进去，在里面执行 dom 操作即可；</li>
<li>我也有简单了解 nextTick 实现，它会在 callbacks 里面加入我们传入的函数，然后用 timerFunc 异步方式调用它们，首选的异步方式会是 Promise。这让我明白了为什么可以在 nextTick 中看到 dom 操作结果。</li>
</ol>
<h4 id="v-model-语法糖和-vue3-的-v-model-变化"><a href="#v-model-语法糖和-vue3-的-v-model-变化" class="headerlink" title="v-model 语法糖和 vue3 的 v-model 变化"></a>v-model 语法糖和 vue3 的 v-model 变化</h4><p>value+input 是 v-band 和 v-on 的简洁写法<br>在 vue2 中 v-model 只能绑定在组件的 value 属性上<br>在 2.x 版本中 可以在组件内部定义一个 model 项，其中 prop 用来设置 v-model 中默认的 value 的别名， event 用来设置 v-model 中默认的 input 事件的别名<br>一个组件上只能一个 v-model</p>
<p>在 vue3 中 v-bind 的.sync 修饰符和组件的 model 选项被删除了<br>支持同一组件同时设置多个 v-model<br>也可以自定义修饰符<br>v-model 绑定的不再是 value，而是 modelValue，接收的方法也不再是 input，而是 update:modelValue</p>
<h4 id="vue-的通信方式"><a href="#vue-的通信方式" class="headerlink" title="vue 的通信方式"></a>vue 的通信方式</h4><ul>
<li>父子：props 和$emit</li>
<li>爷孙：$attrs和$listeners</li>
<li>eventbus</li>
<li>provide 和 inject</li>
<li>$parent 和$children</li>
<li>vuex</li>
<li>自定义 store</li>
</ul>
<h4 id="Object-defineProperty-处理-Array-的-push"><a href="#Object-defineProperty-处理-Array-的-push" class="headerlink" title="Object.defineProperty 处理 Array 的 push"></a>Object.defineProperty 处理 Array 的 push</h4><p>需要重新处理 push 方法</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> originProto <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
<span class="token keyword">const</span> arrayProto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>originProto<span class="token punctuation">)</span><span class="token punctuation">;</span>
arrayProto<span class="token punctuation">[</span><span class="token string">"push"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  originProto<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"jjjkjkjk"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
data<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> arrayProto<span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token string">"push"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"kkkkjj"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h4 id="proxy-的写法"><a href="#proxy-的写法" class="headerlink" title="proxy 的写法"></a>proxy 的写法</h4><pre class=" language-js"><code class="language-js">data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// Reflect.set(target.key,value,receiver)</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h4 id="浏览器回退、切换会触发-vue-的哪些生命周期"><a href="#浏览器回退、切换会触发-vue-的哪些生命周期" class="headerlink" title="浏览器回退、切换会触发 vue 的哪些生命周期"></a>浏览器回退、切换会触发 vue 的哪些生命周期</h4><p>页面刷新时, vue 执行的生命周期钩子<br>依次执行当前页面 vue 组件的 beforeCreate, created, beforeMount, mounted, beforUpdate, updated</p>
<p>页面后退时, vue 执行的生命周期钩子<br>假设从 b 页面后退到 a 页面<br>依次执行 a 页面 vue 组件的 beforeCreate, created, beforeMount, 然后是 b 页面组件的 beforeDestroy, destroyed, 最后是执行 a 页面 vue 组件的 mounted, beforUpdate, updated</p>
<p>页面前进时, vue 执行的生命周期钩子<br>假设从 a 页面到 b 页面<br>依次执行 b 页面 vue 组件的 beforeCreate, created, beforeMount, 然后是 a 页面组件的 beforeDestroy, destroyed, 最后是执行 b 页面 vue 组件的 mounted, beforUpdate, updated</p>
<h4 id="vue-中的-diff"><a href="#vue-中的-diff" class="headerlink" title="vue 中的 diff"></a>vue 中的 diff</h4><p>在 vue1.0 中，通过 watch 来实现数据和视图的响应式更新，通过观察者模式<br>在 vue2.x 中，因为还是无法解决响应式数据过多而引起的卡顿的问题，vue2.x 引入了虚拟 DOM，对于 Vue 2 来说，组件之间的变化，可以通过响应式来通知更新。组件内部的数据变化，则通过虚拟 DOM 去更新页面。这样就把响应式的监听器，控制在了组件级别，而虚拟 DOM 的量级，也控制在了组件的大小。</p>
<p>如果没有绑定 key，对于 DOM 的顺序发生变化，比如直接插入，会导致后面的数据不变的组件重新渲染</p>
<h4 id="vue-的-keep-alive-的作用是什么？怎么实现的？如何刷新的"><a href="#vue-的-keep-alive-的作用是什么？怎么实现的？如何刷新的" class="headerlink" title="vue 的 keep-alive 的作用是什么？怎么实现的？如何刷新的?"></a>vue 的 keep-alive 的作用是什么？怎么实现的？如何刷新的?</h4><p>保持组件不被销毁，组件挂载的数据还存在，所以状态就可以保留。<br>在首次加载被包裹组建时，由 keep-alive.js 中的 render 函数可知，vnode.componentInstance 的值是 undfined，keepAlive 的值是 true，因为 keep-alive 组件作为父组件，它的 render 函数会先于被包裹组件执行；那么只执行到 i(vnode,false)，后面的逻辑不执行；<br>再次访问被包裹组件时，vnode.componentInstance 的值就是已经缓存的组件实例，那么会执行 insert(parentElm, vnode.elm, refElm)逻辑，这样就直接把上一次的 DOM 插入到父元素中。</p>
<p>在 patch 的阶段，最后会执行 invokeInsertHook 函数，而这个函数就是去调用组件实例（VNode）自身的 insert 钩子：<br>在 insert 这个钩子里面，调用了 activateChildComponent 函数递归地去执行所有子组件的 activated 钩子函数：<br>相反地，deactivated 钩子函数也是一样的原理，在组件实例（VNode）的 destroy 钩子函数中调用 deactivateChildComponent 函数。</p>
<h4 id="render-和-template-的区别"><a href="#render-和-template-的区别" class="headerlink" title="render 和 template 的区别"></a>render 和 template 的区别</h4><p>template—-html 的方式做渲染<br>render—-js 的方式做渲染<br>render（提供）是一种编译方式<br>render 里有一个函数 h，这个 h 的作用是将单文件组件进行虚拟 DOM 的创建，然后再通过 render 进行解析。<br>h 就是 createElement()方法：createElement(标签名称,属性配置,children)<br>template 也是一种编译方式，但是 template 最终还是要通过 render 的方式再次进行编译。</p>
<p>render 渲染方式可以让我们将 js 发挥到极致，因为 render 的方式其实是通过 createElement()进行虚拟 DOM 的创建。逻辑性比较强，适合复杂的组件封装。<br>template 是类似于 html 一样的模板来进行组件的封装。<br>render 的性能比 template 的性能好很多<br>render 函数优先级大于 template</p>
<h4 id="vue3-生命周期实现原理"><a href="#vue3-生命周期实现原理" class="headerlink" title="vue3 生命周期实现原理"></a>vue3 生命周期实现原理</h4><p>就是把各个生命周期的函数挂载或者叫注册到组件的实例上，然后等到组件运行到某个时刻，再去组件实例上把相应的生命周期的函数取出来执行。<br>各个生命周期的 Hooks 函数是通过 createHook 这个函数创建的。createHook 是一个闭包函数，通过闭包缓存当前是属于哪个生命周期的 Hooks,target 表示该生命周期 Hooks 函数被绑定到哪个组件实例上，默认是当前工作的组件实例。createHook 底层又调用了一个 injectHook 的函数，那么下面我们继续来看看这个 injectHook 函数。</p>
<p>Vue3 组件实例化之后，通过 effect 包装一个更新的副作用函数来和响应式数据进行依赖收集。在这个副作用函数里面有两个分支，第一个是组件挂载之前执行的，也就是生命周期函数 beforeMount 和 mount 调用的地方，第二个分支是组件挂载之后更新的时候执行的，在这里就是生命周期函数 beforeUpdate 和 updated 调用的地方。具体就是在挂载之前，还没生成虚拟 DOM 之前就执行 beforeMount 函数，之后则去生成虚拟 DOM 经过 patch 之后，组件已经被挂载到页面上了，也就是页面上显示视图了，这个时候就去执行 mount 函数;在更新的时候，还没获取更新之后的虚拟 DOM 之前执行 beforeUpdate，然后去获取更新之后的虚拟 DOM，然后再去 patch，更新视图，之后就执行 updated。需要注意的是 beforeMount 和 beforeUpdate 是同步执行的，都是通过 invokeArrayFns 来调用的</p>
<p>Vue 的 Hooks 设计是从 React 的 Hooks 那里借鉴过来的，React 的 Hooks 的本质就是把状态变量、副作用函数存到函数组件的 fiber 对象上，等到将来状态变量发生改变的时候，相关的函数组件 fiber 就重新进行更新。Vue3 这边的实现原理也类似，通过上面的生命周期的 Hooks 实现原理，我们可以知道 Vue3 的生命周期的 Hooks 是绑定到具体的组件实例上，而状态变量，则因为 Vue 的变量是响应式的，状态变量会通过 effect 和具体的组件更新函数进行依赖收集，然后进行绑定，将来状态变量发生改变的时候，相应的组件更新函数会重新进入调度器的任务队列进行调度执行。</p>
<p>所以 Hooks 的本质就是让那些状态变量或生命周期函数和组件绑定起来，组件运行到相应时刻执行相应绑定的生命周期函数，那些绑定的变量发生改变的时候，相应的组件也重新进行更新。</p>
<h4 id="组件设计原则"><a href="#组件设计原则" class="headerlink" title="组件设计原则"></a>组件设计原则</h4><p>单一职责： 一个组件负责完成一个职责/功能<br>保持简单：不要过度优化，从而牺牲了代码可读性和可维护性<br>不要重复：做好代码的复用性<br>控制反转：子组件的创建与管理交给外层容器组件来控制<br>关注点分离：如果一个问题能分解为独立且较小的问题，就是相对较易解决的。实现关注点分离的方式有两种：一种是标准化，另一种就是抽象与包装<br>松耦合：组件的核心思想是它们是可复用的,为此要求它们必须具有功能性和完整性。“耦合”是指实体彼此依赖的术语。松散耦合的实体应该能够独立运行，而不依赖于其他模块。就前端组件而言，耦合的主要部分是组件的功能依赖于其父级及其传递的 props 的多少，以及内部使用的子组件（当然还有引用的部分，如第三方模块或用户脚本）。在设计组件时，你应该考虑到更加通用的使用场景，而不仅仅只是为了满足最开始某个特定场景的需求。虽然一般来说组件最初都是出于特定目的进行设计，但没关系，如果在设计它们站在更高的角度去看待，那么很多组件将具有更好的适用性。</p>
<h4 id="vue-router3-和-vue-router4-的区别"><a href="#vue-router3-和-vue-router4-的区别" class="headerlink" title="vue router3 和 vue router4 的区别"></a>vue router3 和 vue router4 的区别</h4><ol>
<li>创建方式：在Vue Router 4中，使用createRouter来创建一个路由实例，而在Vue Router 3中，则是通过创建一个VueRouter实例来进行。</li>
</ol>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//  4.x 写法</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> createRouter <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"vue-router"</span>
<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token function">createRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// options</span>
    <span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// 3.x 写法</span>
<span class="token keyword">import</span> VueRouter <span class="token keyword">from</span> <span class="token string">"vue-router"</span>
<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// options</span>
    <span class="token operator">...</span><span class="token operator">...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<ol start="2">
<li>路由模式的定义方式：在Vue Router 4中，使用createWebHistory或createWebHashHistory来定义路由模式，而在Vue Router 3中，则是通过在路由实例中设置mode属性来定义。</li>
</ol>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//  4.x 写法</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>
  createRouter<span class="token punctuation">,</span>
  createWebHistory<span class="token punctuation">,</span>
  createWebHashHistory<span class="token punctuation">,</span>
<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"vue-router"</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token function">createRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  history<span class="token punctuation">:</span> <span class="token function">createWebHistory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">createWebHashHistory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 3.x 写法</span>
<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  mode<span class="token punctuation">:</span> <span class="token string">"hash"</span> <span class="token operator">/</span> <span class="token string">"history"</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<ol start="3">
<li>挂载方式：在Vue 3中使用Composition API，所以Vue Router也要以插件的形式进行挂载。在Vue Router 4中，使用useRouter和useRoute两个API来在组件中获取到路由实例和路由对象。而在Vue Router 3中，则是直接在组件实例中使用this.$router来获取路由实例，并使用this.$route来获取路由对象。</li>
</ol>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 4.x</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span> createApp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> router <span class="token keyword">from</span> <span class="token string">"./router.js"</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">"./App.vue"</span><span class="token punctuation">;</span>
<span class="token function">createApp</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>router<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">"#app"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 3.x</span>

<span class="token keyword">import</span> router <span class="token keyword">from</span> <span class="token string">"./router.js"</span><span class="token punctuation">;</span>
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  router<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<ol start="4">
<li>组件中的使用方式：因为在Vue 3的setup函数中无法使用this，所以在Vue Router 4中提供了useRouter和useRoute两个API来在组件中获取到路由实例和路由对象。而在Vue Router 3中，则是在组件的实例方法中使用this.$router来获取路由实例，并使用this.$route来获取路由对象。</li>
</ol>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 4.x</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> useRouter<span class="token punctuation">,</span>useRoute <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"vue-router"</span>
<span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token function">useRouter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> route <span class="token operator">=</span> <span class="token function">useRoute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> linkToHome <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            path<span class="token punctuation">:</span><span class="token string">'/'</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span><span class="token punctuation">{</span>
        linkToHome
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// 3.x</span>

<span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    methods<span class="token punctuation">:</span><span class="token punctuation">{</span>
        <span class="token function">linkToHome</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
                path<span class="token punctuation">:</span><span class="token string">'/'</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<ol start="5">
<li>导航守卫：由于Vue 3的Composition API变革，beforeRouteUpdate 和 beforeRouteLeave 被替换为 onBeforeRouteUpdate 和 onBeforeRouteLeave。</li>
</ol>
<h4 id="app-use-操作了什么？"><a href="#app-use-操作了什么？" class="headerlink" title="app.use 操作了什么？"></a>app.use 操作了什么？</h4><p>在Vue中，app.use是Vue的全局API之一，用于在Vue应用程序中引入和注册插件。</p>
<p>app.use操作会调用Vue构造器的use方法，该方法接受一个插件对象或模块作为参数。当调用app.use时，Vue会将插件对象或模块的原型链与Vue构造器的原型链进行合并，这样插件就可以访问Vue的核心API和功能。</p>
<p>具体来说，app.use操作会执行以下操作：</p>
<p>引入插件：如果参数是一个对象，它将作为插件对象被引入。插件对象的属性可以包含要注册的插件功能。<br>注册插件：如果参数是一个模块，它将被作为插件模块进行注册。这意味着它的属性和方法将被添加到Vue的全局API中，可以在整个应用程序中使用。<br>合并原型链：无论是引入插件对象还是注册插件模块，Vue都会将它们的原型链与Vue构造器的原型链进行合并。这样，插件就可以访问Vue的核心API和功能，例如this.$createElement、this.$set等。<br>通过app.use可以方便地将第三方库或自定义插件集成到Vue应用程序中，实现扩展和定制化功能，是Vue开发中常见的一种扩展方式。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">s1p21</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://s1p21.github.io/2025/09/19/mian-shi-quan/">https://s1p21.github.io/2025/09/19/mian-shi-quan/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">s1p21</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E9%9D%A2%E8%AF%95/">
                                    <span class="chip bg-color">面试</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2025/09/19/mian-shi-quan/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//medias/featureimages/6.jpg" class="responsive-img" alt="面试-全">
                        
                        <span class="card-title">面试-全</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2025-09-19
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            s1p21
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E9%9D%A2%E8%AF%95/">
                        <span class="chip bg-color">面试</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/05/17/cong-prompt-dao-lun-wen-da-zao-gao-xiao-ke-yan-xie-zuo-liu-cheng-de-shi-yong-zhi-nan/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//medias/featureimages/2.jpg" class="responsive-img" alt="从Prompt到论文：打造高效科研写作流程的实用指南">
                        
                        <span class="card-title">从Prompt到论文：打造高效科研写作流程的实用指南</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-05-17
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            s1p21
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Prompt/">
                        <span class="chip bg-color">Prompt</span>
                    </a>
                    
                    <a href="/tags/%E8%AE%BA%E6%96%87/">
                        <span class="chip bg-color">论文</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2025</span>
            
            <a href="/about" target="_blank">s1p21</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/s1p21" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:269438272@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>



    <a href="https://www.facebook.com/s1p21" class="tooltipped" target="_blank" data-tooltip="关注我的Facebook: https://www.facebook.com/s1p21" data-position="top" data-delay="50">
        <i class="fab fa-facebook-f"></i>
    </a>



    <a href="https://twitter.com/s1p21" class="tooltipped" target="_blank" data-tooltip="关注我的Twitter: https://twitter.com/s1p21" data-position="top" data-delay="50">
        <i class="fab fa-twitter"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=269438272" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 269438272" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/u/2689712123" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/2689712123" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://weixin.qq.com/" class="tooltipped" target="_blank" data-tooltip="微信搜索: s1p21wt" data-position="top" data-delay="50">
        <i class="fab fa-weixin"></i>
    </a>



    <a href="https://www.zhihu.com/people/whitbytao" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/whitbytao" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//libs/others/busuanzi.pure.mini.js"></script>
    

    

    
    <script>
        (function (i, s, o, g, r, a, m) {
            i["DaoVoiceObject"] = r;
            i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o), m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            a.charset = "utf-8";
            m.parentNode.insertBefore(a, m)
        })(window, document, "script", ('https:' == document.location.protocol ? 'https:' : 'http:') +
            "//widget.daovoice.io/widget/6984b559.js", "daovoice")
        daovoice('init', {
            app_id: "89660989"
        });
        daovoice('update');
    </script>
    

    <!--腾讯兔小巢-->
    
    

    

    
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="https://cdn.jsdelivr.net/gh/s1p21/s1p21.github.io//libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
