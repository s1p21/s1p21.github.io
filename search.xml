<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>webpack 优化实践</title>
      <link href="2023/01/18/webpack-you-hua-shi-jian/"/>
      <url>2023/01/18/webpack-you-hua-shi-jian/</url>
      
        <content type="html"><![CDATA[<p>一、优化策略： 缓存、多核、抽离或拆分</p><ul><li>缓存添加：</li></ul><ol><li>babel-loader缓存 通过设置cacheDirectory为true来开启缓存</li></ol><pre class=" language-js"><code class="language-js"><span class="token punctuation">{</span>    test<span class="token punctuation">:</span> <span class="token regex">/\.js$/</span><span class="token punctuation">,</span>    loader<span class="token punctuation">:</span> <span class="token string">'babel-loader'</span><span class="token punctuation">,</span>    options<span class="token punctuation">:</span> <span class="token punctuation">{</span>      cacheDirectory<span class="token punctuation">:</span> <span class="token boolean">true</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><ul><li>多核</li></ul><ol><li>引入happypack 插件</li></ol><pre class=" language-js"><code class="language-js"> cnpm i happypack</code></pre><p>2、对于大的模块引入thread-loader</p><pre class=" language-js"><code class="language-js">rules <span class="token punctuation">[</span>    <span class="token punctuation">{</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.vue$/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'thread-loader'</span><span class="token punctuation">,</span><span class="token string">'vue-loader'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span></code></pre><p>3、抽离和拆分</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//1、</span>    optimization<span class="token punctuation">.</span>runtimeChunk <span class="token operator">=</span> <span class="token string">'single'</span>  <span class="token comment" spellcheck="true">//抽离公共的运行时代码</span><span class="token comment" spellcheck="true">//2、</span>    optimization<span class="token punctuation">.</span>cacheGroups<span class="token punctuation">:</span> <span class="token punctuation">{</span>          vendors<span class="token punctuation">:</span> <span class="token punctuation">{</span>              test<span class="token punctuation">:</span> <span class="token regex">/[\\/]node_modules[\\/]/</span><span class="token punctuation">,</span>              priority<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>              chunks<span class="token punctuation">:</span><span class="token string">'async'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 按需加载</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//3、dll 将vue vue-router jquery等体积较大的包单独打包，之后webpack每次打包不会继续重新打包</span><span class="token comment" spellcheck="true">//新增webpack.dll.conf.js 文件内容如下</span>安装DllPlugin包和DllReferencePlugin包<span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//这地方写你想抽离的包，可以参考你的package.json文件下的dependencies</span>        vue<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'vue'</span><span class="token punctuation">,</span><span class="token string">'vue-router'</span><span class="token punctuation">]</span>     <span class="token punctuation">}</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//这地方写你打包后生成文件的路径</span>        path<span class="token punctuation">:</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">"../src/dll"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        filename<span class="token punctuation">:</span><span class="token string">'[name].dll.js'</span><span class="token punctuation">,</span>        library<span class="token punctuation">:</span><span class="token string">'[name]'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span><span class="token punctuation">[</span>        <span class="token comment" spellcheck="true">//这个插件是重点，用于打包上面entry里配置的包</span>        <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>DllPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            path<span class="token punctuation">:</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">"../src/dll"</span><span class="token punctuation">,</span><span class="token string">'[name]-manifest.json'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            name<span class="token punctuation">:</span><span class="token string">'[name]'</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>optimize<span class="token punctuation">.</span>UglifyJsPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>三、可进行的其他优化<br>1、对于callcenter的图片没有用到的删除掉<br>2、可将callcenter放置在静态资源服务器上，或者CDN引入的方式<br>3、jquery存在重复引入的问题<br>4、logo图片优化，当前为48kB logo.svg图片压缩，当前为22K<br>5、xls模版文档存放在前端，且大小为20-30K左右</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>原来打包时间为3min12s ，经过优化打包时间可到1min 57s左右<br>1、 主要对vue文件使用thread-loader，设置babel-loader缓存 通过设置cacheDirectory为true来开启缓存<br>2、 js使用happypack来多核打包 性能优化明显<br>3、 dllplugin和 cache-loader 操作对于打包时间优化不是很大</p><h4 id="构建过程中分析-原打包时间"><a href="#构建过程中分析-原打包时间" class="headerlink" title="构建过程中分析 原打包时间"></a>构建过程中分析 原打包时间</h4><p><img src="/../images/webpack/01.jpg" alt="b56ca3d344155c15b84a15023ecbd428.png"><br><img src="/../images/webpack/02.jpg" alt="173fb1cff608a8f4484c1eef41c5da9c.png"></p><h4 id="加入babel-loader-缓存和happypack-多核打包后"><a href="#加入babel-loader-缓存和happypack-多核打包后" class="headerlink" title="加入babel-loader 缓存和happypack 多核打包后"></a>加入babel-loader 缓存和happypack 多核打包后</h4><p><img src="/../images/webpack/03.jpg" alt="539b6b0472185750d927d640f36ecf31.png"><br><img src="/../images/webpack/04.jpg" alt="7c7ab7216e0d8a82c2f4f85ad7a20d08.png"></p><h4 id="加入cache-loader-打包"><a href="#加入cache-loader-打包" class="headerlink" title="加入cache-loader 打包"></a>加入cache-loader 打包</h4><p><img src="/../images/webpack/05.jpg" alt="b18a4eabd32cc8bb3a5119cf9f421221.png"><br>未加入cache-loader 查找缓存需要时间<br><img src="/../images/webpack/06.jpg" alt="4c89071c6e14a54a6029a1b5ece2b57e.png"></p><h4 id="加入thread-loader"><a href="#加入thread-loader" class="headerlink" title="加入thread-loader"></a>加入thread-loader</h4><p><img src="/../images/webpack/07.jpg" alt="3654186bb72cf1f7e4d9ea9b288a79bd.png"></p><p><img src="/../images/webpack/08.jpg" alt="ec58e6458b289f32c12c0552f0d41e0c.png"></p><h4 id="抽离与拆分之后"><a href="#抽离与拆分之后" class="headerlink" title="抽离与拆分之后"></a>抽离与拆分之后</h4><p><img src="/../images/webpack/09.jpg" alt="b82fe3bdb40ddd3efd0e4a566a25463f.png"><br>打包时间没有太多变化</p><h3 id="dllplugin-升级"><a href="#dllplugin-升级" class="headerlink" title="dllplugin 升级"></a>dllplugin 升级</h3><p><img src="/../images/webpack/10.jpg" alt="9bf2f42158755d1ecf56082bfa313983.png"></p><p>优化思路： 添加yarn add speed-measure-webpack-plugin 插件，测量出在你的构建过程中，每一个 Loader 和 Plugin 的执行时长</p>]]></content>
      
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJS与Promise的区别</title>
      <link href="2023/01/12/rxjs-yu-promise-de-qu-bie/"/>
      <url>2023/01/12/rxjs-yu-promise-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>RxJS 是 ReactiveX 项目的 JavaScript 实现。ReactiveX 项目旨在为不同编程语言的异步编程提供 API。<br>ReactiveX 的基本概念是 Gang of Four 的 Observer pattern (ReactiveX 甚至通过完成和错误通知扩展了 observer 模式)。因此，所有 ReactiveX 实现的核心抽象是 observable<br>那么，现在我们知道什么是 RxJS，但是什么是 observable 呢？让我们尝试从两个维度来理解它，并将其与其他已知抽象进行比较。维度是同步性/异步性和单个值/多个值。</p><h3 id="Rxjs-与Promise的区别"><a href="#Rxjs-与Promise的区别" class="headerlink" title="Rxjs 与Promise的区别"></a>Rxjs 与Promise的区别</h3><table><thead><tr><th></th><th>单个值</th><th>多个值</th></tr></thead><tbody><tr><td>同步</td><td>get（常规的数据访问操作）</td><td>Interable</td></tr><tr><td>异步</td><td>Promise</td><td>Observable</td></tr></tbody></table><p>对于一个 observable，我们可以说以下是正确的:</p><ul><li>发送多个值</li><li>异步发出其值（“推送”）</li></ul><p>让我们将前面介绍的 Promise 进行对比：</p><ul><li>​发送单个值</li><li>异步发出其值（“推送”）</li></ul><p>最后，让我们看一看 Iterable，这是一种存在于许多编程语言中的抽象，可用于迭代集合数据结构(如数组)的所有元素。对于迭代，要满足以下条件成立：</p><ul><li>发送多个值</li><li>同步发出其值(“拉取”)</li></ul><p>Observable 将 Iterable 带到异步世界。像 Iterable 一样，Observable 会计算并发射流值。但是，与 Iterable 不同，对于 Observable，调用代码不会同步提取每个值，但 Observable 将异步地将每个值尽快推入调用代码。为此，调用代码为 Observable 提供了一个处理函数，然后在 RxJS 中调用该函数，然后 Observable 针对其计算的每个值调用此函数。<br>Observable 发出的值可以是任何东西：数组的元素，HTTP 请求的结果（如果 Observable 发出的只是一个值，不必总是多个值就可以），用户输入事件（例如鼠标单击等）。这使 Observable 非常灵活。此外，由于 Observable 也只能发出单个值，因此 Observable 可以做 Promise 可以做的所有事情，但反之则不成立。</p><h4 id="单个值与多个值"><a href="#单个值与多个值" class="headerlink" title="单个值与多个值"></a>单个值与多个值</h4><p>promises 只能发出单个值。之后，它处于完成状态，只能用于查询该值，而不能再用于计算和发出新值。<br>observables 可以发出任意数量的值。</p><p>Promises:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>       <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// logs:// 1</span></code></pre><p>只执行 executor 函数中解析的第一个 resolve 调用，并使用值 1 解析 promise。之后，promise 转移到完成状态，结果值不再变化。<br>Observables:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> Observable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs'</span><span class="token punctuation">;</span><span class="token keyword">const</span> observable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observable</span><span class="token punctuation">(</span>observer <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  observer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  observer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  observer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>observable<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>result <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// logs:</span><span class="token comment" spellcheck="true">// 1</span><span class="token comment" spellcheck="true">// 2</span><span class="token comment" spellcheck="true">// 3</span></code></pre><h4 id="预解析与惰性的"><a href="#预解析与惰性的" class="headerlink" title="预解析与惰性的"></a>预解析与惰性的</h4><p>promise 是预解析：一旦创建了 promise，就会调用执行程序函数 Executor。</p><p>Observable 是惰性的：仅当客户端订阅 Observable 时才调用 subscriber 函数。</p><p>Promises:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'- Executing'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'- Subscribing'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'- Handling result'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// logs:</span><span class="token comment" spellcheck="true">// - Executing</span><span class="token comment" spellcheck="true">// - Subscribing</span><span class="token comment" spellcheck="true">// - Handling result</span></code></pre><p>可以看到，在订阅 promise 之前，executor 函数已经执行了。<br>如果根本没有订阅承诺，甚至会执行 executor 函数。如果注释掉最后两行，就可以看到这一点:仍然输出- Executing。</p><p>Observables:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> Observable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs'</span><span class="token punctuation">;</span><span class="token keyword">const</span> observable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observable</span><span class="token punctuation">(</span>observer <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'- Executing'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  observer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'- Subscribing'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>observable<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'- Handling result'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// logs:</span><span class="token comment" spellcheck="true">// - Subscribing</span><span class="token comment" spellcheck="true">// - Executing</span><span class="token comment" spellcheck="true">// - Handling result</span></code></pre><p>正如我们所看到的，subscriber 函数只在创建了对 Observable 的订阅之后执行。<br>如果将最后两行注释掉，则根本没有输出，因为 subscriber 函数将永远不会执行。<br>由于 Observable 不是在定义时执行的，而是在其他代码使用它们时才执行，所以它们也称为声明式(声明一个 Observable，但仅在使用它时才执行)。</p><h4 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h4><p>一旦使用 then 订阅了一个 promise，无论如何，传递给 then 的处理函数都将被调用。一旦 promise 执行开始，就不能告诉 promise 取消调用结果处理函数。<br>在使用 subscribe 订阅一个 Observable 之后，可以通过调用 subscribe 返回的订阅对象的 unsubscribe 方法，随时取消订阅。</p><p>Promises:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Async task done'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 不能再阻止handler被执行了。</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Handler'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// logs:</span><span class="token comment" spellcheck="true">// Async task done</span><span class="token comment" spellcheck="true">// Handler</span></code></pre><p>一旦我们调用了 then，就无法阻止调用传递给 then 的处理函数(即使我们有 2 秒的时间)。因此，2 秒后，当 promise 被解析时，处理程序就会执行。<br>Observables:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> Observable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs'</span><span class="token punctuation">;</span><span class="token keyword">const</span> observable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observable</span><span class="token punctuation">(</span>observer <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Async task done'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    observer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> subscription <span class="token operator">=</span> observable<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Handler'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>subscription<span class="token punctuation">.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// logs:</span><span class="token comment" spellcheck="true">// Async task done</span></code></pre><p>我们订阅了 observable，向它注册了一个处理函数，但是紧接着我们又从 observable 中取消订阅。其结果是，2 秒后，当 observable 将发出它的值时，我们的处理函数不会被调用。<br>注意：仍会打印完成的异步任务。取消订阅本身并不意味着 observable 正在执行的任何异步任务都将中止。取消订阅只是实现了对 subscriber 函数中对 observer.next（以及 observer.error 和 observer.complete）的调用不会触发对处理函数的调用。但是其他所有内容仍然可以正常运行，就好像不会取消订阅一样。</p><h4 id="多播和单播"><a href="#多播和单播" class="headerlink" title="多播和单播"></a>多播和单播</h4><p>promise 的 executor 函数只执行一次(在创建 promise 时)。这意味着，对给定 promise 对象的所有调用都直接进入 executor 函数的正在执行，最后得到结果是值的副本。因此，promise 执行多播，是因为相同的执行和结果值用于多个订阅者。<br>observable 的 subscriber 函数在每个调用上执行以订阅该 observable。因此，可观察对象执行单播，因为每个订阅服务器有单独的执行和结果值。<br>Promises:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Executing...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">resolve</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// logs:// Executing...// 0.1277775033205002// 0.1277775033205002</span></code></pre><p>可以看到，executor 函数只执行一次，并且两个订阅之间共享结果值。<br>Observables:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> Observable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs'</span><span class="token punctuation">;</span><span class="token keyword">const</span> observable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observable</span><span class="token punctuation">(</span>observer <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Executing...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  observer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>observable<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>result <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>observable<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>result <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// logs:// Executing...// 0.9823994838399746// Executing...// 0.8877532356021958</span></code></pre><p>可以看到，subscriber 函数是为每个 subscriber 单独执行的，每个 subscriber 都有自己的结果值。</p><h4 id="异步执行与同步执行"><a href="#异步执行与同步执行" class="headerlink" title="异步执行与同步执行"></a>异步执行与同步执行</h4><p>promise 的处理函数是异步执行的。也就是说，它们是在执行完主程序或当前功能中的所有代码之后执行的。<br>observable 的处理函数是同步执行的。也就是说，它们是在当前函数或主程序流中执行的。<br>Promises:</p><pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'- Creating promise'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'- Promise running'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'- Registering handler'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'- Handling result: '</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'- Exiting main'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// logs:// - Creating promise// - Promise running// - Registering handler// - Exiting main// - Handling result: 1</span></code></pre><p>首先创建 promise，然后直接执行 promise（因为 promise 的 executor 函数预先的，请参见上文）。承诺也立即得到解决。之后，我们通过调用 promise 的 then 方法来注册一个处理函数。至此，promise 已经被解析（即它处于已完成状态），然而，我们的处理程序函数此时尚未执行。而是首先执行主程序中所有剩余的代码，然后再调用我们的处理函数。<br>原因是 promise 完成(或拒绝)是作为异步事件处理的。这意味着，当一个承诺被解析(或拒绝)时，相应的处理函数将作为单独的项放在 JavaScript 事件队列中。这意味着处理程序仅在事件队列中的所有先前项目均已执行后才执行，并且在我们的示例中，有一个此类先前项目即主程序。<br>Observables:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> Observable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'- Creating observable'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> observable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observable</span><span class="token punctuation">(</span>observer <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'- Observable running'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  observer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'- Registering handler'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>observable<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>v <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'- Handling result: '</span> <span class="token operator">+</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'- Exiting main'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// logs:// - Creating observable// - Registering handler// - Observable running// - Handling result: 1// - Exiting main</span></code></pre><p>首先，创建了 Observable(但是它还没有被执行，因为 Observable 是惰性的，请参见上文)，然后我们通过调用 Observable 的 subscribe 方法注册一个处理函数。这时，observable 开始运行，并立即发出它的第一个也是唯一一个值。现在执行了处理函数，主程序退出。<br>与 promise 不同，处理函数是在主程序仍在运行时运行的。这是因为 observable 的处理函数是在当前执行的代码中同步调用的，而不是像 promise 的处理函数那样作为异步事件调用的。<br>我们从创建，使用，发送数据，销毁，执行方式多方面研究了 Promises 与 Observables 差异，你会发现 Observables 在各方面都优于 Promises，是不是 Promises 真的不行了，答案：不是。使用场景不一样，我们使用技术也不一样，Promises 有一个杀手锏 async/await。</p><h4 id="Promise-和-RxJS-Observable-互相操作"><a href="#Promise-和-RxJS-Observable-互相操作" class="headerlink" title="Promise 和 RxJS Observable 互相操作"></a>Promise 和 RxJS Observable 互相操作</h4><p>Rxjs 有很多操作符，例如（of、from、defer、forkJoin、concatMap、mergeMap、switchMap、exhaustMap、bufferToggle、audit、debounce、throttle、scheduled）<br>常用操作符可以直接把 Promise 转 Observable：<br>Observable 转 Promise 只有两个方法 toPromise 和 forEach。<br>前面我们说async/await是 Promise 法宝，但是async/await和 Observables 不能真正“协同工作”，我们可以借助 Observable 与 Promises 高度的互操作性来完成。<br>我们上面列举很多操作符都可以将 Promise 转 Observable。<br>例如，如果正在使用一个 switchMap，可以在其中返回一个 Promise，就像可以返回一个 Observable 一样。所有这些都是有效的：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> interval<span class="token punctuation">,</span> <span class="token keyword">of</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> mergeAll<span class="token punctuation">,</span> take<span class="token punctuation">,</span> map<span class="token punctuation">,</span> switchMap <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs/operators'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 每1秒发射100的10倍的可观测值</span><span class="token keyword">const</span> source <span class="token operator">=</span> <span class="token function">interval</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>  <span class="token function">take</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">map</span><span class="token punctuation">(</span>x <span class="token operator">=</span><span class="token operator">></span> x <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 返回一个承诺，等待“ms”毫秒并发出“done” */</span> <span class="token keyword">function</span> <span class="token function">promiseDelay</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'done'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ms<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用 switchMap</span>source  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">switchMap</span><span class="token punctuation">(</span>x <span class="token operator">=</span><span class="token operator">></span> <span class="token function">promiseDelay</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 回调</span>  <span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>x <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'switchMap1'</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>source  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">switchMap</span><span class="token punctuation">(</span>promiseDelay<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 再简洁一点</span>  <span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>x <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'switchMap2'</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 或者是你想做的奇怪的事情</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token function">promiseDelay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">promiseDelay</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">mergeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>x <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'of'</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果可以访问创建承诺的函数，那么可以使用 defer() 将其封装起来，并创建一个可在错误时重试的 Observable。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> defer <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> retry <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs/operators'</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">getErringPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'getErringPromise called'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'sad'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">defer</span><span class="token punctuation">(</span>getErringPromise<span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">retry</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>x <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span>log<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// logs// getErringPromise called// getErringPromise called// getErringPromise called// Error: sad</span></code></pre><p>事实证明，Defer 是一个非常强大的操作符。你可以将其基本上直接与 async/await 函数一起使用，它将使 Observable 发出返回的值并完成。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> defer <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs'</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">promiseDelay</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'done'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ms<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">defer</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">promiseDelay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">await</span> <span class="token function">promiseDelay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">await</span> <span class="token function">promiseDelay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>x <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// logs:// 7</span></code></pre><p>订阅 Observable 的方法不止一种，有一个 subscribe，这是经典的订阅 Observable 的方式，它返回一个 Subscription 对象，该对象可用于取消订阅，还有 forEach，这是一种不可撤销的订阅 Observable 的方式，该方式需要一个函数每个 next 值，并返回一个 Promise，其中包含 Observable 的 complete 和 error。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> fromEvent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> take <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs/operators'</span><span class="token punctuation">;</span><span class="token keyword">const</span> click <span class="token operator">=</span> <span class="token function">fromEvent</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>body<span class="token punctuation">,</span> <span class="token string">'click'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">promiseDelay</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'done'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ms<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 等待5次点击 * 点击完成等待promiseDelay执行 */</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">await</span> click<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>i <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`click </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">await</span> <span class="token function">promiseDelay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// logs:// click [object MouseEvent]// click [object MouseEvent]// click [object MouseEvent]// click [object MouseEvent]// click [object MouseEvent]// click [object MouseEvent]// done</span></code></pre><p>toPromise 函数跟 forEach 一样，是 Observable 上的方法，订阅一个 Observable 并将其封装到一个 Promise 中的方法。Promise 将在 Observable 完成后解析为 Observable 的最后一个被释放的值。如果 Observable 永远不会完成，那么 Promise 永远不会解析。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> interval <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> take <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs/operators'</span><span class="token punctuation">;</span><span class="token keyword">const</span> source <span class="token operator">=</span> <span class="token function">interval</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0, 1, 2</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">await</span> source<span class="token punctuation">.</span><span class="token function">toPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// logs:// 2</span></code></pre><p>注意：使用 toPromise() 是一种反模式，除非你正在处理一个期望 Promise 的 API，比如async/await。Rxjs v7 版本弃用 toPromise()。<br>forEach 和 toPromise 虽然都是返回 Promise 表现却不一致。<br>存在即合理，技术没有好坏，我们需要扬长避短，组合使用，发挥技术的最大优势，写出我们最健壮的程序。</p>]]></content>
      
      
      
        <tags>
            
            <tag> RxJS </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见机器学习算法</title>
      <link href="2023/01/12/chang-jian-ji-qi-xue-xi-suan-fa/"/>
      <url>2023/01/12/chang-jian-ji-qi-xue-xi-suan-fa/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h3><p>机器学习是一门多领域交叉学科，廊括众多：涉及到概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。<br>它是人工智能的核心，是使计算机具有智能的根本途径。如果以人来说明的话，机器学习相当于人的学习能力和发展能力。<br>通过将人类学习和机器学习做比对，我们发现，机器学习输入的是数据，学到的结果叫模型（类似函数的映射），从数据中学得模型这个过程是通过执行某个学习算法来完成的。</p><p><img src="/../images/machine-learning/01.png"><br><img src="/../images/machine-learning/02.png"></p><p>机器能预测，但不能创造新事物，能记忆，但不能快速变聪明；能复制，但无法超出任务范围；能选择最优项，但无法消灭全人类。</p><h3 id="二-常见概念区分"><a href="#二-常见概念区分" class="headerlink" title="二. 常见概念区分"></a>二. 常见概念区分</h3><table><thead><tr><th>概念名称</th><th>具体含义</th></tr></thead><tbody><tr><td>人工智能</td><td>是一门学科，类似于“生物”或“化学”，其终极目标为实现机器可以想人一样思考，当前发展水平：弱人工智能水平</td></tr><tr><td>机器学习</td><td>实现人工智能的核心算法</td></tr><tr><td>神经网络</td><td>机器学习的一种分支方法，很受欢迎</td></tr><tr><td>深度学习</td><td>机器学习中的一种，主要以神经网络为基础，拥有自适应调节能力关于构建、训练和使用神经网络的一种现代方法，本质上来讲，是一种新的架构</td></tr></tbody></table><h3 id="三-发展历史"><a href="#三-发展历史" class="headerlink" title="三.  发展历史"></a>三.  发展历史</h3><p><img src="/../images/machine-learning/03.png"><br><img src="/../images/machine-learning/04.png"></p><h3 id="四-现状和应用"><a href="#四-现状和应用" class="headerlink" title="四. 现状和应用"></a>四. 现状和应用</h3><p><img src="/../images/machine-learning/05.png"><br><img src="/../images/machine-learning/06.png"></p><h3 id="五-机器学习流程"><a href="#五-机器学习流程" class="headerlink" title="五. 机器学习流程"></a>五. 机器学习流程</h3><p><img src="/../images/machine-learning/07.png"><br><img src="/../images/machine-learning/08.png"></p><h3 id="六-常见机器学习算法"><a href="#六-常见机器学习算法" class="headerlink" title="六. 常见机器学习算法"></a>六. 常见机器学习算法</h3><p>在机器学习的世界里，解决问题的方法从来不是唯一的，总会有好几个算法都可以来解决某个问题，你需要做的是：从中选择最合适的那个。</p><p>但是，所有的问题又都可以使用“神经网络”来处理，但代价是算力的硬件成本。</p><p>经典机器学习算法起源于1950年代的统计学，为了解决诸如寻找数字中模式、估计数据点间的距离以及计算向量方向这类形式的数学问题。</p><p>有监督学习</p><ul><li>线性回归</li><li>多项式回归</li><li>朴素贝叶斯</li><li>决策树</li><li>逻辑回归</li><li>K近邻</li><li>支持向量机</li><li>分类：预测一个对象所属的类别，过滤垃圾邮件、语言检测、查找相似文档、情感分析、欺诈检测等；</li><li>回归：预测数轴上一个特定点，股票价格预测、供应和销售量分析、医学诊断、计算时间序列相关性；</li></ul><p>无监督学习</p><ul><li>Apriori</li><li>Euclat</li><li>FP-growth</li><li>主成分分析PCA</li><li>奇异值分解SVD</li><li>潜在狄利克雷特分配LDA</li><li>潜在语义分析LSA</li><li>t-SNE(用于可视化)</li><li>K均值聚类</li><li>Mean-Shift</li><li>DBSCAN</li><li>聚类：市场细分、图像压缩、检测异常行为、合并地图上邻近的点；</li><li>降维：推荐系统、可视化、主题建模和查找相似文档、假图识别、风险管理</li><li>关联规则学习：预测销售和折扣、分析一起购买的商品、规划商品陈列、分析网页浏览模式</li></ul><p>神经网络分类</p><ol><li>有监督的神经网络</li></ol><ul><li><p>神经网络(Artificial Neural Networks)和深度神经网络(Deep Neural Networks)，ANN&amp;DNN</p></li><li><p>循环神经网络(Recurrent Neural Networks)和递归神经网络(Recursive Neural Networks)，RNN</p></li><li><p>卷积网络(Convolutional Neural Networks)，CNN</p></li></ul><ol start="2"><li>无监督的神经网络</li></ol><ul><li><p>深度生成模型(Deep Generative Models)，DGM</p></li><li><p>玻尔兹曼机(Boltzmann Machines)和受限玻尔兹曼机(Restricted Boltzmann Machines)，BM&amp;RBM</p></li><li><p>深度信念网络(Deep Belief Neural Networks)，DBNN</p></li><li><p>生成式对抗网络(Generative Adversarial Networks)，GAN</p></li></ul><p>举例讲解算法思想</p><ul><li>线性回归</li></ul><p>我们现在要做一个预测房价的模型，首先抽象逻辑定义模型：假设影响房价的因素只有住房面积，假设：y=房价，x=住房面积，则定义模型：y=a*x+b其中x为特征变量，a、b为参数。因此我们的目的就是利用训练数据，去确定参数a、b的值。</p><p><img src="/../images/machine-learning/09.jpeg"></p><p>定义好模型后，需要考虑满足什么样条件的参数模型才是最好的，即需要定义代价函数，这里以每个点到直线的距离和计算，最好的模型应该就是距离和最小</p><p>接下来就是通过数据训练了，训练的数据和量会导致最终模型参数有差异。但是在现实问题中，可能房价跟住房面值不是单纯的直线关系，当住房面积到一定大的时候，房价的增幅就会变缓了；或者说当数据量不够大时，我们得到的模型跟测试数据太拟合了，不够通用。为了解决这些问题，我们就需要正则化，就是让模型更加的通用。<br><img src="/../images/machine-learning/10.png"></p><p>总结：线性回归的特点是主要解决连续值预测的问题，输出的是数值.</p><ul><li>决策树模型</li></ul><p>定义：决策树是附加概率结果的一个树状的决策图，是直观的运用统计概率分析的图法，使用层层推理来实现最终的分类。机器学习中决策树是一个预测模型，它表示对象属性和对象值之间的一种映射，树中的每一个节点表示对象属性的判断条件，其分支表示符合节点条件的对象。树的叶子节点表示对象所属的预测结果。根节点代表选择的内容，叶子节点代表决策的结果。</p><p>简单案例：预测贷款人是否有能力偿还贷款</p><p><img src="/../images/machine-learning/10.png"></p><ul><li>K-Means</li></ul><p>计算质心，聚类无标签数据<br><img src="/../images/machine-learning/11.png"></p><p>K-Means算法是一种常见的聚类算法，其基本步骤为：</p><p>（1）随机生成k个初始点作为质心；</p><p>（2）将数据集中的数据按照距离质心的远近分到各个簇中；</p><p>（3）将各个簇中的数据求平均值，作为新的质心，重复上一步，直到所有的簇不再改变。</p><p>主要应用：客户价值分析</p><ul><li>神经网络和深度学习</li></ul><p>神经网络模拟人脑神经网络而设计的模型，由多个节点（人工神经元）相互联结而成，可以用来对数据之间的复杂关系进行建模。不同节点之间的连接被赋予了不同的权重，每个权重代表了一个节点对另一个节点的影响大小。每个节点代表一种特定函数，来自其他节点的信息经过其相应的权重综合计算。是一个可学习的函数，接受不同数据的训练，不断通过调整权重（梯度下降、反向传播）而得到契合实际模型,一个三层的神经网络可以逼近任意的函数。</p><p><img src="/../images/machine-learning/12.png"></p><p>深度学习本质上由一个个神经元组成。如图每一个点都是一个神经元，它可以接收很多的信号，之后通过它自己的办法做计算（加权平均或者做卷积等等），然后产出一个结果，再发给一些其他的节点，这就是一个神经元。大家发现把很多个神经元这样组合起来，然后把很多的data、output不停地输入到神经元里，最终它会自己学习得把加权平均里的很多的参数、权重都做得非常得优化非常得好，比人手工去写很多的规则、写很多特征的传统的机器学习要好得多。这就是深度学习的思想。</p><p>深度学习是很多层的，要去选择很多的网络结构。比如说神经元里，每一层它可以有（数据的）输入层，有的层可以做卷积运算，有的层可以做池化，有的层把结果全连接或者做激励，它每一层可以做的东西很不一样。怎么把这些层比较好地进行组合产出一个比较好的神经网络呢？在深度学习产生的头几年，大家将这样那样的算法比来比去，其实比的就是谁选的网络结构是比较好的。然后就产生了很多种不同的深度学习的框架，比如深度神经网络、卷积神经网络、深度置信网络等等。</p><p><img src="/../images/machine-learning/13.png"><br><img src="/../images/machine-learning/14.png"><br><img src="/../images/machine-learning/15.png"></p><p>如何选择算法呢？从问题本身、标签的类型、数据集的大小、特征的数量、计算时间的要求、以及模型的可解释性这些方面，来比较和选择算法。</p><h3 id="七-其他：当前面临的问题、未来发展趋势、和运维的结合"><a href="#七-其他：当前面临的问题、未来发展趋势、和运维的结合" class="headerlink" title="七. 其他：当前面临的问题、未来发展趋势、和运维的结合"></a>七. 其他：当前面临的问题、未来发展趋势、和运维的结合</h3><p>现在大部分的人工智能的算法需要很大量的训练数据，小数据样本很难操作。</p><p>深度学习网络里面的参数到底怎么调、特征到底怎么选，根本不知道，都是给它大量的数据让它不断地学不断地学。这就导致一旦出问题会是一些非常诡异的问题，然后还很难找到这个问题是什么。而且很多时候我们发现这个学习是一次性的——对这堆数据学了之后，它可以得出一个样本，但是当我想再加一点要求，再加一点数据，再加一点背景时，会发现原来学习的这个模型什么用都没有了，很多时候要重新去学。现在的很多算法是缺乏增量学习的能力的。<br><img src="/../images/machine-learning/16.png"></p><p>如果更长期地看，2017年美国有一个网站叫Business Insider（《商业内幕》/《商业内参》），发表了一个文章用了，说我们现在的很多工作未来在什么时间会被机器所替代。这里边有几个比较有意思的，比如说它认为可能到二零零几年的时候，基本上语言的翻译就可以实现。现在我们看Siri、Google Assistant、国内的讯飞等已经能比较好地翻译语音了。然后它认为到2030年左右机器可以去开一辆卡车，就是自动驾驶应该到了L4的阶段，可以去驾驶卡车。还有一些很有意思，我们之前认为还是要保留一些人类的自留地的，一些涉及情感、审美、艺术创作的东西是我们人类的最后领地。但是我们会看到，比如说到2030年左右，排行榜上的这种歌曲就可以由机器来产生；再往后看，大概在2050年左右机器就可以写畅销书了。我不知道是乐观还是悲观，他们认为2060年左右所有人类工作基本上都可以被机器替代。当然这是这家杂志的观点，具体是不是对的我们可以讨论。但的确我们觉得人工智能未来会在社会中产生越来越大的作用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试-http</title>
      <link href="2022/12/05/http/"/>
      <url>2022/12/05/http/</url>
      
        <content type="html"><![CDATA[<h4 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h4><p>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p><h4 id="http的请求报文和返回报文"><a href="#http的请求报文和返回报文" class="headerlink" title="http的请求报文和返回报文"></a>http的请求报文和返回报文</h4><ul><li>请求报文：</li></ul><ul><li>accept-charset</li><li>accept-encoding</li><li>accept-language</li><li>Host</li><li>User-agent</li><li>connection</li><li>cookie</li><li>If-Modified-Since</li></ul><ul><li>返回报文</li></ul><ul><li>server</li><li>content-type</li><li>content-encoding</li><li>content-language</li><li>keep-alive</li><li>ETag</li><li>cache-control</li><li>Expires</li><li>last-Modified</li><li>access-control-allow-origin：</li></ul><h4 id="tcp和udp-的区别"><a href="#tcp和udp-的区别" class="headerlink" title="tcp和udp 的区别"></a>tcp和udp 的区别</h4><p>tcp：面向连接、传输可靠，可用于传输大量数据,速度慢，建立连接需要开销较多<br>udp: 面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快 ,可能丢包</p><h4 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h4><p>多了一层SSL加密，<br>客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。服务器公钥放在数字证书中。</p><h4 id="http2-0-和http1-的区别"><a href="#http2-0-和http1-的区别" class="headerlink" title="http2.0 和http1 的区别"></a>http2.0 和http1 的区别</h4><ul><li>多路复用：相同域名多个请求，共享同一个TCP连接，降低了延迟</li><li>请求优先级：给每个request设置优先级</li><li>服务端推送：可以主动向客户端发送消息。</li><li>头部压缩：减少包的大小跟数量</li></ul><h4 id="tcp-三次握手"><a href="#tcp-三次握手" class="headerlink" title="tcp 三次握手"></a>tcp 三次握手</h4><p>客户端 发送SYN 包<br>服务端接受并发生SYN+ACK包<br>客户端接受ACK包并发送至服务端，建立连接</p><h4 id="tcp-四次挥手"><a href="#tcp-四次挥手" class="headerlink" title="tcp 四次挥手"></a>tcp 四次挥手</h4><p>客户端发出FIN包，进入FIN-WAIT<br>服务端发出确认报文 ACK 进入 CLOSE-WAIT<br>服务端发送连接释放报文，进入LAST-ACK<br>客户端发出ACK，等待2*MSL（最长报文段寿命）进入closed状态</p><h4 id="http-code"><a href="#http-code" class="headerlink" title="http code"></a>http code</h4><p>1xx：信息，请求收到，继续处理<br>2xx：成功，行为被成功地接受、理解和采纳<br>3xx：重定向，为了完成请求，必须进一步执行的动作<br>4xx：客户端错误，请求包含语法错误或者请求无法实现<br>5xx：服务器错误，服务器不能实现一种明显无效的请求 </p><p>200 OK：客户端请求成功<br>201 用户新建或修改数据成功<br>202 一个请求已经进入后台<br>204 No Content：无内容。服务器成功处理，但未返回内容。一般用在只是客户端向服务器发送信息，而服务器不用向客户端返回什么信息的情况。不会刷新页面。<br>206 Partial Content：服务器已经完成了部分GET请求（客户端进行了范围请求）。响应报文中包含Content-Range指定范围的实体内容</p><p>301 Moved Permanently：永久重定向，表示请求的资源已经永久的搬到了其他位置。</p><p>302 Found：临时重定向，表示请求的资源临时搬到了其他位置</p><p>303 See Other：临时重定向，应使用GET定向获取请求资源。303功能与302一样，区别只是303明确客户端应该使用GET访问</p><p>307 Temporary Redirect：临时重定向，和302有着相同含义。POST不会变成GET</p><p>304 Not Modified：表示客户端发送附带条件的请求（GET方法请求报文中的IF…）时，条件不满足。返回304时，不包含任何响应主体。虽然304被划分在3XX，但和重定向一毛钱关系都没有</p><p>400 Bad Request：客户端请求有语法错误，服务器无法理解。<br>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。<br>403 Forbidden：服务器收到请求，但是拒绝提供服务<br>404 Not Found：请求资源不存在。比如，输入了错误的url<br>415 Unsupported media type：不支持的媒体类型</p><p>500 Internal Server Error：服务器发生不可预期的错误。<br>502 网关错误<br>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常<br>504 网关超时<br>505 HTTP版本未被支持</p><h4 id="websocket的连接原理"><a href="#websocket的连接原理" class="headerlink" title="websocket的连接原理"></a>websocket的连接原理</h4><p>轮询<br>客户端通过一定的时间间隔以频繁请求的方式向服务器发送请求，来保持客户端和服务器端的数据同步。问题很明显，当客户端以固定频率向服务器端发送请求时，服务器端的数据可能并没有更新，带来很多无谓请求，浪费带宽，效率低下。</p><p>从上文可以看出，传统 Web 模式在处理高并发及实时性需求的时候，会遇到难以逾越的瓶颈，我们需要一种高效节能的双向通信机制来保证数据的实时传输。在此背景下，基于 HTML5 规范的、有 Web TCP 之称的 WebSocket 应运而生。</p><p>WebSocket 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯，它建立在 TCP 之上，同 HTTP 一样通过 TCP 来传输数据，但是它和 HTTP 最大不同是：</p><p>WebSocket 是一种双向通信协议，在建立连接后，WebSocket 服务器和 Browser/Client Agent 都能主动的向对方发送或接收数据，就像 Socket 一样；<br>WebSocket 需要类似 TCP 的客户端和服务器端通过握手连接，连接成功后才能相互通信。</p><h4 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h4><p>跨域是指一个域下的文档或脚本试图去请求另一个域下的资源</p><p>什么是同源策略？<br>同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。<br>同源策略限制以下几种行为：</p><ol><li>Cookie、LocalStorage 和 IndexDB 无法读取</li><li>DOM 和 Js对象无法获得</li><li>AJAX 请求不能发送</li></ol><p>跨域解决方案<br>1、 通过jsonp跨域<br>2、 document.domain + iframe跨域<br>3、 location.hash + iframe<br>4、 window.name + iframe跨域<br>5、 postMessage跨域<br>6、 跨域资源共享（CORS）<br>7、 nginx代理跨域<br>8、 nodejs中间件代理跨域<br>9、 WebSocket协议跨域</p><h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><p>预检请求是在进行跨域资源共享 CORS 时，由浏览器自动发起的一种 OPTIONS 请求。它的存在是为了保障安全，并允许服务器决定是否允许跨域请求。</p><p>跨域请求是指在浏览器中向不同域名、不同端口或不同协议的资源发送请求。出于安全原因，浏览器默认禁止跨域请求，只允许同源策略。而当网页需要进行跨域请求时，浏览器会自动发送一个预检请求，以确定是否服务器允许实际的跨域请求。</p><p>预检请求中包含了一些额外的头部信息，如 Origin 和 Access-Control-Request-Method 等，用于告知服务器实际请求的方法和来源。服务器收到预检请求后，可以根据这些头部信息，进行验证和授权判断。如果服务器认可该跨域请求，将返回一个包含 Access-Control-Allow-Origin 等头部信息的响应，浏览器才会继续发送实际的跨域请求。</p><p>使用预检请求机制可以有效地防范跨域请求带来的安全风险，保护用户数据和隐私。</p><h3 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h3><p>该安全策略的实现基于一个称作 Content-Security-Policy的 HTTP 首部。<br>可以移步MDN，有更加规范的解释。我在这里就是梳理一下吧。<br>CSP，即浏览器中的内容安全策略，它的核心思想大概就是服务器决定浏览器加载哪些资源，具体来说有几个功能</p><ul><li>限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；</li><li>禁止向第三方域提交数据，这样用户数据也不会外泄；</li><li>提供上报机制，能帮助我们及时发现 XSS 攻击。</li><li>禁止执行内联脚本和未授权的脚本；</li></ul><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试-webpack和Node</title>
      <link href="2022/12/04/webpack-he-node/"/>
      <url>2022/12/04/webpack-he-node/</url>
      
        <content type="html"><![CDATA[<h4 id="loader-和plugin的区别"><a href="#loader-和plugin的区别" class="headerlink" title="loader 和plugin的区别"></a>loader 和plugin的区别</h4><p>loader即为文件加载器，操作的是文件，将文件A通过loader转换成文件B，是一个单纯的文件转化过程。<br>plugin即为插件，是一个扩展器，丰富webpack本身，增强功能 ，针对的是在loader结束之后，webpack打包的整个过程，他并不直接操作文件，而是基于事件机制工作，监听webpack打包过程中的某些节点，执行广泛的任务。</p><ul><li>Loader 特性:</li></ul><ul><li>链式传递，按照配置时相反的顺序链式执行;</li><li>基于 Node 环境，拥有 较高权限，比如文件的增删查改; 可同步也可异步;</li></ul><ul><li>编写原则:</li></ul><ul><li>单一原则: 每个 Loader 只做一件事;</li><li>链式调用: Webpack 会按顺序链式调用每个 Loader;</li><li>统一原则: 遵循 Webpack 制定的设计规则和结构，输入与输出均为字符串，各个 Loader 完全独立，即插即用;</li></ul><ul><li>plugin<br>在编译的整个生命周期中，Webpack 会触发许多事件钩子， Plugin 可以监听这些事件，根据需求在相应的时间点对打包内容进行定向的修改。</li></ul><p>Plugin的组成部分<br>1）Plugin的本质是一个 node 模块，这个模块导出一个JavaScript 类<br>2）它的原型上需要定义一个apply 的方法<br>3）通过compiler获取webpack内部的钩子，获取webpack打包过程中的各个阶段<br>钩子分为同步和异步的钩子，异步钩子必须执行对应的回调<br>4）通过compilation操作webpack内部实例特定数据<br>5）功能完成后，执行webpack提供的cb回调</p><ul><li>事件流机制<br>Webpack 就像工厂中的一条产品流水线。原材料经过 Loader 与 Plugin 的一道道处理，最后输出结果。</li></ul><ul><li>通过链式调用，按顺序串起一个个 Loader;</li><li>通过事件流机制，让 Plugin 可以插入到整个生产过程中的每个步骤中;</li></ul><p>Webpack 事件流编程范式的核心是基础类<code> Tapable</code> ，是一种 观察者模式 的实现事件的订阅与广播:<br>Webpack 中两个最重要的类 <code>Compiler</code> 与 <code>Compilation</code> 便是继承于 Tapable，也拥有这样的事件流机制。</p><ul><li>Compiler: 可以简单的理解为 Webpack 实例，它包含了当前 Webpack 中的所有配置信息，如 options， loaders, plugins 等信息，全局唯一，只在启动时完成初始化创建，随着生命周期逐一传递; </li><li>Compilation: 可以称为 编译实例。当监听到文件发生改变时，Webpack 会创建一个新的 Compilation 对象，开始一次新的编译。它包含了当前的输入资源，输出资源，变化的文件等，同时通过它提供的 api，可 以监听每次编译过程中触发的事件钩子;</li></ul><p>区别:</p><ul><li>Compiler 全局唯一，且从启动生存到结束;</li><li>Compilation 对应每次编译，每轮编译循环均会重新创建;</li></ul><h5 id="常用-Plugin"><a href="#常用-Plugin" class="headerlink" title="常用 Plugin:"></a>常用 Plugin:</h5><ul><li>UglifyJsPlugin: 压缩、混淆代码;</li><li>Optimization.splitChunks: 代码分割;</li><li>ProvidePlugin: 自动加载模块;</li><li>html-webpack-plugin: 加载 html 文件，并引入 css / js 文件; </li><li>extract-text-webpack-plugin / mini-css-extract-plugin: 抽离样式，生成 css 文件; </li><li>DefinePlugin: 定义全局变量;</li><li>optimize-css-assets-webpack-plugin: CSS 代码去重; </li><li>webpack-bundle-analyzer: 代码分析;</li><li>compression-webpack-plugin: 使用 gzip 压缩 js 和 css; </li><li>happypack: 使用多进程，加速代码构建; </li><li>EnvironmentPlugin: 定义环境变量;</li></ul><h4 id="优化技巧"><a href="#优化技巧" class="headerlink" title="优化技巧"></a>优化技巧</h4><p>缓存、加快打包速度、缩小打包体积</p><ol><li>缓存，比如bable-loader 添加cacheDirectory为true来开启缓存</li></ol><pre class=" language-js"><code class="language-js"><span class="token punctuation">{</span>    test<span class="token punctuation">:</span> <span class="token regex">/\.js$/</span><span class="token punctuation">,</span>    loader<span class="token punctuation">:</span> <span class="token string">'babel-loader'</span><span class="token punctuation">,</span>    options<span class="token punctuation">:</span> <span class="token punctuation">{</span>      cacheDirectory<span class="token punctuation">:</span> <span class="token boolean">true</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><p>cacheLoader</p><ol start="2"><li>加快打包速度<br>多核打包，比如使用happyPack/Thread-loader/Parallel-Webpack<br>高效编译，对于JS的编译选用不同的编译器，比如ESBuild 基于Go语言开发的JavaScript Bundler 和SWC 基于Rust的JavaScript Compiler(其生态中也包含打包工具spack), 目前为Next.JS/Parcel/Deno等前端圈知名项目使用</li></ol><p>3、缩小打包体积</p><ul><li>使用Tree-shaking、减少打包代码</li><li>对于大的模块引入thread-loader</li><li>对于不常用的变更抽离出去 ，一种是使用webpack-dll-plugin,在首次构建时候将这些静态依赖打包，另外一种是使用Externals，将这些不常用的静态资源抽离，并用cdn方式引用他们</li><li>compression-webpack-plugin 压缩js和css代码</li></ul><h4 id="什么是Tree-Shark"><a href="#什么是Tree-Shark" class="headerlink" title="什么是Tree-Shark"></a>什么是Tree-Shark</h4><p>摇树优化 (Tree-shaking)，这是一种形象比喻。我们把打包后的代码比喻成一棵树，这里其实表示的就 是，通过工具 “摇” 我们打包后的 js 代码，将没有使用到的无用代码 “摇” 下来 (删除)。即 消除那些被 引用了但未被使用 的模块代码。<br>原理: 由于是在编译时优化，因此最基本的前提就是语法的静态分析，ES6的模块机制提供了这种可能性。不需要运行时，便可进行代码字面上的静态分析，确定相应的依赖关系。<br>问题: 具有副作用的函数无法被 tree-shaking。 在引用一些第三方库，需要去观察其引入的代码 量是不是符合预期; 尽量写纯函数，减少函数的副作用; 可使用 webpack-deep-scope-plugin， 可以进行作用域分析，减少此类情况的发生，但仍需要注意;</p><h4 id="performance-对象api"><a href="#performance-对象api" class="headerlink" title="performance 对象api"></a>performance 对象api</h4><p>属性</p><ul><li>memory</li><li>navigation </li><li>timing<br><img src="https://img-blog.csdnimg.cn/20200717141446763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0ODE0MDU=,size_16,color_FFFFFF,t_70"></li></ul><p>方法</p><ul><li>getEntries() 这个函数返回的将是一个数组，包含了页面中所有的 HTTP 请求</li><li>now()  输出的是相对于 performance.timing.navigationStart(页面初始化) 的时间, Date.now() 输出的是 UNIX 时间，即距离 1970 的时间 </li><li>mark()  performance.mark() 标记各种时间戳（就像在地图上打点），保存为各种测量值（测量地图上的点之间的距离），便可以批量地分析这些数据了。</li></ul><p>后来 window.performance.timing 被废弃，通过 PerformanceObserver 旧的 api，返回的是一个 UNIX 类型的绝对时间，和用户的系统时间相关，分析的时候需要再次计算。而新的 api，返回的是一个相对时间，可以直接用来分析</p><h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3><p>开发过程中，代码发生变动后，webpack会重新编译，编译后浏览器替换修改的模块，局部更新，无需刷新整个页面</p><p>主要是通过websocket实现，建立本地服务和浏览器的双向通信。当代码变化，重新编译后，通知浏览器请求更新的模块，替换原有的模块<br>1） 通过webpack-dev-server开启server服务，本地server启动之后，再去启动websocket服务，建立本地服务和浏览器的双向通信<br>2） webpack每次编译后，会生成一个Hash值，Hash代表每一次编译的标识。本次输出的Hash值会编译新生成的文件标识，被作为下次热更新的标识<br>3）webpack监听文件变化（主要是通过文件的生成时间判断是否有变化），当文件变化后，重新编译<br>4）编译结束后，通知浏览器请求变化的资源，同时将新生成的hash值传给浏览器，用于下次热更新使用<br>5）浏览器拿到更新后的模块后，用新模块替换掉旧的模块，从而实现了局部刷新</p><h3 id="模块联邦"><a href="#模块联邦" class="headerlink" title="模块联邦"></a>模块联邦</h3><p>webpack5 模块联邦(Module Federation) 使 JavaScript应用，得以从另一个 JavaScript应用中动态的加载代码，实现共享依赖，用于前端的微服务化<br>比如项目A和项目B，公用项目C组件，以往这种情况，可以将C组件发布到npm上，然后A和B再具体引入。当C组件发生变化后，需要重新发布到npm上，A和B也需要重新下载安装<br>使用模块联邦后，可以在远程模块的Webpack配置中，将C组件模块暴露出去，项目A和项目B就可以远程进行依赖引用。当C组件发生变化后，A和B无需重新引用<br>模块联邦利用webpack5内置的ModuleFederationPlugin插件，实现了项目中间相互引用的按需热插拔</p><h3 id="一个简单的AST示例"><a href="#一个简单的AST示例" class="headerlink" title="一个简单的AST示例"></a>一个简单的AST示例</h3><p>let a = 1，转化成AST的结果</p><pre class=" language-js"><code class="language-js"><span class="token punctuation">{</span>  <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"Program"</span><span class="token punctuation">,</span>  <span class="token string">"start"</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token string">"end"</span><span class="token punctuation">:</span> <span class="token number">9</span><span class="token punctuation">,</span>  <span class="token string">"body"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"VariableDeclaration"</span><span class="token punctuation">,</span>      <span class="token string">"start"</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>      <span class="token string">"end"</span><span class="token punctuation">:</span> <span class="token number">9</span><span class="token punctuation">,</span>      <span class="token string">"declarations"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>          <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"VariableDeclarator"</span><span class="token punctuation">,</span>          <span class="token string">"start"</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span>          <span class="token string">"end"</span><span class="token punctuation">:</span> <span class="token number">9</span><span class="token punctuation">,</span>          <span class="token string">"id"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>            <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"Identifier"</span><span class="token punctuation">,</span>            <span class="token string">"start"</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span>            <span class="token string">"end"</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span>            <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"a"</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token string">"init"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>            <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"Literal"</span><span class="token punctuation">,</span>            <span class="token string">"start"</span><span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">,</span>            <span class="token string">"end"</span><span class="token punctuation">:</span> <span class="token number">9</span><span class="token punctuation">,</span>            <span class="token string">"value"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>            <span class="token string">"raw"</span><span class="token punctuation">:</span> <span class="token string">"1"</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token string">"kind"</span><span class="token punctuation">:</span> <span class="token string">"let"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token string">"sourceType"</span><span class="token punctuation">:</span> <span class="token string">"module"</span><span class="token punctuation">}</span></code></pre><h3 id="koa和express的区别"><a href="#koa和express的区别" class="headerlink" title="koa和express的区别"></a>koa和express的区别</h3><p>express框架是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，主要基于 Connect 中间件，并且自身封装了路由、视图处理等功能。</p><p>koa是 Express 原班人马基于 ES6 新特性重新开发的框架，主要基于 co 中间件，框架自身不包含任何中间件，很多功能需要借助第三方中间件解决，但是由于其基于 ES6 generator 特性的异步流程控制，解决了 “callback hell” 和麻烦的错误处理问题。</p><p>相同点<br>两个框架都对http进行了封装。相关的api都差不多，同一批人所写。</p><p>不同点<br>express内置了许多中间件可供使用，而koa没有。</p><p>express包含路由，视图渲染等特性，而koa只有http模块。</p><p>express的中间件模型为线型，而koa的中间件模型为U型，也可称为洋葱模型构造中间件。</p><p>express通过回调实现异步函数，在多个回调、多个中间件中写起来容易逻辑混乱。</p><h3 id="node的错误监控"><a href="#node的错误监控" class="headerlink" title="node的错误监控"></a>node的错误监控</h3><p>try catch 通常用于捕获throw抛出的错误</p><p>callback(err, result)回调函数处理</p><p>Emitter.on的回调函数 on注册了事件和回调函数， 并且在emit触发事件后会执行回调函数，以达到捕获错误的解决方式。</p><p>process.on(“error”, function(err){})<br>错误异常有两种场景的出现：</p><p>一种是代码运行中throw new error没有被捕获，另一种是Promise的失败回调函数，没有对应的reject回调函数处理，针对这两种情况Nodejs都有默认的统一处理方式，就是给整个进程process对象监听相应的错误事件。<br>process.on(‘uncaughtException’,function(err){}) //监听未捕获的异常<br>process.on(‘unhandledRejection’,function(err,promise){}) //监听Promise没有被捕获的失败函数</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> webpack </tag>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试-算法</title>
      <link href="2022/12/04/suan-fa/"/>
      <url>2022/12/04/suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="1-排序"><a href="#1-排序" class="headerlink" title="1.排序"></a>1.排序</h2><h3 id="1-1-快排"><a href="#1-1-快排" class="headerlink" title="1.1 快排"></a>1.1 快排</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> quickSort <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span>  <span class="token keyword">var</span> j <span class="token operator">=</span> r<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    x <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">!==</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        j<span class="token operator">--</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token punctuation">[</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token punctuation">[</span>a<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">quickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> l<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">quickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>快排核心是先找到数字的位置，然后两边分别是该数字的小值和大值，其时间复杂度为O(nlogn)</p><h2 id="2-排列组合"><a href="#2-排列组合" class="headerlink" title="2.排列组合"></a>2.排列组合</h2><h3 id="2-1-全排列"><a href="#2-1-全排列" class="headerlink" title="2.1 全排列"></a>2.1 全排列</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">peru</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">const</span> dfs <span class="token operator">=</span> <span class="token punctuation">(</span>tempArr<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>leftArr<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tempArr<span class="token punctuation">.</span>length <span class="token operator">===</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tempArr<span class="token punctuation">,</span><span class="token string">'temp'</span><span class="token punctuation">)</span>            res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tempArr<span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            leftArr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token keyword">let</span> temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>leftArr<span class="token punctuation">]</span>                temp<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>tempArr<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">,</span>temp<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">)</span>     <span class="token keyword">return</span> res<span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">peru</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="2-2-组合"><a href="#2-2-组合" class="headerlink" title="2.2 组合"></a>2.2 组合</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> combine <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>n<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token keyword">function</span> <span class="token function">dfs</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span>n<span class="token punctuation">,</span>k<span class="token punctuation">,</span>temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token punctuation">(</span>n<span class="token operator">-</span>cur<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token punctuation">.</span>length<span class="token operator">===</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>          res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span>          <span class="token keyword">return</span>       <span class="token punctuation">}</span>      <span class="token function">dfs</span><span class="token punctuation">(</span>cur<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>k<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">...</span>temp<span class="token punctuation">,</span>cur<span class="token punctuation">]</span><span class="token punctuation">)</span>      <span class="token function">dfs</span><span class="token punctuation">(</span>cur<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>k<span class="token punctuation">,</span>temp<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>k<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> res<span class="token punctuation">}</span></code></pre><h2 id="3-背包问题"><a href="#3-背包问题" class="headerlink" title="3. 背包问题"></a>3. 背包问题</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> pack<span class="token operator">=</span><span class="token punctuation">(</span>total<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">const</span> value<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>    <span class="token keyword">const</span> weights<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>    <span class="token keyword">const</span> m <span class="token operator">=</span> value<span class="token punctuation">.</span>length    <span class="token keyword">const</span> n <span class="token operator">=</span> total    <span class="token comment" spellcheck="true">// dp[i][j]表示有i件商品，最大承重为j的最大价值，</span>    <span class="token keyword">const</span> dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 如果选择第i件商品</span>    <span class="token comment" spellcheck="true">// dp[i][j]=dp[i-1][j-weights[i]]+values[i]</span>    <span class="token comment" spellcheck="true">// 如果不选择第i件商品</span>    <span class="token comment" spellcheck="true">// dp[i][j]=dp[i-1][j]</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j<span class="token operator">&lt;</span>weights<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>weights<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>values<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">}</span></code></pre><h2 id="4-动态规划"><a href="#4-动态规划" class="headerlink" title="4. 动态规划"></a>4. 动态规划</h2><h3 id="4-1-最长公共子序列"><a href="#4-1-最长公共子序列" class="headerlink" title="4.1 最长公共子序列"></a>4.1 最长公共子序列</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> longString<span class="token operator">=</span><span class="token punctuation">(</span>nums1<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums2<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">const</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>nums1<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>nums2<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// dp[i][j]表示第一个数组前i个元素第二个数组前j个元素的最长公共子序列</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>nums1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>nums2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">===</span>nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">}</span></code></pre><h3 id="4-2-最长上升子序列"><a href="#4-2-最长上升子序列" class="headerlink" title="4.2 最长上升子序列"></a>4.2 最长上升子序列</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> fn<span class="token operator">=</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">const</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">}</span></code></pre><h2 id="5-树的遍历"><a href="#5-树的遍历" class="headerlink" title="5. 树的遍历"></a>5. 树的遍历</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 前序遍历</span><span class="token keyword">var</span> preorderTraversal <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">preorderTraversal1</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> preorderTraversal1 <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>    arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token function">preorderTraversal1</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token function">preorderTraversal1</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 中序遍历</span><span class="token keyword">var</span> inorderTraversal <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">inorderTraversal1</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> inorderTraversal1 <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token function">inorderTraversal1</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token function">inorderTraversal1</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 后续遍历</span><span class="token keyword">var</span> postorderTraversal <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">postorderTraversal1</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> postorderTraversal1 <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token function">postorderTraversal1</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token function">postorderTraversal1</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>     arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 层序遍历</span><span class="token keyword">var</span> levelOrder <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> values <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> values<span class="token punctuation">;</span>    <span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> levelList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> levelLength <span class="token operator">=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">const</span> current <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        levelList<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span>left<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span>right<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        levelLength<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>levelLength <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 当上一层长度递减到0，队列里剩下的数量，就是下一层数量</span>            levelLength <span class="token operator">=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span>            values<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>levelList<span class="token punctuation">)</span><span class="token punctuation">;</span>            levelList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> values<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="6-链表"><a href="#6-链表" class="headerlink" title="6. 链表"></a>6. 链表</h2><h3 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> reverseBetween <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>head<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> pre <span class="token operator">=</span> dummy<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">let</span> rightNode <span class="token operator">=</span> pre<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    rightNode <span class="token operator">=</span> rightNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">let</span> leftNode <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token keyword">let</span> curr <span class="token operator">=</span> rightNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  pre<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  rightNode<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token function">reverse</span><span class="token punctuation">(</span>leftNode<span class="token punctuation">)</span><span class="token punctuation">;</span>  pre<span class="token punctuation">.</span>next <span class="token operator">=</span> rightNode<span class="token punctuation">;</span>  leftNode<span class="token punctuation">.</span>next <span class="token operator">=</span> curr<span class="token punctuation">;</span>  <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> reverse <span class="token operator">=</span> <span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> temp <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    cur<span class="token punctuation">.</span>next <span class="token operator">=</span> prev<span class="token punctuation">;</span>    prev <span class="token operator">=</span> cur<span class="token punctuation">;</span>    cur <span class="token operator">=</span> temp<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>移除链表元素</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> removeElements <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>head<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> temp <span class="token operator">=</span> dummy<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>temp<span class="token punctuation">.</span>next <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">===</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>      temp<span class="token punctuation">.</span>next <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      temp <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="7-广度优先和深度优先"><a href="#7-广度优先和深度优先" class="headerlink" title="7. 广度优先和深度优先"></a>7. 广度优先和深度优先</h2><p>深度优先采用堆栈的形式，即先进后出<br>广度优先采用队列的形式，先进先出</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>   name<span class="token punctuation">:</span> <span class="token string">'a2'</span><span class="token punctuation">,</span>        children<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'b2'</span><span class="token punctuation">,</span> children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'e2'</span> <span class="token punctuation">}</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'c2'</span><span class="token punctuation">,</span> children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'f2'</span> <span class="token punctuation">}</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'d2'</span><span class="token punctuation">,</span> children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'g2'</span> <span class="token punctuation">}</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">// 深度</span><span class="token keyword">function</span> <span class="token function">getNames</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    data<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">const</span>  dfs <span class="token operator">=</span> data <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        data<span class="token punctuation">.</span>children <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">foreach</span><span class="token punctuation">(</span>child<span class="token operator">=</span><span class="token operator">></span><span class="token function">dfs</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 广度遍历</span><span class="token keyword">function</span> <span class="token function">getNames</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">let</span> queue <span class="token operator">=</span> data    <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">[</span><span class="token operator">...</span>queue<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>child<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>            child<span class="token punctuation">.</span>children <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>child<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h2 id="8-找零钱"><a href="#8-找零钱" class="headerlink" title="8.找零钱"></a>8.找零钱</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">findCoins</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>coins<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 用于保存每个目标总额对应的最小硬币个数</span>  <span class="token keyword">const</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 提前定义已知情况</span>  f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 遍历 [1, amount] 这个区间的硬币总额</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> amount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 求的是最小值，因此我们预设为无穷大，确保它一定会被更小的数更新</span>    f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">Infinity</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 循环遍历每个可用硬币的面额</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> coins<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 若硬币面额小于目标总额，则问题成立</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> coins<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 状态转移方程</span>        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> coins<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 若目标总额对应的解为无穷大，则意味着没有一个符合条件的硬币总数来更新它，本题无解，返回-1</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">Infinity</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 若有解，直接返回解的内容</span>  <span class="token keyword">return</span> f<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">findCoins</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3</span></code></pre><h2 id="9-三数之和"><a href="#9-三数之和" class="headerlink" title="9.三数之和"></a>9.三数之和</h2><p>给定一个数组nums，判断 nums 中是否存在三个元素a，b，c ，使得 a + b + c = target</p><p>找出所有满足条件且不重复的三元组合</p><p>思路：</p><p>将数组排序，然后固定数组中某一项，用双端指针的方式，查到两数之和加上该项的值等于目标值，将三数之和转化为两数之和</p><p>题目中说明可能会出现多组结果，所以我们要考虑好去重</p><p>1）为了方便去重，我们首先将数组从小到大排列</p><p>2）对数组进行遍历，取当前遍历的数nums[i]为一个基准数</p><p>3）在寻找数组中设定两个起点，最左侧的left(i+1)和最右侧的right(length-1)</p><p>4）判断nums[i] + nums[left] + nums[right]是否等于目标值target</p><p>5）如果相等，存储该结果，并分别将left和right各移动一位</p><p>6）如果大于目标值，将right向左移动一位，向结果逼近</p><p>7）如果小于目标值，将left向右移动一位，向结果逼近</p><p>8）一轮遍历结束后i++，进入下一轮查询</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">findThree</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>  arr<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 跳过重复的arr[i]值, 比如[2, 1, 1],跳过第二个1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> arr<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> left <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> right <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> sum <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        right<span class="token operator">--</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        left<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// arr[left++], 先取arr[left]，然后left++, 两步合成一步；arr[right--]同样的逻辑</span>        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>right<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">===</span> arr<span class="token punctuation">[</span>left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 跳过重复的arr[left]值,</span>          left<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">===</span> arr<span class="token punctuation">[</span>right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 跳过重复的arr[right]值</span>          right<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">findThree</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//  [1, 1, 6] [1, 2, 5] [1, 3, 4]</span></code></pre><h2 id="10-四数之和"><a href="#10-四数之和" class="headerlink" title="10.四数之和"></a>10.四数之和</h2><p>给定一个整数数组nums，判断 nums 中是否存在四个元素a，b，c，d ，使得 a + b + c + d = target，找出所有满足条件且不重复的四元组合</p><p>思路</p><p>到这里其实我们就能发现一些规律，可以像三数之和那样，通过大小指针来逼近结果，从而达到降低一层时间复杂度的效果（重点：将4个数相加，转化为三个数，降低层级）</p><p>不管是几数之和，都可以用这种方法来进行降级优化</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">findFour</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  arr<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 最外层控制循环次数，循环次数为arr.length - 3</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 跳过数组中，重复的起始值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> arr<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 因为数组已进行排序，所有一旦超过目标值，那么以后的值也都比目标值大，所以可以直接结束这一轮循环</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 注意范围，第二个值的最小值是倒数第3位（以下的代码和三个数求和的逻辑一致）</span>      <span class="token comment" spellcheck="true">// 跳过数组中，第二个值重复的</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">===</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 第三个数的下标</span>      <span class="token keyword">let</span> left <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">let</span> right <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> sum <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>          right<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>          left<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 坑点，注意添加后，left++， right--, 确保循环继续执行</span>          result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>right<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">===</span> arr<span class="token punctuation">[</span>left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 跳过重复的值</span>            left<span class="token operator">++</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">===</span> arr<span class="token punctuation">[</span>right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 跳过重复的值</span>            right<span class="token operator">--</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">findFour</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [0, 1, 2, 7]   [0, 1, 3, 6] [0, 1, 4</span></code></pre><h2 id="11-连续整数之和"><a href="#11-连续整数之和" class="headerlink" title="11. 连续整数之和"></a>11. 连续整数之和</h2><p>输入一个正整数S，打印出所有和为S的连续整数序列</p><p>例如：输入15，连续整数序列有：1+2+3+4+5 = 4+5+6 = 7+8 = 15，所以打印出3个连续序列1-5，5-6和7-8</p><p>思路:</p><p>1）创建一个容器child，用于表示当前的子序列，初始元素为1,2</p><p>2）记录子序列的开头元素small和末尾元素big</p><p>3）big向右移动子序列末尾增加一个数；small向右移动子序列开头减少一个数</p><p>4）当子序列的和大于目标值，small向右移动，子序列的和小于目标值，big向右移动</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">FindContinuousSequence</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 记录当前的结果</span>  <span class="token keyword">let</span> child <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> small <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始值1</span>  <span class="token keyword">let</span> big <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//</span>  <span class="token keyword">let</span> currentSum <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当前数字之和</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>big <span class="token operator">&lt;</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// big等于sum时，child中只剩一个数，不满足连续正数序列的要求，结束循环</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>currentSum <span class="token operator">&lt;</span> sum <span class="token operator">&amp;&amp;</span> big <span class="token operator">&lt;</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>      child<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">++</span>big<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// currentSum为当前child的和</span>      currentSum <span class="token operator">+</span><span class="token operator">=</span> big<span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>currentSum <span class="token operator">></span> sum <span class="token operator">&amp;&amp;</span> small <span class="token operator">&lt;</span> big<span class="token punctuation">)</span> <span class="token punctuation">{</span>      child<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 因为删除了最小值，所以small也要响应变化，增加1</span>      currentSum <span class="token operator">-</span><span class="token operator">=</span> small<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentSum <span class="token operator">===</span> sum <span class="token operator">&amp;&amp;</span> child<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// child.length大于1，剔除一个数等于sum的情况</span>      <span class="token comment" spellcheck="true">// child.slice返回一个新的数组</span>      result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      child<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">++</span>big<span class="token punctuation">)</span><span class="token punctuation">;</span>      currentSum <span class="token operator">+</span><span class="token operator">=</span> big<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">FindContinuousSequence</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1, 2, 3, 4, 5] [4, 5, 6] [7, 8]</span></code></pre><h4 id="递归-斐波拉契数列"><a href="#递归-斐波拉契数列" class="headerlink" title="递归 斐波拉契数列"></a>递归 斐波拉契数列</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">feibo</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> sum1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> sum2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> sum2<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">feibo</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> sum2<span class="token punctuation">,</span> sum1 <span class="token operator">+</span> sum2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="模版替换"><a href="#模版替换" class="headerlink" title="模版替换"></a>模版替换</h4><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// var reg=/\${(\w+)}/g</span><span class="token comment" spellcheck="true">// var regNew = /\$\{(.+?)\}/</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"wt"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"${name}sss${name}"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// var keyArr = str.match(/\$\{(.+?)\}/)[1];</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">"\\${"</span> <span class="token operator">+</span> item <span class="token operator">+</span> <span class="token string">"}"</span><span class="token punctuation">,</span> <span class="token string">"g"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span> obj<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试-bff</title>
      <link href="2022/12/01/bff/"/>
      <url>2022/12/01/bff/</url>
      
        <content type="html"><![CDATA[<h3 id="bff-作用"><a href="#bff-作用" class="headerlink" title="bff 作用"></a>bff 作用</h3><p>业务遇到的问题：PC 端移植至移动端，不同端展示内容不同；产品形态，业务属于哪个行业（西红柿在买菜和优选），面向用户群体等；面向 C 端用户带来的功能频繁迭代问题。</p><p>解决问题：服务端需要对不同端进行适配和裁剪问题。即针对多端差异进行适配。</p><p>缺点：<br>BFF 引入“解决”服务端单一稳定与端的差异灵活诉求之间的矛盾，但它不是解决，而是转移到了 BFF 与前端之间。<br>业务支撑效率：场景越来越多，API 爆炸性增长，系统能力难以支撑业务场景规模化拓展<br>系统复杂度高：核心功能持续迭代，内部逻辑充斥 if…else，系统难以维护</p><h3 id="GraphQL-特点"><a href="#GraphQL-特点" class="headerlink" title="GraphQL 特点"></a>GraphQL 特点</h3><p>合并多次请求<br>自由定制数据（精确查询想要的字段）</p><p>新手容易造成N+1查询的问题<br>针对批量查询的性能优化，可以使用DataLoader 。</p><p>不支持部分渲染<br>用rxjs的Observable 来做部分成功的数据渲染</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> bff </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试-vue</title>
      <link href="2022/11/30/vue/"/>
      <url>2022/11/30/vue/</url>
      
        <content type="html"><![CDATA[<h4 id="vue-的双向绑定"><a href="#vue-的双向绑定" class="headerlink" title="vue 的双向绑定"></a>vue 的双向绑定</h4><p>vue2.x 中通过发布者-订阅者设计模式的方式实现，通过get和set方法，通过Object.defineProperty() 实现数据劫持<br>有三个参数，对象，对象的属性，以及描述符对象<br>描述符对象： 数据属性：</p><ul><li>writable 可读写</li><li>enumerable 可迭代，表示是否可用for in循环</li><li>configurable 是否可删除</li><li>value 值</li></ul><p>访问器属性</p><ul><li>get</li><li>set</li></ul><p>同时需要遍历所有属性进行双向绑定</p><p>缺点：对于新增的属性无法监听，需要通过 vm.$set方法新增属性；</p><p>vue3 中通过proxy的api 来实现监听<br>proxy有两个参数<br>target:要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）<br>handler:一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。</p><h4 id="vue的生命周期"><a href="#vue的生命周期" class="headerlink" title="vue的生命周期"></a>vue的生命周期</h4><p>vue2.x</p><p>beforeCreate<br>created<br>beforeMount<br>mounted<br>beforeUpdate<br>updated<br>beforeDestory<br>destoryed</p><p>加载渲染过程<br>父beforeCreate -&gt; 父created -&gt; 父beforeMount-&gt; 子beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt; 子mounted -&gt; 父mounted</p><p>子组件更新过程<br>父beforeUpdate -&gt; 子beforeUpdate -&gt; 子updated -&gt; 父updated</p><p>父组件更新过程<br>父beforeUpdate -&gt; 父updated</p><p>销毁过程<br>父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed</p><p>vue3<br>setup<br>onBeforeMount<br>onMounted<br>onBeforeUpdated<br>onUpdated<br>onBeforeUnmount<br>onUnmounted</p><h4 id="vuex-和pinia"><a href="#vuex-和pinia" class="headerlink" title="vuex 和pinia"></a>vuex 和pinia</h4><p>vuex分为State、Getter、Mutation、Action、Module<br>dispatch方法操作-&gt;action-&gt;commit方法-&gt;mutation<br>State是状态，mapState通常用来解决一个组件需要获取多个状态时的辅助函数；<br>Getter state对象读取方法，用来计算state然后生成新的数据，相当于对于部分state重新封装了一层<br>Mutation对state进行改变的唯一方法，其中Mutation必须是同步的<br>Action是通过触发Mutation从而改变state，可以包含任意异步操作，其中通过store.dispatch进行触发<br>Module可以说是对store进行分割，每一个module拥有自己的state，mutation，action，getter等。命名空间使得模块的封装和复用更加方便<br>插件使用使得vuex扩展性更好，表单处理的双向绑定需要绑定事件或者通过计算属性的setter进行双向绑定</p><p>缺点：</p><ol><li>TS支持不良好</li><li>不能同时支持Composition API和Option API（vuex5 之后支持）</li></ol><p>pinia</p><ol><li>去掉了容易混淆的mutation和action概念，只保留了action，action中的函数可以是同步的也可以是异步的，并且可以直接调用action中的方法，不再需要commit、dispatch等方法，语法更简洁；</li><li>无需创建自定义复杂包装器来支持 TypeScript，所有内容都是类型化的，并且 API 的设计方式尽可能地利用了 TS 的类型推断；</li><li>不再有 modules 的嵌套结构。 Pinia 通过设计提供平面结构，同时仍然支持 Store 之间的交叉组合方式；</li><li>更加轻便 Pinia 大小约1kb</li></ol><h4 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h4><p>在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。 nextTick主要使用了宏任务和微任务。 根据执行环境分别尝试采用Promise、MutationObserver、setImmediate，如果以上都不行则采用setTimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p><ol><li>nextTick是Vue提供的一个全局API,是在下次DOM更新循环结束之后执行延迟回调，在修改数据之后使用$nextTick，则可以在回调中获取更新后的DOM；</li><li>Vue在更新DOM时是异步执行的。只要侦听到数据变化，Vue将开启1个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个watcher被多次触发，只会被推入到队列中-次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作是非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用；</li><li>比如，我在干什么的时候就会使用nextTick，传一个回调函数进去，在里面执行dom操作即可；</li><li>我也有简单了解nextTick实现，它会在callbacks里面加入我们传入的函数，然后用timerFunc异步方式调用它们，首选的异步方式会是Promise。这让我明白了为什么可以在nextTick中看到dom操作结果。</li></ol><h4 id="v-model语法糖和-vue3的v-model变化"><a href="#v-model语法糖和-vue3的v-model变化" class="headerlink" title="v-model语法糖和 vue3的v-model变化"></a>v-model语法糖和 vue3的v-model变化</h4><p>value+input 是v-band和v-on的简洁写法<br>在vue2中 v-model 只能绑定在组件的 value 属性上<br>在2.x 版本中 可以在组件内部定义一个model项，其中prop用来设置v-model中默认的value的别名， event用来设置v-model中默认的input事件的别名<br>一个组件上只能一个v-model</p><p>在vue3中v-bind的.sync修饰符和组件的model选项被删除了<br>支持同一组件同时设置多个 v-model<br>也可以自定义修饰符<br>v-model绑定的不再是value，而是modelValue，接收的方法也不再是input，而是update:modelValue</p><h4 id="vue-的通信方式"><a href="#vue-的通信方式" class="headerlink" title="vue 的通信方式"></a>vue 的通信方式</h4><ul><li>父子：props和$emit</li><li>爷孙：$attrs和$listeners</li><li>eventbus</li><li>provide和 inject</li><li>$parent 和$children</li><li>vuex</li><li>自定义store</li></ul><h4 id="Object-defineProperty-处理Array的push"><a href="#Object-defineProperty-处理Array的push" class="headerlink" title="Object.defineProperty 处理Array的push"></a>Object.defineProperty 处理Array的push</h4><p>需要重新处理push方法</p><pre class=" language-js"><code class="language-js"> <span class="token keyword">const</span> originProto <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype    <span class="token keyword">const</span> arrayProto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>originProto<span class="token punctuation">)</span>    arrayProto<span class="token punctuation">[</span><span class="token string">'push'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        originProto<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'jjjkjkjk'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    data<span class="token punctuation">.</span>__proto__<span class="token operator">=</span> arrayProto    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span><span class="token string">'push'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>        <span class="token keyword">set</span><span class="token punctuation">:</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'kkkkjj'</span><span class="token punctuation">)</span>            <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h4 id="proxy-的写法"><a href="#proxy-的写法" class="headerlink" title="proxy 的写法"></a>proxy 的写法</h4><pre class=" language-js"><code class="language-js"> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span><span class="token punctuation">{</span>        <span class="token keyword">set</span><span class="token punctuation">:</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">,</span>receiver<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">,</span>key<span class="token punctuation">)</span>            target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">=</span>value            <span class="token comment" spellcheck="true">// Reflect.set(target.key,value,receiver)</span>            <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">true</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h4 id="浏览器回退、切换会触发vue的哪些生命周期"><a href="#浏览器回退、切换会触发vue的哪些生命周期" class="headerlink" title="浏览器回退、切换会触发vue的哪些生命周期"></a>浏览器回退、切换会触发vue的哪些生命周期</h4><p>页面刷新时, vue执行的生命周期钩子<br>依次执行当前页面vue组件的beforeCreate, created, beforeMount, mounted, beforUpdate, updated</p><p>页面后退时, vue执行的生命周期钩子<br>假设从b页面后退到a页面<br>依次执行a页面vue组件的beforeCreate, created, beforeMount, 然后是b页面组件的beforeDestroy, destroyed, 最后是执行a页面vue组件的mounted, beforUpdate, updated</p><p>页面前进时, vue执行的生命周期钩子<br>假设从a页面到b页面<br>依次执行b页面vue组件的beforeCreate, created, beforeMount, 然后是a页面组件的beforeDestroy, destroyed, 最后是执行b页面vue组件的mounted, beforUpdate, updated</p><h4 id="vue-中的diff"><a href="#vue-中的diff" class="headerlink" title="vue 中的diff"></a>vue 中的diff</h4><p>在vue1.0 中，通过watch来实现数据和视图的响应式更新，通过观察者模式<br>在vue2.x中，因为还是无法解决响应式数据过多而引起的卡顿的问题，vue2.x 引入了虚拟DOM，对于 Vue 2 来说，组件之间的变化，可以通过响应式来通知更新。组件内部的数据变化，则通过虚拟DOM去更新页面。这样就把响应式的监听器，控制在了组件级别，而虚拟DOM的量级，也控制在了组件的大小。</p><p>如果没有绑定key，对于DOM的顺序发生变化，比如直接插入，会导致后面的数据不变的组件重新渲染</p><h4 id="vue-的keep-alive的作用是什么？怎么实现的？如何刷新的"><a href="#vue-的keep-alive的作用是什么？怎么实现的？如何刷新的" class="headerlink" title="vue 的keep-alive的作用是什么？怎么实现的？如何刷新的?"></a>vue 的keep-alive的作用是什么？怎么实现的？如何刷新的?</h4><p>保持组件不被销毁，组件挂载的数据还存在，所以状态就可以保留。<br>在首次加载被包裹组建时，由keep-alive.js中的render函数可知，vnode.componentInstance的值是undfined，keepAlive的值是true，因为keep-alive组件作为父组件，它的render函数会先于被包裹组件执行；那么只执行到i(vnode,false)，后面的逻辑不执行；<br>再次访问被包裹组件时，vnode.componentInstance的值就是已经缓存的组件实例，那么会执行insert(parentElm, vnode.elm, refElm)逻辑，这样就直接把上一次的DOM插入到父元素中。</p><p>在patch的阶段，最后会执行invokeInsertHook函数，而这个函数就是去调用组件实例（VNode）自身的insert钩子：<br>在insert这个钩子里面，调用了activateChildComponent函数递归地去执行所有子组件的activated钩子函数：<br>相反地，deactivated钩子函数也是一样的原理，在组件实例（VNode）的destroy钩子函数中调用deactivateChildComponent函数。</p><h4 id="render-和template-的区别"><a href="#render-和template-的区别" class="headerlink" title="render 和template 的区别"></a>render 和template 的区别</h4><p>template—-html的方式做渲染<br>render—-js的方式做渲染<br>render（提供）是一种编译方式<br>render里有一个函数h，这个h的作用是将单文件组件进行虚拟DOM的创建，然后再通过render进行解析。<br>h就是createElement()方法：createElement(标签名称,属性配置,children)<br>template也是一种编译方式，但是template最终还是要通过render的方式再次进行编译。</p><p>render渲染方式可以让我们将js发挥到极致，因为render的方式其实是通过createElement()进行虚拟DOM的创建。逻辑性比较强，适合复杂的组件封装。<br>template是类似于html一样的模板来进行组件的封装。<br>render的性能比template的性能好很多<br>render函数优先级大于template</p><h4 id="vue3-生命周期实现原理"><a href="#vue3-生命周期实现原理" class="headerlink" title="vue3 生命周期实现原理"></a>vue3 生命周期实现原理</h4><p>就是把各个生命周期的函数挂载或者叫注册到组件的实例上，然后等到组件运行到某个时刻，再去组件实例上把相应的生命周期的函数取出来执行。<br>各个生命周期的Hooks函数是通过createHook这个函数创建的。createHook是一个闭包函数，通过闭包缓存当前是属于哪个生命周期的Hooks,target表示该生命周期Hooks函数被绑定到哪个组件实例上，默认是当前工作的组件实例。createHook底层又调用了一个injectHook的函数，那么下面我们继续来看看这个injectHook函数。</p><p>Vue3组件实例化之后，通过effect包装一个更新的副作用函数来和响应式数据进行依赖收集。在这个副作用函数里面有两个分支，第一个是组件挂载之前执行的，也就是生命周期函数beforeMount和mount调用的地方，第二个分支是组件挂载之后更新的时候执行的，在这里就是生命周期函数beforeUpdate和updated调用的地方。具体就是在挂载之前，还没生成虚拟DOM之前就执行beforeMount函数，之后则去生成虚拟DOM经过patch之后，组件已经被挂载到页面上了，也就是页面上显示视图了，这个时候就去执行mount函数;在更新的时候，还没获取更新之后的虚拟DOM之前执行beforeUpdate，然后去获取更新之后的虚拟DOM，然后再去patch，更新视图，之后就执行updated。需要注意的是beforeMount和beforeUpdate是同步执行的，都是通过invokeArrayFns来调用的</p><p>Vue的Hooks设计是从React的Hooks那里借鉴过来的，React的Hooks的本质就是把状态变量、副作用函数存到函数组件的fiber对象上，等到将来状态变量发生改变的时候，相关的函数组件fiber就重新进行更新。Vue3这边的实现原理也类似，通过上面的生命周期的Hooks实现原理，我们可以知道Vue3的生命周期的Hooks是绑定到具体的组件实例上，而状态变量，则因为Vue的变量是响应式的，状态变量会通过effect和具体的组件更新函数进行依赖收集，然后进行绑定，将来状态变量发生改变的时候，相应的组件更新函数会重新进入调度器的任务队列进行调度执行。</p><p>所以Hooks的本质就是让那些状态变量或生命周期函数和组件绑定起来，组件运行到相应时刻执行相应绑定的生命周期函数，那些绑定的变量发生改变的时候，相应的组件也重新进行更新。</p><h4 id="组件设计原则"><a href="#组件设计原则" class="headerlink" title="组件设计原则"></a>组件设计原则</h4><p>单一职责： 一个组件负责完成一个职责/功能<br>保持简单：不要过度优化，从而牺牲了代码可读性和可维护性<br>不要重复：做好代码的复用性<br>控制反转：子组件的创建与管理交给外层容器组件来控制<br>关注点分离：如果一个问题能分解为独立且较小的问题，就是相对较易解决的。实现关注点分离的方式有两种：一种是标准化，另一种就是抽象与包装<br>松耦合：组件的核心思想是它们是可复用的,为此要求它们必须具有功能性和完整性。“耦合”是指实体彼此依赖的术语。松散耦合的实体应该能够独立运行，而不依赖于其他模块。就前端组件而言，耦合的主要部分是组件的功能依赖于其父级及其传递的 props 的多少，以及内部使用的子组件（当然还有引用的部分，如第三方模块或用户脚本）。在设计组件时，你应该考虑到更加通用的使用场景，而不仅仅只是为了满足最开始某个特定场景的需求。虽然一般来说组件最初都是出于特定目的进行设计，但没关系，如果在设计它们站在更高的角度去看待，那么很多组件将具有更好的适用性。</p><h4 id="vue-router3-和vue-router4的区别"><a href="#vue-router3-和vue-router4的区别" class="headerlink" title="vue router3 和vue router4的区别"></a>vue router3 和vue router4的区别</h4><h4 id="app-use-操作了什么？"><a href="#app-use-操作了什么？" class="headerlink" title="app.use 操作了什么？"></a>app.use 操作了什么？</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试-React</title>
      <link href="2022/11/30/react/"/>
      <url>2022/11/30/react/</url>
      
        <content type="html"><![CDATA[<h4 id="react生命周期"><a href="#react生命周期" class="headerlink" title="react生命周期"></a>react生命周期</h4><ul><li>constructor（并不属于生命周期 - 初始化 state，初始化参数）</li><li>static getDerivedStateFormPorps - 组件 props 变化时更新 state</li><li>componentDidMount - 网络请求，添加监听事件等</li><li>shouldComponentUpdate - 通过判断新传入的 props，优化性能，避免重复渲染</li><li>static getSnapshopBeforeUpdate - 很少用，组件更新之前捕获一些信息（例如滚动位置）</li><li>componentDidUpdate - 组件更新完成后的一些操作</li><li>componentWillUnmount - 卸载监听事件，卸载计时器等</li><li>componentDidUnmount()</li></ul><h4 id="react-Fiber"><a href="#react-Fiber" class="headerlink" title="react Fiber"></a>react Fiber</h4><p>React 的核心流程可以分为两个部分:</p><p>reconciliation (调度算法，也可称为 render):</p><p>更新 state 与 props；<br>调用生命周期钩子；<br>生成 virtual dom；</p><p>这里应该称为 Fiber Tree 更为符合；</p><p>通过新旧 vdom 进行 diff 算法，获取 vdom change；<br>确定是否需要重新渲染</p><ul><li>Render 阶段就是根据每个组件中的状态构建出一个新的 UI Tree，也叫WorkInProgress Tree，并为每一个结点对应的操作打上 EffectTag，即更新、删除、新增。全部构建完成后就进入下一阶段。</li></ul><p>commit:</p><ul><li>Commit 阶段就是将构建好的 WIP Tree 反应到浏览器中，即 React 为我们自动进行相应的 dom 操作，保持 UI 一致性。<br>如需要，则操作 dom 节点更新；</li></ul><p>要了解 Fiber，我们首先来看为什么需要它？</p><p>问题: 随着应用变得越来越庞大，整个更新渲染的过程开始变得吃力，大量的组件渲染会导致主进程长时间被占用，导致一些动画或高频操作出现卡顿和掉帧的情况。而关键点，便是 同步阻塞。在之前的调度算法中，React 需要实例化每个类组件，生成一颗组件树，使用 同步递归 的方式进行遍历渲染，而这个过程最大的问题就是无法 暂停和恢复。</p><p>解决方案: 解决同步阻塞的方法，通常有两种: 异步 与 任务分割。而 React Fiber 便是为了实现任务分割而诞生的。</p><p>简述:</p><p>在 React V16 将调度算法进行了重构， 将之前的 stack reconciler 重构成新版的 fiber reconciler，变成了具有链表和指针的 单链表树遍历算法。通过指针映射，每个单元都记录着遍历当下的上一步与下一步，从而使遍历变得可以被暂停和重启。<br>这里我理解为是一种 任务分割调度算法，主要是 将原先同步更新渲染的任务分割成一个个独立的 小任务单位，根据不同的优先级，将小任务分散到浏览器的空闲时间执行，充分利用主进程的事件循环机制。</p><p>核心:</p><p>Fiber 这里可以具象为一个 数据结构:</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name">Fiber</span> <span class="token punctuation">{</span>    <span class="token keyword">constructor</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>instance <span class="token operator">=</span> instance        <span class="token comment" spellcheck="true">// 指向第一个 child 节点</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>child <span class="token operator">=</span> child        <span class="token comment" spellcheck="true">// 指向父节点</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">return</span> <span class="token operator">=</span> parent        <span class="token comment" spellcheck="true">// 指向第一个兄弟节点</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>sibling <span class="token operator">=</span> previous    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>链表树遍历算法: 通过 节点保存与映射，便能够随时地进行 停止和重启，这样便能达到实现任务分割的基本前提；</p><p>1、首先通过不断遍历子节点，到树末尾；<br>2、开始通过 sibling 遍历兄弟节点；<br>3、return 返回父节点，继续执行2；<br>4、直到 root 节点后，跳出遍历；</p><p>任务分割，React 中的渲染更新可以分成两个阶段:</p><p>reconciliation 阶段: vdom 的数据对比，是个适合拆分的阶段，比如对比一部分树后，先暂停执行个动画调用，待完成后再回来继续比对。<br>Commit 阶段: 将 change list 更新到 dom 上，并不适合拆分，才能保持数据与 UI 的同步。否则可能由于阻塞 UI 更新，而导致数据更新和 UI 不一致的情况。</p><p>分散执行: 任务分割后，就可以把小任务单元分散到浏览器的空闲期间去排队执行，而实现的关键是两个新API: <code>requestIdleCallback</code> 与 <code>requestAnimationFrame</code></p><p>低优先级的任务交给<code>requestIdleCallback</code>处理，这是个浏览器提供的事件循环空闲期的回调函数，需要 pollyfill，而且拥有 deadline 参数，限制执行事件，以继续切分任务；<br>高优先级的任务交给<code>requestAnimationFrame</code>处理；</p><pre class=" language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// 类似于这样的方式</span><span class="token function">requestIdleCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span>deadline<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 当有空闲时间时，我们执行一个组件渲染；</span>    <span class="token comment" spellcheck="true">// 把任务塞到一个个碎片时间中去；</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>deadline<span class="token punctuation">.</span><span class="token function">timeRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> deadline<span class="token punctuation">.</span>didTimeout<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nextComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        nextComponent <span class="token operator">=</span> <span class="token function">performWork</span><span class="token punctuation">(</span>nextComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>优先级策略: 文本框输入 &gt; 本次调度结束需完成的任务 &gt; 动画过渡 &gt; 交互反馈 &gt; 数据更新 &gt; 不会显示但以防将来会显示的任务</p><p>Fiber 其实可以算是一种编程思想，在其它语言中也有许多应用(Ruby Fiber)。核心思想是 任务拆分和协同，主动把执行权交给主线程，使主线程有时间空挡处理其他高优先级任务。</p><h4 id="react-优化"><a href="#react-优化" class="headerlink" title="react 优化"></a>react 优化</h4><p>pureComponent 浅比较<br>shouldComponentUpdate 深比较</p><p>hooks优化<br>React.memo<br>react.<br>useMemo useMemo 是一种缓存机制提速，当它的依赖未发生改变时，就不会触发重新计算。<br>useCallback  针对传入子组件的为函数，进行优化使用，因为函数式组件每次发生渲染，都会从头执行，两次的callBack函数发生了改变，导致子组件渲染。useCallback 针对函数进行记忆，从而避免触发渲染。</p><h4 id="setState-是异步还是同步的？"><a href="#setState-是异步还是同步的？" class="headerlink" title="setState 是异步还是同步的？"></a>setState 是异步还是同步的？</h4><p>在React管理的事件回调和生命周期中，是异步的，其他是同步的，因为来做批量更新，减少渲染。<br>但在函数式组件中不存在这个问题。因为函数组件中生成的函数是通过闭包引用了 state，而不是通过 this.state 的方式引用 state，所以函数组件的处理函数中 state 一定是旧值，不可能是新值。可以说函数组件已经将这个问题屏蔽掉了。</p><h4 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h4><p>state<br>Action<br>reducer 处理state</p><h4 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h4><p>纯函数<br>函数复合<br>数据不可变性<br>函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单元函数，组合调用操作数据流；<br>它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部 / 副作用；</p><h4 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h4><p>react 中的 HOC 高阶组件，就是一个函数，接受一个组件作为参数，返回一个新的组件<br>例如一个loading的高阶组件</p><pre class=" language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// high order component</span><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">'axios'</span><span class="token keyword">interface</span> <span class="token class-name">ILoaderState</span> <span class="token punctuation">{</span>  data<span class="token punctuation">:</span> <span class="token keyword">any</span><span class="token punctuation">,</span>  isLoading<span class="token punctuation">:</span> <span class="token keyword">boolean</span><span class="token punctuation">}</span><span class="token keyword">interface</span> <span class="token class-name">ILoaderProps</span> <span class="token punctuation">{</span>  data<span class="token punctuation">:</span> <span class="token keyword">any</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">const</span> withLoader <span class="token operator">=</span> <span class="token operator">&lt;</span>P <span class="token keyword">extends</span> <span class="token class-name">ILoaderState</span><span class="token operator">></span><span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">:</span> React<span class="token punctuation">.</span>ComponentType<span class="token operator">&lt;</span>P<span class="token operator">></span><span class="token punctuation">,</span> url<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">LoaderComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token operator">&lt;</span>Partial<span class="token operator">&lt;</span>ILoaderProps<span class="token operator">></span><span class="token punctuation">,</span> ILoaderState<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">:</span> <span class="token keyword">any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>        data<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>        isLoading<span class="token punctuation">:</span> <span class="token keyword">false</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        isLoading<span class="token punctuation">:</span> <span class="token keyword">true</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>      axios<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>          data<span class="token punctuation">:</span> result<span class="token punctuation">.</span>data<span class="token punctuation">,</span>          isLoading<span class="token punctuation">:</span> <span class="token keyword">false</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> <span class="token punctuation">{</span> data<span class="token punctuation">,</span> isLoading <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state      <span class="token keyword">return</span> <span class="token punctuation">(</span>        <span class="token operator">&lt;</span><span class="token operator">></span>          <span class="token punctuation">{</span> <span class="token punctuation">(</span>isLoading <span class="token operator">||</span> <span class="token operator">!</span>data<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">&lt;</span>p<span class="token operator">></span>data is loading<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span> <span class="token punctuation">:</span>            <span class="token operator">&lt;</span>WrappedComponent <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props as P<span class="token punctuation">}</span> data<span class="token operator">=</span><span class="token punctuation">{</span>data<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>          <span class="token punctuation">}</span>        <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">></span>      <span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">default</span> withLoader</code></pre><p>使用实例：</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name">IShowResult</span><span class="token punctuation">{</span>    message<span class="token punctuation">:</span><span class="token keyword">string</span><span class="token punctuation">,</span>    status<span class="token punctuation">:</span><span class="token keyword">string</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//定义一个组件</span><span class="token keyword">const</span> DogShow<span class="token punctuation">:</span>React<span class="token punctuation">.</span>FC<span class="token operator">&lt;</span><span class="token punctuation">{</span>data<span class="token punctuation">:</span>IShowResult<span class="token punctuation">}</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>data<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>        <span class="token operator">&lt;</span><span class="token operator">></span>            <span class="token operator">&lt;</span>h2<span class="token operator">></span>show<span class="token punctuation">:</span><span class="token punctuation">{</span>data<span class="token punctuation">.</span>status<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>            <span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token punctuation">{</span>data<span class="token punctuation">.</span>message<span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">></span>    <span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">const</span> App<span class="token punctuation">:</span>React<span class="token punctuation">.</span>FC<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//高阶组件，将一个组件用参数形式传入，然后经过包裹后返回一个新的组件，达到公用包裹组件的功能</span>    <span class="token keyword">const</span> WrappedDogShow <span class="token operator">=</span> <span class="token function">withLoader</span><span class="token punctuation">(</span>DogShow<span class="token punctuation">,</span><span class="token string">'https://dog.ceo/api/breeds/image/random'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>        <span class="token operator">&lt;</span>WrappedDogShow<span class="token operator">/</span><span class="token operator">></span>    <span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h4 id="React-hooks"><a href="#React-hooks" class="headerlink" title="React hooks"></a>React hooks</h4><p>其实，React hooks 的问题也有很多，比如：</p><ul><li>Hook 是一个链表的结构，在循环，条件或嵌套函数中调用 Hook，会引发一些问题。</li><li>useEffect 的依赖容易造成心智负担，所有人阅读这段代码，都需要完整的阅读完这些依赖触发的地方</li><li>由于闭包的原因，useEffect 等内部捕获的，都是过时的变量。</li></ul><p>对 React Hooks 而言，调用必须放在最前面，而且不能被包含在条件语句里，这是因为 React Hooks 采用下标方式寻找状态，一旦位置不对或者 Hooks 放在了条件中，就无法正确找到对应位置的值。<br>所有 Hooks 都在渲染闭包中执行，每次重渲染都有一定性能压力，而且频繁的渲染会带来许多闭包，虽然可以依赖 GC 机制回收，但会给 GC 带来不小的压力。<br>需要用useCallback、useMemo 来做性能优化，两者的区别在于一个存储函数的本身(useCallback) 一个存储函数返回的值（useMemo）</p><p>useLayoutEffect<br>跟 useEffect 使用差不多，通过同步执行状态更新可解决一些特性场景下的页面闪烁问题<br>useLayoutEffect 会阻塞渲染，请谨慎使用</p><ul><li>DOM更新同步钩子。用法与useEffect类似，只是区别于执行时间点的不同。</li><li>useEffect属于异步执行，并不会等待 DOM 真正渲染后执行，而useLayoutEffect则会真正渲染后才触发；</li><li>可以获取更新后的 state；</li></ul><p>useReducer</p><p>接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法</p><ul><li>reducer 本质是一个纯函数，每次只返回一个值，那个值可以是数字，字符串，对象，数组或者对象，但是它总是一个值</li><li>React 会确保 dispatch 函数的标识是稳定的，并且不会在组件重新渲染时改变</li><li>useReducer 还能给那些会触发深更新的组件做性能优化，因为可以向子组件传递 dispatch 而不是回调函数</li><li>reducer 更适合去处理比较复杂的 state，来维护组件的状态</li></ul><p>类似于 Redux 思想的实现，但其并不足以替代 Redux，可以理解成一个组件内部的 redux:</p><ul><li>并不是持久化存储，会随着组件被销毁而销毁；</li><li>属于组件内部，各个组件是相互隔离的，单纯用它并无法共享数据；</li><li>配合useContext的全局性，可以完成一个轻量级的 Redux；(easy-peasy)</li></ul><p>useContext</p><ul><li>接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值</li><li>useContext 的参数必须是 context 对象本身</li><li>当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定</li><li>调用了 useContext 的组件总会在 context 值变化时重新渲染</li></ul><h4 id="React-diff"><a href="#React-diff" class="headerlink" title="React diff"></a>React diff</h4><p>要求：1、跨层级节点移动操作较少；2、相同类的两个组件会生成相似的树形结构；3、同一层的一组节点，通过唯一的key进行区分<br>树差异（Tree Diff）、组件差异（Component Diff）以及元素差异（Element Diff）<br>树差异 只比较同一层级，如果同一层级不同，直接先销毁再创建<br>组件差异 同一类型的组件，比较子树， 如果不是，直接替换<br>元素差异，直接通过唯一的key来辨别</p><h4 id="umi-amp-dva"><a href="#umi-amp-dva" class="headerlink" title="umi &amp; dva"></a>umi &amp; dva</h4><p>umi 企业级的前端开发框架，Umi 以路由为基础的，同时支持配置式路由和约定式路由，保证路由的功能完备，并以此进行功能扩展。然后配以生命周期完善的插件体系，覆盖从源码到构建产物的每个生命周期，支持各种功能扩展和业务需求。</p><p>特性：插件化、MFSU<br><img src="/images/umi.png"></p><p>dva 是基于redux的前端数据流方案<br>特性：</p><ul><li>易学易用</li></ul><p>特点：<br>modal、namespace、state、effect、reducer、subscription</p><ul><li>effect:以 key/value 格式定义 effect。用于处理异步操作和业务逻辑，不直接修改 state</li><li>reducer:以 key/value 格式定义 reducer。用于处理同步操作，唯一可以修改 state 的地方，由 action 触发</li><li>subscription:以 key/value 格式定义 subscription。subscription 是订阅，用于订阅一个数据源，然后根据需要 dispatch 相应的 action。在 app.start() 时被执行，数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写实现promise</title>
      <link href="2022/11/29/shou-xie-shi-xian-promise/"/>
      <url>2022/11/29/shou-xie-shi-xian-promise/</url>
      
        <content type="html"><![CDATA[<pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> PENDING <span class="token operator">=</span> <span class="token string">"pending"</span><span class="token punctuation">;</span><span class="token keyword">const</span> FULFILLED <span class="token operator">=</span> <span class="token string">"fulfilled"</span><span class="token punctuation">;</span><span class="token keyword">const</span> REJECTED <span class="token operator">=</span> <span class="token string">"rejected"</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">myPromise</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token function">executor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>resolve<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>reject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  status <span class="token operator">=</span> PENDING<span class="token punctuation">;</span>  value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  reason <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  onFulfilledCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 存储失败回调函数</span>  onRejectedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  resolve <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> PENDING<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> FULFILLED<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>onFulfilledCallbacks<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>onFulfilledCallbacks<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  reject <span class="token operator">=</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> PENDING<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> REJECTED<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>reason <span class="token operator">=</span> reason<span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token function">then</span><span class="token punctuation">(</span>onFulFilled<span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> realOnFulFilled <span class="token operator">=</span>      <span class="token keyword">typeof</span> onFulFilled <span class="token operator">===</span> <span class="token string">"function"</span> <span class="token operator">?</span> onFulFilled <span class="token punctuation">:</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> value<span class="token punctuation">;</span>    <span class="token keyword">const</span> realOnRejected <span class="token operator">=</span>      <span class="token keyword">typeof</span> onRejected <span class="token operator">===</span> <span class="token string">"function"</span>        <span class="token operator">?</span> onRejected        <span class="token punctuation">:</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> reason<span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> promise2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">myPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> fulfilledMicroTask <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">queueMicrotask</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">realOnFulFilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token keyword">const</span> rejectMicroTask <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">queueMicrotask</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">realOnRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> FULFILLED<span class="token punctuation">:</span>          <span class="token function">fulfilledMicroTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> REJECTED<span class="token punctuation">:</span>          <span class="token function">rejectMicroTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> PENDING<span class="token punctuation">:</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>onFulfilledCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fulfilledMicroTask<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>rejectMicroTask<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token punctuation">:</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> promise2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">static</span> <span class="token function">resolve</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>param <span class="token keyword">instanceof</span> <span class="token class-name">myPromise</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> param<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">myPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token function">resolve</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">static</span> <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">myPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  resolvePromise <span class="token operator">=</span> <span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>promise2 <span class="token operator">===</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">"链式循环"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token keyword">instanceof</span> <span class="token class-name">myPromise</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      x<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  promiseAll <span class="token operator">=</span> <span class="token punctuation">(</span>promises<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">myPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isArray</span><span class="token punctuation">(</span>promises<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">"必须是数组"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">let</span> resolveCounter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">let</span> promiseNum <span class="token operator">=</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">;</span>      <span class="token keyword">let</span> resolvedValue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> promiseNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>          Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>promises<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>            <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>              resolveCounter<span class="token operator">++</span><span class="token punctuation">;</span>              resolvedValue<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>resolveCounter <span class="token operator">===</span> promiseNum<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token function">resolve</span><span class="token punctuation">(</span>resolvedValue<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token keyword">function</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>          <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  promiseRace <span class="token operator">=</span> <span class="token punctuation">(</span>promises<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isArray</span><span class="token punctuation">(</span>promises<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"必须是数组"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">myPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            myPromise<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span>                    <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试-JS</title>
      <link href="2022/11/29/js/"/>
      <url>2022/11/29/js/</url>
      
        <content type="html"><![CDATA[<h4 id="1-js-垃圾回收机制"><a href="#1-js-垃圾回收机制" class="headerlink" title="1.  js 垃圾回收机制"></a>1.  js 垃圾回收机制</h4><p>答:js 的内存泄漏可以通过三个:闭包、全局变量、对象属性循环使用、DOM 节点删除时未解绑事件、计时器引用未及时删除</p><p>垃圾回收机制:手动回收和自动回收、自动回收分为对调用栈的数据回收、对调用堆的数据回收、<br>调用栈的数据回收基于 ESP（记录当前执行状态的指针）来销毁保存在栈的执行上下文；<br>调用堆的数据回收:v8 把堆分为<code>新生代</code>和<code>老生代</code>,新生代存放的是生存时间短的对象，老生代存放生存时间长的对象<br>执行流程:</p><ol><li>标记活动对象和非活动对象</li><li>回收非活动对象占据的内存</li><li>内存整理。整理内存碎片</li></ol><p>新生代的垃圾回收，将新生代空间内存分为两个区域，一半是对象区域，一半是空闲区域，当对象区域写满后，需要执行一次垃圾清理操作。在垃圾回收过程中，对使用对象进行标记。在垃圾清理阶段，把存活的对象复制到空闲区域，并有序排列这些对象。同时经过两次垃圾回收依然还存活的对象，将放置在老生区中</p><p>老生代的垃圾回收，使用标记清除。通过遍历调用栈，能够到达的元素称为活动对象，没有对象的可以判断为垃圾数据，进行标记。之后进行垃圾清除，这个是直接删除标记数据。清除之后，产生大量不连续的内存碎片，于是产生了标记-整理的过程。对所有的可以活动的对象向一端移动，清理边界以外的内存，从而占据连续的内存块。</p><h4 id="2-模块化"><a href="#2-模块化" class="headerlink" title="2. 模块化"></a>2. 模块化</h4><p>AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块 CMD推崇就近依赖，只有在用到某个模块的时候再去require<br>CommonJS通过同步的方式加载模块，其输出的模块是一个拷贝对象，所以修改原的模块不会对被引入的模块内部产生影响，且模块在代码运行的时候加载<br>es6模块是在代码编译时输出接口即编译时加载，es6是通过命令来指定导出和加载，且导出的是模块中的只读引用，如果原始模块中的值被改变了，那么加载的值也会随之改变，所以是动态引用</p><h5 id="CommonJS-与-ESM-的区别"><a href="#CommonJS-与-ESM-的区别" class="headerlink" title="CommonJS 与 ESM 的区别"></a>CommonJS 与 ESM 的区别</h5><p>实际开发中，经常会将 ESM 和 CommonJS 混用，因此有必要了解它们之间的区别。</p><h6 id="动态与静态"><a href="#动态与静态" class="headerlink" title="动态与静态"></a>动态与静态</h6><p>CommonJS中对模块依赖的解决是“动态的”，而ESM是静态的。所谓动态，是指模块依赖关系的建立发生在代码运行阶段；而静态是指模块依赖关系的建立发生在代码编译阶段。</p><p>CommonJS在运行时才会加载模块，确定模块依赖关系。因此可以在任意地方导入模块，甚至可以通过if语句来判断是否加载某个模块。</p><p>ESM的导入、导出语句都是声明式的，导入和导出语句必须位于模块的顶层作用域。它是一种静态的模块结构，在编译阶段就可以分析出模块的依赖关系。相比CommonJS，其具有以下优势：</p><p>死代码检测和排除。可以减小打包资源体积。</p><p>模块变量类型检查。</p><p>编译器优化。CommonJS中不论采用那种方式，本质上导入的都是一个对象。而ESM中，可以直接导入变量，减少了引用层级，程序效率更高。</p><h6 id="值拷贝和动态映射"><a href="#值拷贝和动态映射" class="headerlink" title="值拷贝和动态映射"></a>值拷贝和动态映射</h6><p>导入一个模块时，CommonJS中获取的是一份值的拷贝，而在ESM中，获取的是值的动态映射，并且这个映射是只读的。</p><p>浏览器中 ES6 的模块化支持、node 采用 commonJS 的模块化支持</p><ul><li>es6 <code>import/export</code></li><li>commonjs <code>require/module.exports/exports</code></li><li>amd <code>require/defined</code></li></ul><p><code>require</code> 与<code>import</code>的区别:</p><ul><li><code>require</code>支持动态导入,<code>import</code>不支持</li></ul><h4 id="3-原型和原型链"><a href="#3-原型和原型链" class="headerlink" title="3. 原型和原型链"></a>3. 原型和原型链</h4><p>原型关系：</p><ul><li>每个 class 都有显示原型 prototype</li><li>每个实例都有隐式原型 _ proto_</li><li>实例的* proto*指向对应 class 的 prototype</li></ul><p>原型: 在 JS 中，每当定义一个对象（函数也是对象）时，对象中都会包含一些预定义的属性。其中每个函数对象都有一个 prototype 属性，这个属性指向函数的原型对象。</p><p>原型链：函数的原型链对象 constructor 默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针<strong>proto</strong>,该指针是指向上一层的原型对象，而上一层的原型对象的结构依然类似。因此可以利用<strong>proto</strong>一直指向 Object 的原型对象上，而 Object 原型对象用 Object.prototype.** proto** = null 表示原型链顶端。如此形成了 js 的原型链继承。同时所有的 js 对象都有 Object 的基本防范</p><p>特点: JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p><h5 id="ES5与ES6继承的区别"><a href="#ES5与ES6继承的区别" class="headerlink" title="ES5与ES6继承的区别"></a>ES5与ES6继承的区别</h5><p>ES5的继承是先创建子类的实例, 然后再创建父类的方法添加到this上.</p><p>ES6的继承是先创建父类的实例对象this(必须先调用super方法), 再调用子类的构造函数修改this.</p><p>通过关键字class定义类, extends关键字实现继承. 子类必须在constructor方法中调用super方法否则创建实例报错. 因为子类没有this对象, 而是使用父类的this, 然后对其进行加工</p><p>super关键字指代父类的this, 在子类的构造函数中, 必须先调用super, 然后才能使用this</p><h4 id="执行上下文和闭包"><a href="#执行上下文和闭包" class="headerlink" title="执行上下文和闭包"></a>执行上下文和闭包</h4><p>执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。 执行上下文的生命周期包括三个阶段：创建阶段→执行阶段→回收阶段，我们重点介绍创建阶段。</p><p>闭包就是能够读取其他函数内部变量的函数。在 js 中只有函数内部的子函数才能读取局部变量。所以可以简单的理解为：定义在内部函数的函数。</p><p>用途主要有两个：</p><p>1）使用闭包可以访问函数中的变量。</p><p>2）让变量值始终保持在内存中。</p><h4 id="4-介绍节流防抖原理、区别以及应用"><a href="#4-介绍节流防抖原理、区别以及应用" class="headerlink" title="4.介绍节流防抖原理、区别以及应用"></a>4.介绍节流防抖原理、区别以及应用</h4><p>节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次。</p><p>防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如 1 秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待 1 秒，直到能最终执行！</p><p>使用场景：<br>节流：滚动加载更多、搜索框搜的索联想功能、高频点击、表单重复提交……<br>防抖：搜索框搜索输入，并在输入完以后自动搜索、手机号，邮箱验证输入检测、窗口大小 resize 变化后，再重新渲染。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 节流</span><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> lastTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> nowTime <span class="token operator">=</span> Data<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nowTime <span class="token operator">-</span> lastTime <span class="token operator">></span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>      fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      lastTime <span class="token operator">=</span> nowTime<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//  防抖</span><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">clearTimeOut</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>    timer <span class="token operator">=</span> <span class="token function">setTimeOut</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="5-函数式编程"><a href="#5-函数式编程" class="headerlink" title="5. 函数式编程"></a>5. 函数式编程</h4><ul><li>纯函数(确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维护；</li></ul><p>优势:</p><ul><li>完全独立，与外部解耦；</li><li>高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳定；</li><li>可测试性极强；</li></ul><p>条件:</p><ul><li>不修改参数；</li><li>不依赖、不修改任何函数外部的数据；</li><li>完全可控，参数一样，返回值一定一样: 例如函数不能包含 new Date()或者 Math.rando()等这种不可控因素；</li><li>引用透明；</li></ul><h4 id="6-call、-apply-和-bind-的区别"><a href="#6-call、-apply-和-bind-的区别" class="headerlink" title="6. call、 apply 和 bind 的区别"></a>6. call、 apply 和 bind 的区别</h4><p>全局环境下this指向window，箭头函数的this永远指向创建当前词法环境时的this，作为构造函数时，函数中的this指向实例对象<br>执行上下文在被执行的时候才会创建，创建执行上下文时才会绑定this，所以this的指向永远是在执行时确定</p><p>call( this,a,b,c ) 在第一个参数之后的，后续所有参数就是传入该函数的值。apply( this,[a,b,c] ) 只有两个参数，第一个是对象，第二个是数组，这个数组就是该函数的参数。</p><p>bind 除了返回是函数以外，它的参数和 call 一样。</p><p>共同之处：都可以用来代替另一个对象调用一个方法，将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 实现bind</span>Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">mybind</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> fun  <span class="token operator">=</span> <span class="token keyword">this</span>    <span class="token keyword">function</span> <span class="token function">bound</span><span class="token punctuation">(</span><span class="token operator">...</span>args2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> self <span class="token operator">=</span> <span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">bound</span><span class="token operator">?</span><span class="token keyword">this</span><span class="token punctuation">:</span>context        <span class="token keyword">return</span> fun<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>args<span class="token punctuation">.</span><span class="token function">contact</span><span class="token punctuation">(</span>args2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    bound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>fun<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>    <span class="token keyword">return</span> bound<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 实现call</span>Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">mycall</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    context<span class="token punctuation">.</span>fun <span class="token operator">=</span> <span class="token keyword">this</span>    <span class="token keyword">return</span> context<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 实现apply</span>Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myapply <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    context<span class="token punctuation">.</span>fun <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> context<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h4 id="7-reduce-参数"><a href="#7-reduce-参数" class="headerlink" title="7. reduce 参数"></a>7. reduce 参数</h4><p>arr.reduce(callback,[initialValue])</p><p>callback （执行数组中每个值的函数，包含四个参数）</p><p>1、previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））<br>2、currentValue （数组中当前被处理的元素）<br>3、index （当前元素在数组中的索引）<br>4、array （调用 reduce 的数组）</p><p>initialValue （作为第一次调用 callback 的第一个参数。）</p><p>手写reduce</p><pre class=" language-js"><code class="language-js">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myReduce <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span>initialValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> pre<span class="token punctuation">,</span>index  <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>initalValue <span class="token operator">===</span> undefined<span class="token punctuation">)</span> <span class="token punctuation">{</span>    pre <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    index <span class="token operator">=</span> <span class="token number">1</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    pre <span class="token operator">=</span> initialValue    index <span class="token operator">=</span> <span class="token number">0</span>  <span class="token punctuation">}</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span>index<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    pre <span class="token operator">=</span> fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span>pre<span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> pre<span class="token punctuation">}</span></code></pre><h4 id="8-深拷贝"><a href="#8-深拷贝" class="headerlink" title="8. 深拷贝"></a>8. 深拷贝</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> deepClone<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">function</span> <span class="token function">isObject</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> typeOf data <span class="token operator">===</span><span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> data <span class="token operator">!==</span><span class="token keyword">null</span>    <span class="token punctuation">}</span>    <span class="token keyword">function</span> clone <span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isObject</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> cloneTarget <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>            map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> cloneTarget<span class="token punctuation">)</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                cloneTarget<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">clone</span><span class="token punctuation">(</span>target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> cloneTarget        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> target        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">clone</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h4 id="9-new-关键字做了什么"><a href="#9-new-关键字做了什么" class="headerlink" title="9. new 关键字做了什么"></a>9. new 关键字做了什么</h4><p>做了四件事，1，创建空对象，2，将空对象的<code>__proto__</code>指向构造函数的<code>prototype</code>3，构造函数的 this 作用域赋给新对象，4，返回原始值需要忽略，返回对象需要正常处理</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">_new</span><span class="token punctuation">(</span>constructor<span class="token punctuation">,</span> <span class="token operator">...</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 创建一个空对象</span>  <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 空对象的`__proto__`指向构造函数的`prototype`, 为这个新对象添加属性</span>  obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 构造函数的作用域赋给新对象</span>  <span class="token keyword">var</span> res <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 返回新对象.如果没有显式return语句，则返回this</span>  <span class="token keyword">return</span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">"[object Object]"</span> <span class="token operator">?</span> res <span class="token punctuation">:</span> obj<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="10-判断类型-三种方式"><a href="#10-判断类型-三种方式" class="headerlink" title="10. 判断类型 三种方式"></a>10. 判断类型 三种方式</h4><p>typeOf、  instanceOf、Object.prototype.toString.call()<br>typeOf 不能区分Array和Object<br>instanceOf 不能区分基本类型</p><h4 id="11-手动实现一个-instanceOf"><a href="#11-手动实现一个-instanceOf" class="headerlink" title="11. 手动实现一个 instanceOf"></a>11. 手动实现一个 instanceOf</h4><p>instanceOf 基于原型链</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">isInstanceOf</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> fun<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> fun <span class="token operator">!==</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">"arg2 fun is not a function"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>child <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">false</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>__proto__ <span class="token operator">!==</span> fun<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">isInstanceOf</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>__proto__<span class="token punctuation">,</span> fun<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token keyword">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="12-观察者模式和发布订阅模式"><a href="#12-观察者模式和发布订阅模式" class="headerlink" title="12. 观察者模式和发布订阅模式"></a>12. 观察者模式和发布订阅模式</h4><p>观察者模式是一对多的依赖关系，他表示多个观察者对象同时监听某一个主题对象，当这个主题对象发生变化时，会通知所有观察者，使他们能够自我更新<br>发布-订阅者模式引入了第三方组件，叫做信息中介，它将订阅者和发布者联系起来，当发布者发生变化时，由信息中介通知订阅者，并进行更新。</p><ul><li>观察者模式</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 被观察者</span><span class="token keyword">class</span> <span class="token class-name">Subject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>    <span class="token function">add</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">notiify</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>ob<span class="token operator">=</span><span class="token operator">></span>ob<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 观察者</span><span class="token keyword">class</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">update</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>发布-订阅模式</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">PubSub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>handles<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>    <span class="token function">subscribe</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>handles<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>handles<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>handles<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">publish</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>handles<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>handles<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fn<span class="token operator">=</span><span class="token operator">></span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="13-虚拟-DOM-和真实-DOM-的转换"><a href="#13-虚拟-DOM-和真实-DOM-的转换" class="headerlink" title="13. 虚拟 DOM 和真实 DOM 的转换"></a>13. 虚拟 DOM 和真实 DOM 的转换</h4><p>虚拟DOM缺点：在首次渲染时，多了一层虚拟DOM的计算，影响性能</p><pre class=" language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">VDom</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> data<span class="token punctuation">,</span> value<span class="token punctuation">,</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag <span class="token operator">&amp;&amp;</span> tag<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 节点名</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 属性</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 文本数据</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 节点类型</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">appendChild</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// nodeName：node的名字，如果是element那名字是大写的,其他的名字前面写上#。</span>  <span class="token comment" spellcheck="true">// nodeType：node的类型，一般用数字表示，1表示element(也可以用Node.ELEMENT_NODE来表示)，3表示text(Node.TEXT_NODE)。</span>  <span class="token comment" spellcheck="true">// 如果是element，那么nodeName === tagName</span>  <span class="token comment" spellcheck="true">// 如果是text，那么nodeName = #text， tagName = undefined</span>  <span class="token comment" spellcheck="true">// nodeValue：当前节点的值，对于text, comment节点来说, nodeValue返回该节点的文本内容，对于 attribute 节点来说, 返回该属性的属性值，而对于document和element节点来说，返回null</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">getVnode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> nodeType <span class="token operator">=</span> node<span class="token punctuation">.</span>nodeType<span class="token punctuation">;</span>  <span class="token keyword">let</span> _vnode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>nodeType <span class="token operator">===</span> <span class="token string">"element"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> tag <span class="token operator">=</span> node<span class="token punctuation">.</span>nodeName<span class="token punctuation">;</span>    <span class="token keyword">let</span> attrs <span class="token operator">=</span> node<span class="token punctuation">.</span>attributes<span class="token punctuation">;</span>    <span class="token keyword">let</span> _attrObj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> attrs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      _attrObj<span class="token punctuation">[</span>attrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>nodeName<span class="token punctuation">]</span> <span class="token operator">=</span> attrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>nodeValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    _vnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VDom</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> _attrObj<span class="token punctuation">,</span> undefined<span class="token punctuation">,</span> nodeType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> children <span class="token operator">=</span> node<span class="token punctuation">.</span>childNodes<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      _vnode<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token function">getVNode</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nodeType <span class="token operator">===</span> <span class="token string">"text"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    _vnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VDom</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> nodeName<span class="token punctuation">,</span> undefined<span class="token punctuation">,</span> node<span class="token punctuation">.</span>nodeValue<span class="token punctuation">,</span> nodeType<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> _vnode<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>虚拟 DOM 转化成 DOM</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">parseVNode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> type <span class="token operator">=</span> vnode<span class="token punctuation">.</span>type<span class="token punctuation">;</span>  <span class="token keyword">let</span> rdom <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> <span class="token string">"element"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    rdom <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> attrs <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> attrs<span class="token punctuation">)</span> <span class="token punctuation">{</span>      rdom<span class="token punctuation">.</span><span class="token function">setArribute</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> attrs<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">let</span> children <span class="token operator">=</span> vnode<span class="token punctuation">.</span>children<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      rdom<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token function">parseNode</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> <span class="token string">"text"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    rdom <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> rdom<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="15-node-的eventloop"><a href="#15-node-的eventloop" class="headerlink" title="15. node 的eventloop"></a>15. node 的eventloop</h4><p> node的 事件循环有times, pending callbacks(I/o callbacks, idle prepare), poll,check,close callbacks</p><ul><li>times 执行setTimeOut 和setTimeInterval</li><li>check 直接执行setTimeImmediate</li></ul><h4 id="16-ajax"><a href="#16-ajax" class="headerlink" title="16. ajax"></a>16. ajax</h4><p>readyState 0 表示 请求还未初始化，尚未调用 open() 方法。<br>1 表示 已建立服务器链接，open() 方法已经被调用。<br>2 表示 请求已接受，send() 方法已经被调用，并且头部和状态已经可获得。<br>3 表示 正在处理请求，下载中； responseText 属性已经包含部分数据。<br>4 表示 完成，下载操作已完成。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">ajax</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> method<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> method<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>      xhr<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">resolve</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">404</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'404'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'请求数据失败'</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span></code></pre><h4 id="17-flutter-的生命周期"><a href="#17-flutter-的生命周期" class="headerlink" title="17. flutter 的生命周期"></a>17. flutter 的生命周期</h4><p>分为两种情况，<br>一个是statelessWidget 其生命周期是constructor、build、deactive、dispose<br>另外一个是statefulWidget，其生命周期是constructor、initState、didChangeDependencies,build、didUpdate Widget、deactive、dispose</p><h4 id="18-js-加载的async-和defer的区别"><a href="#18-js-加载的async-和defer的区别" class="headerlink" title="18. js 加载的async 和defer的区别"></a>18. js 加载的async 和defer的区别</h4><p>async script标签设置了这个值，则说明引入的js需要<strong>异步加载和执行</strong><br>在有async的情况下脚本异步加载和执行，并且不会阻塞页面加载，但是也并不会保证其加载的顺序，如果多个async优先执行，则先加载好的js文件，所以使用此方式加载的js文件最好不要包含其他依赖</p><p>defer<br>果使用此属性，也将会使js异步加载执行，且会在文档被解析完成后执行，这样就不会阻塞页面加载，但是它将会按照原来的执行顺序执行，对于有依赖关系的也可使用’</p><p>如果只有async，那么脚本在下载完成后异步执行。<br>如果只有defer，那么脚本会在页面解析完毕之后执行。</p><h4 id="19-虚拟列表"><a href="#19-虚拟列表" class="headerlink" title="19. 虚拟列表"></a>19. 虚拟列表</h4><p>可见区域</p><ul><li>列表高度是固定的，条数计算</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> height <span class="token operator">=</span> <span class="token number">60</span><span class="token keyword">const</span> bufferSize <span class="token operator">=</span> <span class="token number">5</span><span class="token keyword">this</span><span class="token punctuation">.</span>visibleCount <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>clientHeight<span class="token operator">||</span>window<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>height<span class="token punctuation">)</span> <span class="token operator">/</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>列表高度不固定<br>通过观察者方式，来观察元素是否进入视口。我们会对固定元素的第一个和最后一个分别打上标签，例如把第一个元素的id设置为top，把最后一个元素的id值设置为bottom。<br>此时调用异步的api：IntersectionObserver，他能获取到进入到视口的元素，判断当前进入视口的元素是最后个元素，则说明内容是往上滚的，如果进入视口的是第一个元素，则说明内容是往下滚的。<br>我们依次保存下当前第一个元素距离顶部的高度和距离底部的高度，赋值给滚动内容元素的paddingTop和paddingBottom，这样内容区域的高度就不会坍塌，依旧保持这传统滚动元素充满列表时的内容高度:</li></ul><h4 id="20-node-的多个通信"><a href="#20-node-的多个通信" class="headerlink" title="20. node 的多个通信"></a>20. node 的多个通信</h4><p>通过socket 和HTTP进行通信<br>同一台电脑通信可以通过IPC进行通信<br>PM2 监听node的原理：<br>pm2包括 Satan进程、God Deamon守护进程、进程间的远程调用rpc、cluster等几个概念<br>1.Satan.js提供了程序的退出、杀死等方法，因此它是魔鬼；God.js 负责维护进程的正常运行，当有异常退出时能保证重启，所以它是上帝。作者这么命名，我只能说一句：oh my god。<br>God进程启动后一直运行，它相当于cluster中的Master进程，守护者worker进程的正常运行。</p><p>2.rpc（Remote Procedure Call Protocol）是指远程过程调用，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。同一机器不同进程间的方法调用也属于rpc的作用范畴。</p><p>3.代码中采用了axon-rpc 和 axon 两个库，基本原理是提供服务的server绑定到一个域名和端口下，调用服务的client连接端口实现rpc连接。后续新版本采用了pm2-axon-rpc 和 pm2-axon两个库，绑定的方法也由端口变成.sock文件，因为采用port可能会和现有进程的端口产生冲突。</p><p>每次命令行的输入都会执行一次satan程序。如果God进程不在运行，首先需要启动God进程。然后根据指令，satan通过rpc调用God中对应的方法执行相应的逻辑。<br>God在初次执行时会配置cluster，同时监听cluster中的事件：<br>在God启动后， 会建立Satan和God的rpc链接，然后调用prepare方法。prepare方法会调用cluster.fork，完成集群的启动.</p><h4 id="21-性能指标："><a href="#21-性能指标：" class="headerlink" title="21. 性能指标："></a>21. 性能指标：</h4><ul><li>FP（首次绘制）</li><li>FCP（首次内容绘制 First contentful paint）</li><li>LCP（最大内容绘制时间 Largest contentful paint）</li><li>FPS（每秒传输帧数）</li><li>CLS (累积布局偏移)</li><li>TTI（页面可交互时间 Time to Interactive）</li><li>HTTP 请求响应时间</li><li>DNS 解析时间</li><li>TCP 连接时间</li></ul><h4 id="22-interface-和-type-、-泛型位置"><a href="#22-interface-和-type-、-泛型位置" class="headerlink" title="22. interface 和 type 、 泛型位置"></a>22. interface 和 type 、 泛型位置</h4><p>interface 只能定义对象类型。type声明可以声明任何类型。</p><p>interface 能够声明合并，两个相同接口会合并。Type声明合并会报错<br>type可以类型推导</p><p>// 定义callback遍历方法 两种方式 应该采用哪一种？<br><code>type Callback = &lt;T&gt;(item: T) =&gt; void</code><br>// 第二种声明方式<br><code>type Callback&lt;T&gt; = (item: T) =&gt; void;</code></p><p>当泛型出现在内部时，比接口本身并不具备任何泛型定义。而接口代表的函数则会接受一个泛型定义。换句话说接口本身不需要泛型，而在实现使用接口代表的函数类型时需要声明该函数接受一个泛型参数。</p><p>当泛型出现在接口中时，比如Callback<t> 代表的是使用接口时需要传入泛型的类型.</t></p><h4 id="24-箭头函数"><a href="#24-箭头函数" class="headerlink" title="24 箭头函数"></a>24 箭头函数</h4><p>this的作用域<br>但是没有prototype属性没有构造器特性，所以也就没有所谓的constructor，就不能作为构造器使用。<br>箭头函数的作用域不能通过.call、.apply、.bind等语法来改变，这使得箭头函数的上下文将永久不变<br>箭头函数不能使用关键字arguments来访问，只能通过定义的命名参数来访问。</p><h4 id="25-JS-设计模式"><a href="#25-JS-设计模式" class="headerlink" title="25 JS 设计模式"></a>25 JS 设计模式</h4><ul><li>单例模式</li><li>工厂模式</li><li>装饰器模式</li><li>观察者模式</li><li>发布-订阅者模式</li><li>策略模式</li><li>访问者模式（bable插件）</li></ul><p>装饰器模式<br>在不改变对象自身的基础上，动态地给某个对象添加一些额外的职责</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fuc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>before <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>beFn<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    beFn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 先执行插入到前面的方法，类似于二叉树的前序遍历</span>    <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 后执行当前的方法</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>afFn<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    self<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 先执行当前的方法</span>    <span class="token keyword">return</span> afFn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 后执行插入到后面的方法</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">fuc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">fuc3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">fuc4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>fuc <span class="token operator">=</span> fuc<span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span>fuc1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span>fuc4<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">after</span><span class="token punctuation">(</span>fuc3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fuc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>访问者模式<br>在不改变该对象的前提下访问其结构中元素的新方法</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 元素类</span><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> chinese<span class="token punctuation">,</span> math<span class="token punctuation">,</span> english<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>chinese <span class="token operator">=</span> chinese<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>math <span class="token operator">=</span> math<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>english <span class="token operator">=</span> english<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">accept</span><span class="token punctuation">(</span>visitor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    visitor<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 访问者类</span><span class="token keyword">class</span> <span class="token class-name">ChineseTeacher</span> <span class="token punctuation">{</span>  <span class="token function">visit</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`语文 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>student<span class="token punctuation">.</span>chinese<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MathTeacher</span> <span class="token punctuation">{</span>  <span class="token function">visit</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`数学 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>student<span class="token punctuation">.</span>math<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">EnglishTeacher</span> <span class="token punctuation">{</span>  <span class="token function">visit</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`英语 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>student<span class="token punctuation">.</span>english<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 实例化元素类</span><span class="token keyword">const</span> student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 实例化访问者类</span><span class="token keyword">const</span> chineseTeacher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChineseTeacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> mathTeacher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MathTeacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> englishTeacher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EnglishTeacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 接受访问</span>student<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>chineseTeacher<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 语文90</span>student<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>mathTeacher<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 数学80</span>student<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>englishTeacher<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 英语60</span></code></pre><h3 id="26-async-await"><a href="#26-async-await" class="headerlink" title="26. async await"></a>26. async await</h3><p>作用：用同步方式，执行异步操作</p><p>总结</p><p>1）async函数是generator（迭代函数）的语法糖</p><p>2）async函数返回的是一个Promise对象，有无值看有无return值</p><p>3）await关键字只能放在async函数内部，await关键字的作用 就是获取Promise中返回的resolve或者reject的值</p><p>4）async、await要结合try/catch使用，防止意外的错误</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">generatorToAsync</span><span class="token punctuation">(</span>generatorFn<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> gen <span class="token operator">=</span> generatorFn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// gen有可能传参</span>    <span class="token comment" spellcheck="true">// 返回一个Promise</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">function</span> <span class="token function">go</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> res        <span class="token keyword">try</span> <span class="token punctuation">{</span>          res <span class="token operator">=</span> gen<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 这里有可能会执行返回reject状态的Promise</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 报错的话会走catch，直接reject</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 解构获得value和done</span>        <span class="token keyword">const</span> <span class="token punctuation">{</span> value<span class="token punctuation">,</span> done <span class="token punctuation">}</span> <span class="token operator">=</span> res        <span class="token keyword">if</span> <span class="token punctuation">(</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 如果done为true，说明走完了，进行resolve(value)</span>          <span class="token keyword">return</span> <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 如果done为false，说明没走完，还得继续走</span>          <span class="token comment" spellcheck="true">// value有可能是：常量，Promise，Promise有可能是成功或者失败</span>          <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>val <span class="token operator">=</span><span class="token operator">></span> <span class="token function">go</span><span class="token punctuation">(</span><span class="token string">'next'</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">,</span> err <span class="token operator">=</span><span class="token operator">></span> <span class="token function">go</span><span class="token punctuation">(</span><span class="token string">'throw'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token function">go</span><span class="token punctuation">(</span><span class="token string">"next"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 第一次执行</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> asyncFn <span class="token operator">=</span> <span class="token function">generatorToAsync</span><span class="token punctuation">(</span>gen<span class="token punctuation">)</span><span class="token function">asyncFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h4 id="27-实现一个批量请求函数"><a href="#27-实现一个批量请求函数" class="headerlink" title="27.实现一个批量请求函数"></a>27.实现一个批量请求函数</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>idArray<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token function">request</span><span class="token punctuation">(</span>idArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`id</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>res<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">的请求已经处理完毕,当前并发为</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>pool<span class="token punctuation">.</span>length<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pool<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>pool<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>promise<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        pool<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>promise<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//这里是重点，当满了就阻塞</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pool<span class="token punctuation">.</span>length<span class="token operator">==</span>max<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span>pool<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="28-Promise-then-第二个参数和catch的区别是什么"><a href="#28-Promise-then-第二个参数和catch的区别是什么" class="headerlink" title="28.Promise then 第二个参数和catch的区别是什么"></a>28.Promise then 第二个参数和catch的区别是什么</h3><p>主要区别就是，如果在then的第一个函数里抛出了异常，后面的catch能捕获到，而then的第二个函数捕获不到。<br>then的第二个参数和catch捕获错误信息的时候会就近原则，如果是promise内部报错，reject抛出错误后，then的第二个参数和catch方法都存在的情况下，只有then的第二个参数能捕获到，如果then的第二个参数不存在，则catch方法会捕获到。</p><h3 id="29-promise-finally-方法实现"><a href="#29-promise-finally-方法实现" class="headerlink" title="29. promise finally 方法实现"></a>29. promise finally 方法实现</h3><p>调用当前 Promise 的 then 方法返回一个新的 Promise 对象（保证链式调用）<br>调用 Promise 中的 resolve 方法进行返回</p><pre class=" language-js"><code class="language-js">Promise<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token keyword">finally</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>    <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> err<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h3 id="30-sleep函数的多种实现"><a href="#30-sleep函数的多种实现" class="headerlink" title="30. sleep函数的多种实现"></a>30. sleep函数的多种实现</h3><p>JS没有语言内置的休眠（sleep or wait）函数，所谓的sleep只是实现一种延迟执行的效果<br>等待指定时间后再执行对应方法</p><ul><li>循环阻止</li><li>定时器</li><li>promise</li><li>async await的promise实现</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">sleep1</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> start <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start <span class="token operator">&lt;</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">continue</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 方式二： 定时器</span><span class="token keyword">function</span> <span class="token function">sleep2</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 方式三：promise</span><span class="token keyword">function</span> <span class="token function">sleep3</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 方式四：async await</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">sleep4</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"fn"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">sleep1</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sleep2</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sleep3</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sleep4</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="手写map"><a href="#手写map" class="headerlink" title="手写map"></a>手写map</h3><pre class=" language-js"><code class="language-js">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>selfMap <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> content<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// map中的第二个参数作为fn函数的this</span>  <span class="token comment" spellcheck="true">// Array.prototype.slice.call将类数组转化为数组，同Array.from, this为调用的数组（arr）</span>  <span class="token keyword">let</span> arr <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> mappedArr <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建一个空数组</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 判断稀疏数组，跳过稀疏数组中的空值</span>    <span class="token comment" spellcheck="true">// 稀疏数组：数组中元素的个数小于数组的长度，比如Array(2) 长度为2的稀疏数组</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>arr<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>    mappedArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> mappedArr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">selfMap</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> item <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [2, 4, 6]</span></code></pre><h3 id="前端错误捕获"><a href="#前端错误捕获" class="headerlink" title="前端错误捕获"></a>前端错误捕获</h3><p>错误信息分为以下几种：</p><ul><li>JS 代码运行错误、语法错误等</li><li>异步错误等</li><li>静态资源加载错误</li><li>接口请求报错</li></ul><p>try/catch 只能捕获常规的运行错误，语法错误和异步错误无法捕获<br>window.onerror 可以捕获常规的错误、异步错误、但不能捕获资源错误<br>window.addEventListener 当静态资源加载失败时，会触发error事件<br>promise错误，无法被以上几种捕获，可通过unhandledrejection 事件来处理</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// unhandledrejection 可以捕获Promise中的错误 ✅</span>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"unhandledrejection"</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"捕获到异常"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// preventDefault阻止传播，不会在控制台打印</span>  e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>vue 错误 window.onerror 和 error 事件不能捕获到常规的代码错误,vue 通过 Vue.config.errorHander 来捕获异常：</p><pre class=" language-js"><code class="language-js">Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>errorHandler <span class="token operator">=</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> vm<span class="token punctuation">,</span> info<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'进来啦~'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>React 错误<br>从 react16 开始，官方提供了 ErrorBoundary 错误边界的功能，被该组件包裹的子组件，render 函数报错时会触发离当前组件最近父组件的ErrorBoundary，生产环境，一旦被 ErrorBoundary 捕获的错误，也不会触发全局的 window.onerror 和 error 事件<br>react项目中，可以在 componentDidCatch 中将捕获的错误上报</p><p>跨域问题：如果当前页面中，引入了其他域名的JS资源，如果资源出现错误，error 事件只会监测到一个 script error 的异常。是由于浏览器基于安全考虑，故意隐藏了其它域JS文件抛出的具体错误信息，这样可以有效避免敏感信息无意中被第三方(不受控制的)脚本捕获到，因此，浏览器只允许同域下的脚本捕获具体的错误信息</p><p>接口错误<br>1）拦截XMLHttpRequest请求示例：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">xhrReplace</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token string">"XMLHttpRequest"</span> <span class="token keyword">in</span> window<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">const</span> originalXhrProto <span class="token operator">=</span> XMLHttpRequest<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 重写XMLHttpRequest 原型上的open方法</span>  <span class="token function">replaceAop</span><span class="token punctuation">(</span>originalXhrProto<span class="token punctuation">,</span> <span class="token string">"open"</span><span class="token punctuation">,</span> originalOpen <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 获取请求的信息</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>_xhr <span class="token operator">=</span> <span class="token punctuation">{</span>        method<span class="token punctuation">:</span> <span class="token keyword">typeof</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">"string"</span> <span class="token operator">?</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        url<span class="token punctuation">:</span> args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        startTime<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        type<span class="token punctuation">:</span> <span class="token string">"xhr"</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 执行原始的open方法</span>      originalOpen<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 重写XMLHttpRequest 原型上的send方法</span>  <span class="token function">replaceAop</span><span class="token punctuation">(</span>originalXhrProto<span class="token punctuation">,</span> <span class="token string">"send"</span><span class="token punctuation">,</span> originalSend <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 当请求结束时触发，无论请求成功还是失败都会触发</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"loadend"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> <span class="token punctuation">{</span> responseType<span class="token punctuation">,</span> response<span class="token punctuation">,</span> status <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> endTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>_xhr<span class="token punctuation">.</span>reqData <span class="token operator">=</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>_xhr<span class="token punctuation">.</span>status <span class="token operator">=</span> status<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"json"</span><span class="token punctuation">,</span> <span class="token string">"text"</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>responseType<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>_xhr<span class="token punctuation">.</span>responseText <span class="token operator">=</span>            <span class="token keyword">typeof</span> response <span class="token operator">===</span> <span class="token string">"object"</span> <span class="token operator">?</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span> <span class="token punctuation">:</span> response<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 获取接口的请求时长</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>_xhr<span class="token punctuation">.</span>elapsedTime <span class="token operator">=</span> endTime <span class="token operator">-</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_xhr<span class="token punctuation">.</span>startTime<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 上报xhr接口数据</span>        <span class="token function">reportData</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_xhr<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 执行原始的send方法</span>      originalSend<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 重写指定的方法 * @param { object } source 重写的对象 * @param { string } name 重写的属性 * @param { function } fn 拦截的函数 */</span><span class="token keyword">function</span> <span class="token function">replaceAop</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> name<span class="token punctuation">,</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>source <span class="token operator">===</span> undefined<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token keyword">in</span> source<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> original <span class="token operator">=</span> source<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> wrapped <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> wrapped <span class="token operator">===</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      source<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> wrapped<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>拦截fetch为例</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fetchReplace</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token string">"fetch"</span> <span class="token keyword">in</span> window<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 重写fetch方法</span>  <span class="token function">replaceAop</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> <span class="token string">"fetch"</span><span class="token punctuation">,</span> originalFetch <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> config<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> sTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">const</span> method <span class="token operator">=</span> <span class="token punctuation">(</span>config <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>method<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token string">"GET"</span><span class="token punctuation">;</span>      <span class="token keyword">let</span> handlerData <span class="token operator">=</span> <span class="token punctuation">{</span>        type<span class="token punctuation">:</span> <span class="token string">"fetch"</span><span class="token punctuation">,</span>        method<span class="token punctuation">,</span>        reqData<span class="token punctuation">:</span> config <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>body<span class="token punctuation">,</span>        url      <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> originalFetch<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> <span class="token punctuation">[</span>url<span class="token punctuation">,</span> config<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>        res <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// res.clone克隆，防止被标记已消费</span>          <span class="token keyword">const</span> tempRes <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">const</span> eTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          handlerData <span class="token operator">=</span> <span class="token punctuation">{</span>            <span class="token operator">...</span>handlerData<span class="token punctuation">,</span>            elapsedTime<span class="token punctuation">:</span> eTime <span class="token operator">-</span> sTime<span class="token punctuation">,</span>            status<span class="token punctuation">:</span> tempRes<span class="token punctuation">.</span>status          <span class="token punctuation">}</span><span class="token punctuation">;</span>          tempRes<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            handlerData<span class="token punctuation">.</span>responseText <span class="token operator">=</span> data<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 上报fetch接口数据</span>            <span class="token function">reportData</span><span class="token punctuation">(</span>handlerData<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 返回原始的结果，外部继续使用then接收</span>          <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">const</span> eTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          handlerData <span class="token operator">=</span> <span class="token punctuation">{</span>            <span class="token operator">...</span>handlerData<span class="token punctuation">,</span>            elapsedTime<span class="token punctuation">:</span> eTime <span class="token operator">-</span> sTime<span class="token punctuation">,</span>            status<span class="token punctuation">:</span> <span class="token number">0</span>          <span class="token punctuation">}</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 上报fetch接口数据</span>          <span class="token function">reportData</span><span class="token punctuation">(</span>handlerData<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">throw</span> err<span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="首屏加载时间计算"><a href="#首屏加载时间计算" class="headerlink" title="首屏加载时间计算"></a>首屏加载时间计算</h3><p>首屏加载时间和首页加载时间不一样，首屏指的是屏幕内的dom渲染完成的时间<br>比如首页很长需要好几屏展示，这种情况下屏幕以外的元素不考虑在内<br>计算首屏加载时间流程</p><p>1）利用MutationObserver监听document对象，每当dom变化时触发该事件</p><p>2）判断监听的dom是否在首屏内，如果在首屏内，将该dom放到指定的数组中，记录下当前dom变化的时间点</p><p>3）在MutationObserver的callback函数中，通过防抖函数，监听document.readyState状态的变化</p><p>4）当document.readyState === ‘complete’，停止定时器和取消对document的监听</p><p>5）遍历存放dom的数组，找出最后变化节点的时间，用该时间点减去performance.timing.navigationStart 得出首屏的加载时间</p><h3 id="图片打点上报的优势："><a href="#图片打点上报的优势：" class="headerlink" title="图片打点上报的优势："></a>图片打点上报的优势：</h3><p>1）支持跨域，一般而言，上报域名都不是当前域名，上报的接口请求会构成跨域<br>2）体积小且不需要插入dom中<br>3）不需要等待服务器返回数据<br>图片打点缺点是：url受浏览器长度限制</p><h3 id="浏览器事件循环机制"><a href="#浏览器事件循环机制" class="headerlink" title="浏览器事件循环机制"></a>浏览器事件循环机制</h3><p>事件循环其实就是在事件驱动模式中来管理和执行事件的一套流程。包括两种，一种是事件驱动，另外一种是状态驱动或数据驱动。<br>在事件驱动中，当有事件触发后，被触发的事件会按顺序暂时存在一个队列中，待 JS 的同步任务执行完成后，会从这个队列中取出要处理的事件并进行处理</p><p>JS 按顺序执行执行栈中的方法，每次执行一个方法时，会为这个方法生成独有的执行环境（上下文 context)，待这个方法执行完成后，销毁当前的执行环境，并从栈中弹出此方法（即消费完成），然后继续下一个方法。在事件驱动的模式下，至少包含了一个执行循环来检测任务队列是否有新的任务。通过不断循环去取出异步回调来执行，这个过程就是事件循环，而每一次循环就是一个事件周期或称为一次 tick。</p><p>事件循环的过程中，执行栈在同步代码执行完成后，优先检查微任务队列是否有任务需要执行，如果没有，再去宏任务队列检查是否有任务执行，如此往复。微任务一般在当前循环就会优先执行，而宏任务会等到下一次循环，因此，微任务一般比宏任务先执行，并且微任务队列只有一个，宏任务队列可能有多个。另外我们常见的点击和键盘等事件也属于宏任务。<br>根据任务的种类不同，可以分为微任务（micro task）队列和宏任务（macro task）队列。<br>常见宏任务：setTimeout() setInterval()<br>常见微任务：promise.then() MutaionObserver nextTick</p><h3 id="关于SVG-和-Canvas-的区别。"><a href="#关于SVG-和-Canvas-的区别。" class="headerlink" title="关于SVG 和 Canvas 的区别。"></a>关于SVG 和 Canvas 的区别。</h3><p>1、SVG 不能绘制图片，而 canvas 可以。SVG是通过 XML 绘制，而Canvas通过 js 绘制<br>2、Canvas绘制的方式，是通过 js 逐像素渲染的。也就是说，它绘制一个复杂的图形和一个简单的图形的性能是差不多的。<br>SVG 是通过 XML 的方式渲染。它的本质是DOM，而复杂的图形，就会降低其渲染性能。<br>3、Canvas 是依赖分辨率，是一种标量图。所以在放缩的时候，存在失真的问题。<br>SVG 绘制的时候，不依赖分辨率，是一种矢量图。所以当SVG放缩的时候，不会使得图像失真。<br>4、SVG 适合带有大型渲染区域的应用程序：比如谷歌地图、百度地图。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试-CSS</title>
      <link href="2022/11/29/css/"/>
      <url>2022/11/29/css/</url>
      
        <content type="html"><![CDATA[<h4 id="1-定位、布局"><a href="#1-定位、布局" class="headerlink" title="1.定位、布局"></a>1.定位、布局</h4><p>不同定位的区别，两栏布局、三栏布局，flex布局必会<br> 两栏布局:浮动布局、flex<br> 三栏布局:双飞翼布局 三栏都采用左浮动</p><pre class=" language-css"><code class="language-css"> <span class="token selector"><span class="token id">#main</span></span><span class="token punctuation">{</span>  <span class="token property">background-color</span><span class="token punctuation">:</span>aqua<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">100%</span><span class="token punctuation">;</span>  <span class="token property">float</span><span class="token punctuation">:</span>left<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token id">#left</span></span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">200</span>px<span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span>yellow<span class="token punctuation">;</span>  <span class="token property">float</span><span class="token punctuation">:</span>left<span class="token punctuation">;</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span>-<span class="token number">100%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token id">#right</span></span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">300</span>px<span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span>orange<span class="token punctuation">;</span>  <span class="token property">float</span><span class="token punctuation">:</span>left<span class="token punctuation">;</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span>-<span class="token number">300</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token id">#content</span></span><span class="token punctuation">{</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span><span class="token number">200</span>px<span class="token punctuation">;</span>  <span class="token property">margin-right</span><span class="token punctuation">:</span><span class="token number">300</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span>  &lt;!--中间栏写在最前面-->&lt;div id = <span class="token string">"main"</span>>  &lt;div id=<span class="token string">"content"</span>>&lt;/div>&lt;/div>&lt;div id = <span class="token string">"left"</span>>&lt;/div>&lt;div id = <span class="token string">"right"</span>>&lt;/div></code></pre><p>CSS三列布局</p><ul><li>float布局：左边左浮动，右边右浮动，中间margin：0 100px;</li><li>Position布局: 左边left：0; 右边right：0; 中间left: 100px; right: 100px;</li><li>table布局: 父元素 display: table; 左右 width: 100px; 三个元素display: table-cell;</li><li>弹性(flex)布局:父元素 display: flex; 左右 width: 100px;</li><li>网格（gird）布局：</li></ul><h4 id="2-对于一些常见css的书写-比如文本溢出显示省略号"><a href="#2-对于一些常见css的书写-比如文本溢出显示省略号" class="headerlink" title="2. 对于一些常见css的书写:比如文本溢出显示省略号"></a>2. 对于一些常见css的书写:比如文本溢出显示省略号</h4><pre class=" language-css"><code class="language-css"><span class="token property">text-overflow</span><span class="token punctuation">:</span>ellipsis#多行<span class="token property">display</span><span class="token punctuation">:</span>-webkit-box<span class="token property">-webkit-line-clamp</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">;</span></code></pre><h4 id="3-link和-import的区别"><a href="#3-link和-import的区别" class="headerlink" title="3. link和@import的区别"></a>3. link和@import的区别</h4><ul><li>link的功能比较多，可以定义RSS、Rel等作用，而@import只能用于加载css</li><li>解析到link时，同步加载引到的css，而@import引到的css等到页面加载完成后才被加载</li><li>@import 需要ES5 以上</li><li>link可以js动态导入，@import不行</li></ul><h4 id="4-flex"><a href="#4-flex" class="headerlink" title="4. flex"></a>4. flex</h4><ul><li>flex-direction</li><li>justify-content</li><li>align-items</li><li>align-content (多轴线的对齐方式)</li><li>flex-wrap</li></ul><p>子 </p><ul><li>flex： 0 1 auto</li><li>表示flex-grow 为0 flex-shrink 为1 flex basis为auto</li><li>align-self</li></ul><h4 id="5-垂直居中和水平居中"><a href="#5-垂直居中和水平居中" class="headerlink" title="5.垂直居中和水平居中"></a>5.垂直居中和水平居中</h4><ul><li>line-height</li><li>absolute+ margin(负值)</li><li>absolute + margin auto</li><li>absolute + translate</li><li>Flex + align-items</li><li>Flex + margin auto</li><li>Flex + align-self</li><li>grid +align-items</li><li>calc</li></ul><h4 id="6-BFC"><a href="#6-BFC" class="headerlink" title="6. BFC"></a>6. BFC</h4><p>BFC（Block formatting context），即块级格式化上下文，它作为HTML页面上的一个独立渲染区域，只有区域内元素参与渲染，且不会影响其外部元素。简单来说，可以将 BFC 看做是一个“围城”，外面的元素进不来，里面的元素出不去<br>形成BFC的条件:</p><p>1、浮动元素，float 除 none 以外的值；<br>2、定位元素，position（absolute，fixed）；<br>3、display 为以下其中之一的值 inline-block，table-cell，table-caption；<br>4、overflow 除了 visible 以外的值（hidden，auto，scroll）；</p><p>BFC 一般用来解决以下几个问题<br>边距重叠问题<br>消除浮动问题<br>自适应布局问题</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解Composition API和 watch 源码分析</title>
      <link href="2022/11/18/shen-ru-liao-jie-composition-api-he-watch-yuan-ma-fen-xi/"/>
      <url>2022/11/18/shen-ru-liao-jie-composition-api-he-watch-yuan-ma-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-Composition-API（VCA）"><a href="#什么是-Composition-API（VCA）" class="headerlink" title="什么是 Composition API（VCA）"></a>什么是 Composition API（VCA）</h2><p>Composition API 是 vue3 推出的重磅功能之一，是一种新的编写 vue 组件的方式，实现了类似于 React hooks 可以在组件之间共享可复用的状态逻辑的特性, 方便了开发者将业务逻辑和 UI 视图进行解耦，从而状态与 UI 的界限会越来越清晰，Vue Composition API 是未来 Vue 社区组件和响应式数据组织所倡导的方式，不仅能提供性能提升、更高的逻辑清晰度，也能让我们能够更方便的复用开源社区共享的逻辑实现片段，助力我们更好的进行业务支撑。顺着这个思路，我们有机会将与业务无关的逻辑进行抽象，封装一套通用场景的纯逻辑的 Hooks 工具方法。</p><p>其实，React hooks 的问题也有很多，比如：</p><ul><li>Hook 是一个链表的结构，在循环，条件或嵌套函数中调用 Hook，会引发一些问题。</li><li>useEffect 的依赖容易造成心智负担，所有人阅读这段代码，都需要完整的阅读完这些依赖触发的地方</li><li>由于闭包的原因，useEffect 等内部捕获的，都是过时的变量。</li></ul><p>而 Vue 以上三个问题都没有。并且因为 setup 函数只调用一次，性能上占优，当然，根本原因就是因为它的数据是响应式的，我直接改就可以读取到最新的值。</p><h2 id="对比-react-的-hooks，VCA-的优点："><a href="#对比-react-的-hooks，VCA-的优点：" class="headerlink" title="对比 react 的 hooks，VCA 的优点："></a>对比 react 的 hooks，VCA 的优点：</h2><h3 id="1-对-Hooks-使用顺序无要求，而且可以放在条件语句里。"><a href="#1-对-Hooks-使用顺序无要求，而且可以放在条件语句里。" class="headerlink" title="1. 对 Hooks 使用顺序无要求，而且可以放在条件语句里。"></a>1. 对 Hooks 使用顺序无要求，而且可以放在条件语句里。</h3><p>对 React Hooks 而言，调用必须放在最前面，而且不能被包含在条件语句里，这是因为 React Hooks 采用下标方式寻找状态，一旦位置不对或者 Hooks 放在了条件中，就无法正确找到对应位置的值。<br>而 Vue Function API 中的 Hooks 可以放在任意位置、任意命名、被条件语句任意包裹的，因为其并不会触发 setup 的更新，只在需要的时候更新自己的引用值即可，而 Template 的重渲染则完全继承 Vue 2.0 的依赖收集机制，它不管值来自哪里，只要用到的值变了，就可以重新渲染了。</p><h3 id="2-不会每次渲染重复调用，减少-GC-压力。"><a href="#2-不会每次渲染重复调用，减少-GC-压力。" class="headerlink" title="2. 不会每次渲染重复调用，减少 GC 压力。"></a>2. 不会每次渲染重复调用，减少 GC 压力。</h3><p>这确实是 React Hooks 的一个问题，所有 Hooks 都在渲染闭包中执行，每次重渲染都有一定性能压力，而且频繁的渲染会带来许多闭包，虽然可以依赖 GC 机制回收，但会给 GC 带来不小的压力。<br>而 Vue Hooks 只有一个引用，所以存储的内容就非常精简，也就是占用内存小，而且当值变化时，也不会重新触发 setup 的执行，所以确实不会造成 GC 压力。</p><blockquote><p>延伸：在 VCA 中还需要 useEffect、useCallback、useMemo 来做性能优化吗？</p><p>答：不需要使用 useEffect useMemo 等进行性能优化，所有性能优化都是自动的。这也是实在话，毕竟 Mutable + 依赖自动收集就可以做到最小粒度的精确更新，根本不会触发不必要的 Rerender，因此 useMemo 这个概念也不需要了。而 useEffect 也需要传递第二个参数 “依赖项”，在 Vue 中根本不需要传递 “依赖项”，所以也不会存在用户不小心传错的问题.</p></blockquote><h2 id="VCA-对比-Vue2-中对象式-API（OptionsAPI）"><a href="#VCA-对比-Vue2-中对象式-API（OptionsAPI）" class="headerlink" title="VCA 对比 Vue2 中对象式 API（OptionsAPI）"></a>VCA 对比 Vue2 中对象式 API（OptionsAPI）</h2><p>Options API 存在的问题：</p><h3 id="1-组件逻辑膨胀导致的可读性变差–反复横跳"><a href="#1-组件逻辑膨胀导致的可读性变差–反复横跳" class="headerlink" title="1. 组件逻辑膨胀导致的可读性变差–反复横跳"></a>1. 组件逻辑膨胀导致的可读性变差–反复横跳</h3><p>大部分同学都维护过超过 200 行的.vue 组件，新增或者修改一个需求，就需要分别在 data，methods，computed 里修改 ，滚动条反复上下移动，这里称之为『反复横跳』 比如我们简单的加个拍脑门的需求加个累加器 ，这种写代码上下反复横跳的体验比较差，同时，可读性随代码量增加随之变差。<br><img src="https://raw.githubusercontent.com/s1p21/hexo/master/source/images4497234467.jpeg"></p><p><img src="https://raw.githubusercontent.com/s1p21/hexo/master/source/images4497541299.jpeg"></p><h3 id="2-无法很好跨组件重用代码-mixin-和-this"><a href="#2-无法很好跨组件重用代码-mixin-和-this" class="headerlink" title="2.无法很好跨组件重用代码 - mixin 和 this"></a>2.无法很好跨组件重用代码 - mixin 和 this</h3><h4 id="2-1-来源黑盒"><a href="#2-1-来源黑盒" class="headerlink" title="2.1 来源黑盒"></a>2.1 来源黑盒</h4><p>反复横跳的本质，在于功能的分块组织，以及代码量太大了，如果我们能把代码控制在一屏，自然就解决了，vue2 里的解决方案，是使用 mixin 来混合, 我们抽离一个 counter.js</p><pre class=" language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// counter.js</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      count<span class="token punctuation">:</span><span class="token number">1</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">double</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token number">2</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span><span class="token punctuation">{</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">++</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// App.vue</span><span class="token keyword">import</span> Counter <span class="token keyword">from</span> <span class="token string">'./counter'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  mixins<span class="token punctuation">:</span><span class="token punctuation">[</span>Counter<span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">...</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">}</span></code></pre><p>这样确实拆分了代码，但是有一个严重的问题，就是不打开 counter.js，App.vue 里的 this 上，count，add 这些属性，是完全不知道从哪来的，你不知道是 mixin，还是全局 install，还是 Vue.prototype.count 设置的，数据来源完全模糊，调试难度增加，这也是 option 的一个大问题，this 是个黑盒，template 里写的 count 和 double，完全不知道从哪来的。</p><h3 id="2-2-命名冲突"><a href="#2-2-命名冲突" class="headerlink" title="2.2 命名冲突"></a>2.2 命名冲突</h3><p>如果有两个 mixin，就更有意思了，比如我们又有一个需求，实时显示鼠标的坐标位置 x，并且有一个乘以 2 的计算属性凑巧也叫 double，再整一个 mixin</p><pre class=" language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// mixin</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      x<span class="token punctuation">:</span><span class="token number">0</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span><span class="token punctuation">{</span>    <span class="token function">update</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> e<span class="token punctuation">.</span>pageX    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  computed<span class="token punctuation">:</span><span class="token punctuation">{</span>    <span class="token function">double</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token operator">*</span><span class="token number">2</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'mousemove'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>update<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">destroyed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    window<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">'mousemove'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>update<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// App.vue</span><span class="token keyword">import</span> Counter <span class="token keyword">from</span> <span class="token string">'./counter'</span><span class="token keyword">import</span> Mouse <span class="token keyword">from</span> <span class="token string">'./mouse'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  mixins<span class="token punctuation">:</span><span class="token punctuation">[</span>Counter<span class="token punctuation">,</span>Mouse<span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">}</span></code></pre><p>两个 mixin 里都有 double 这个数，尴尬，看效果 ，lsp 的 count 被覆盖了 很尴尬，而且在 App.vue 这里，你完全不知道这个 double 到底是哪个，调试很难</p><p><img src="https://raw.githubusercontent.com/s1p21/hexo/master/source/images4498294791.jpeg"></p><p><strong>composition api 就是为了解决上述问题存在的，通过组合的方式，把零散在各个 data，methods 的代码，重新组合，一个功能的代码都放在一起维护，并且这些代码可以单独拆分成函数，不仅提高可读性和维护性，也可以更好的重用逻辑代码。</strong></p><p><img src="https://raw.githubusercontent.com/s1p21/hexo/master/source/images4498621529.jpeg"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>优势对比</p><table><thead><tr><th>Options API</th><th>Composition API</th></tr></thead><tbody><tr><td>按 API 类型组织代码，复杂度高了后需要反复横跳</td><td>按功能/逻辑组织代码</td></tr><tr><td>不利于复用</td><td>极易复用,可灵活组合</td></tr><tr><td>潜在命名冲突，数据源来源不清晰</td><td>数据来源清晰</td></tr><tr><td>上下文丢失</td><td>提供更好的上下文</td></tr><tr><td>有限类型支持</td><td>更好的 TypeScript 支持</td></tr><tr><td>响应式数据必须在组件的 data 中定义</td><td>可独立 vue 组件使用</td></tr></tbody></table><h2 id="watch-源码分析"><a href="#watch-源码分析" class="headerlink" title="watch 源码分析"></a>watch 源码分析</h2><p>在使用 Composition API 的过程中，我们不可避免的使用 watch 监听方法，监听数据的变化从而进行业务的操作。但是在 watch 方法的使用过程中，发现只能以两种方式来传入 watch 的数据源信息，那么这两者有什么区别呢？</p><h3 id="watch-方法的-API"><a href="#watch-方法的-API" class="headerlink" title="watch 方法的 API"></a>watch 方法的 API</h3><p>首先看下 watch 的 ts 类型</p><pre class=" language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// 源码中的createWatcher方法</span><span class="token keyword">function</span> <span class="token function">createWatcher</span><span class="token punctuation">(</span>  vm<span class="token punctuation">:</span> ComponentInstance<span class="token punctuation">,</span>  source<span class="token punctuation">:</span> WatchSource<span class="token operator">&lt;</span>unknown<span class="token operator">></span> <span class="token operator">|</span> WatchSource<span class="token operator">&lt;</span>unknown<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> WatchEffect<span class="token punctuation">,</span>  cb<span class="token punctuation">:</span> WatchCallback<span class="token operator">&lt;</span><span class="token keyword">any</span><span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>  options<span class="token punctuation">:</span> WatchOptions<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//  类型声明如下</span><span class="token keyword">declare</span> <span class="token keyword">function</span> watch<span class="token operator">&lt;</span>  T <span class="token keyword">extends</span> <span class="token class-name">Readonly</span><span class="token operator">&lt;</span>WatchSource<span class="token operator">&lt;</span>unknown<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">,</span>  Immediate <span class="token keyword">extends</span> <span class="token class-name">Readonly</span><span class="token operator">&lt;</span><span class="token keyword">boolean</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token keyword">false</span><span class="token operator">></span><span class="token punctuation">(</span>  sources<span class="token punctuation">:</span> T<span class="token punctuation">,</span>  cb<span class="token punctuation">:</span> WatchCallback<span class="token operator">&lt;</span>MapSources<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">,</span> MapOldSources<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Immediate<span class="token operator">></span><span class="token operator">></span><span class="token punctuation">,</span>  options<span class="token operator">?</span><span class="token punctuation">:</span> WatchOptions<span class="token operator">&lt;</span>Immediate<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">:</span> WatchStopHandle<span class="token punctuation">;</span><span class="token keyword">declare</span> <span class="token keyword">function</span> watch<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Immediate <span class="token keyword">extends</span> <span class="token class-name">Readonly</span><span class="token operator">&lt;</span><span class="token keyword">boolean</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token keyword">false</span><span class="token operator">></span><span class="token punctuation">(</span>  source<span class="token punctuation">:</span> WatchSource<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">,</span>  cb<span class="token punctuation">:</span> WatchCallback<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Immediate <span class="token keyword">extends</span> <span class="token class-name">true</span> <span class="token operator">?</span> T <span class="token operator">|</span> undefined <span class="token punctuation">:</span> T<span class="token operator">></span><span class="token punctuation">,</span>  options<span class="token operator">?</span><span class="token punctuation">:</span> WatchOptions<span class="token operator">&lt;</span>Immediate<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">:</span> WatchStopHandle<span class="token punctuation">;</span><span class="token keyword">declare</span> <span class="token keyword">function</span> watch<span class="token operator">&lt;</span>  T <span class="token keyword">extends</span> <span class="token class-name">object</span><span class="token punctuation">,</span>  Immediate <span class="token keyword">extends</span> <span class="token class-name">Readonly</span><span class="token operator">&lt;</span><span class="token keyword">boolean</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token keyword">false</span><span class="token operator">></span><span class="token punctuation">(</span>  source<span class="token punctuation">:</span> T<span class="token punctuation">,</span>  cb<span class="token punctuation">:</span> WatchCallback<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Immediate <span class="token keyword">extends</span> <span class="token class-name">true</span> <span class="token operator">?</span> T <span class="token operator">|</span> undefined <span class="token punctuation">:</span> T<span class="token operator">></span><span class="token punctuation">,</span>  options<span class="token operator">?</span><span class="token punctuation">:</span> WatchOptions<span class="token operator">&lt;</span>Immediate<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">:</span> WatchStopHandle<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 其中watchSource和watchCallback分别为</span>type WatchSource<span class="token operator">&lt;</span>T <span class="token operator">=</span> <span class="token keyword">any</span><span class="token operator">></span> <span class="token operator">=</span> Ref<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">|</span> ComputedRef<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> T<span class="token punctuation">)</span><span class="token punctuation">;</span>type WatchCallback<span class="token operator">&lt;</span>V <span class="token operator">=</span> <span class="token keyword">any</span><span class="token punctuation">,</span> OV <span class="token operator">=</span> <span class="token keyword">any</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">(</span>  value<span class="token punctuation">:</span> V<span class="token punctuation">,</span>  oldValue<span class="token punctuation">:</span> OV<span class="token punctuation">,</span>  onInvalidate<span class="token punctuation">:</span> InvalidateCbRegistrator<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">any</span><span class="token punctuation">;</span></code></pre><p>综上所述，watch 接受三个参数，第一个是数据源信息，可以是 any 也可以是 ref 或者是 reactive 的类型，第二个参数是一个 watch 函数，接受三个参数，最新的 value，oldValue 和验证 onInvalidate 参数，第三个 option 的参数就是 immetiate 和 deep 的属性了</p><p>那么其在业务中的最佳实践是什么样的呢？</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"tom"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ✅ 方法一，传递响应对象</span><span class="token function">watch</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 监听成功，输出 { name: 'jake' }</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ❌ 方法二：传递响应对象下的属性</span><span class="token function">watch</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 监听失败，没输出</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ✅ 方法三：传递函数，函数返回响应对象属性</span><span class="token function">watch</span><span class="token punctuation">(</span>  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> user<span class="token punctuation">.</span>name<span class="token punctuation">,</span>  <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 监听成功，输出 jake</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 对响应对象重新赋值</span>user<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"jake"</span><span class="token punctuation">;</span></code></pre><p>第二种方式为什么不能被监听呢？<br>查看<a href="https://github.com/vuejs/composition-api/blob/main/src/apis/watch.ts">源码</a>，在第二种场景下，else 逻辑，使得 getter 变成 noopFn。所以没法触发 getter，也就是没法收集 effect，最终导致 watch 失效。</p><p><img src="https://raw.githubusercontent.com/s1p21/hexo/master/source/images202211181733359.png"></p><p>也就是说针对第二种情况，我们可以通过将 user.name 转化成 ref 或者变成第三种来触发其属性的变更。实践证明，确实是可以执行的。</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"tom"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token punctuation">{</span> name <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">toRefs</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">watch</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 监听监听成功，输出 jake</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了 Composition API (VCA), 并且与 React hooks 以及 Option API 进行了对比，详细阐述了 VCA 的一些优点; 结合 VCA 的 watch 源码，详细阐述了 watch 的数据源类型只能是响应对象和函数，否则将无法监听数据源的变更。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> composition API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防腐层在前端领域的实践</title>
      <link href="2022/11/16/fang-fu-ceng-zai-qian-duan-ling-yu-de-shi-jian/"/>
      <url>2022/11/16/fang-fu-ceng-zai-qian-duan-ling-yu-de-shi-jian/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是防腐层"><a href="#什么是防腐层" class="headerlink" title="什么是防腐层"></a>什么是防腐层</h3><p>防腐层(Anti-corruption layer) ： 防腐层（Anti-corruption layer）模式最先由 Eric Evans 在 Domain-Driven Design（领域驱动的设计）中描述。</p><p>防腐层（Anti-corruption layer，简称 ACL）介于新应用和遗留应用之间，用于确保新应用的设计不受老应用的限制。是一种在不同应用间转换的机制。</p><p>创建一个防腐层，以根据客户端自己的域模型为客户提供功能。该层通过其现有接口与另一个系统进行通信，几乎不需要或不需要对其进行任何修改。因此，防腐层隔离不仅是为了保护您免受混乱的代码的侵害，还在于分离不同的域并确保它们在将来保持分离。</p><p>防腐层是将一个域映射到另一个域，这样使用第二个域的服务就不必被第一个域的概念“破坏”。</p><p>在不共享相同语义的不同子系统之间实施外观或适配器层。 此层转换一个子系统向另一个子系统发出的请求。 使用防腐层（Anti-corruption layer）模式可确保应用程序的设计不受限于对外部子系统的依赖。</p><h3 id="防腐层提出背景"><a href="#防腐层提出背景" class="headerlink" title="防腐层提出背景"></a>防腐层提出背景</h3><p>大多数应用程序依赖于其他系统的某些数据或功能。 例如，旧版应用程序迁移到新式系统时，可能仍需要现有的旧的资源。 新功能必须能够调用旧系统。 逐步迁移尤其如此，随着时间推移，较大型应用程序的不同功能迁移到新式系统中。</p><p>这些旧系统通常会出现质量问题，如复杂的数据架构或过时的 API。 旧系统使用的功能和技术可能与新式系统中的功能和技术有很大差异。 若要与旧系统进行互操作，新应用程序可能需要支持过时的基础结构、协议、数据模型、API、或其他不会引入新式应用程序的功能。</p><p>保持新旧系统之间的访问可以强制新系统至少支持某些旧系统的 API 或其他语义。 这些旧的功能出现质量问题时，支持它们“损坏”可能会是完全设计的新式应用程序。</p><p>不仅仅是旧系统，不受开发团队控制的任何外部系统(第三方系统)都可能出现类似的问题。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>在不同的子系统之间放置防损层以将其隔离。 此层转换两个系统之间的通信，在一个系统保持不变的情况下，使另一个系统可以避免破坏其设计和技术方法。</p><p>​ 在不同的子系统之间放置防损层以将其隔离<br><img src="https://raw.githubusercontent.com/s1p21/hexo/master/source/images20221115191411.png" alt="防腐层"></p><p>上图显示了采用两个子系统的应用程序。</p><p>子系统 A 通过防损层调用子系统 B。 子系统 A 与防损层之间的通信始终使用子系统 A 的数据模型和体系结构。防腐层向子系统 B 发出的调用符合该子系统的数据模型或方法。 防腐层包含在两个系统之间转换所必需的所有逻辑。</p><p>该层可作为应用程序内的组件或作为独立服务实现。</p><h3 id="防腐层实践"><a href="#防腐层实践" class="headerlink" title="防腐层实践"></a>防腐层实践</h3><p>在前端，谈到防腐层，不得不先来提下 23 种设计模式中的适配器模式，主要用于将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能在一起工作的那些类可以一起工作。这个设计模式的很好理解，主要用于接口参数的对齐。但是，仅仅只能解决字段不一致的问题，不能解决功能不一致的问题。</p><p>而防腐层，亦被称适配层。我们在重构的时候，时常需要访问一些外部的变量和方法，但因为是存量代码，我们无法保证他们的行为是符合预期的，并且我们现在也并不打算去他们做重写，那么引入防腐层就能很好的解决该问题。该层通过其现有接口与另一个系统进行通信，几乎不需要对其进行任何修改。因此，防腐层隔离不仅是为了保护你的系统免受异常代码的侵害，还在于分离不同的领域并确保它们在将来保持分离。有了防腐层，未来的变更不会动到我们的领域核心代码，每次接口字段变更、业务逻辑变更、上游依赖变更，只需要在防腐层内进行统一对齐，缩小了整体的影响范围。</p><p>以 To B 业务场景中的展示仪表盘举例，该页面包含了可用内存，已使用内存和已使用内存占比三部分信息展示</p><p><img src="https://www.xieyadong.com/markdown/147622816-198b6901-48ce-4ecc-8417-259a4410cc6f.webp" alt="内存"></p><p>此时前端组件与接口之间的依赖关系如下图所示<br><img src="https://www.xieyadong.com/markdown/147622819-d7119f0a-20a5-43b9-bfaa-354a6be6308d.webp" alt="接口依赖关系"></p><p>当 v2 版本的接口返回结构进行了调整，为了适配该结构的变化，MemoryFree 组件对接口的调用方式需要调整。同样的，MemoryUsage 与 MemoryUsagePercent 也要进行类似的修改才能工作。<br><img src="https://www.xieyadong.com/markdown/147622830-c6035b6b-ed9e-464f-a4b5-ad995b9c5eca.webp" alt="更改后的接口"></p><h4 id="前端防腐层选型"><a href="#前端防腐层选型" class="headerlink" title="前端防腐层选型"></a>前端防腐层选型</h4><p>前端有很多种方式可以实现防腐层，无论是近几年大火的 GraphQL 还是 BFF 都可以作为备选方案，但是技术选型同样受限于我们的业务场景。与 To C 业务完全不同，在 To B 业务中，前后端的关系通常为客户/供应商或者跟随者/被跟随者的关系。在这种关系下，寄希望于后端配合前端对接口进行 GraphQL 改造已经变得不太现实，而 BFF 的构建一般需要额外的部署资源及运维成本。</p><p>在上述情况下，在浏览器端构建防腐层是更为可行的方案，但是在浏览器中构建防腐层同样面临挑战。</p><p>无论是 React、Angular 还是 Vue 均有无数的数据层解决方案，从 Mobx、Redux、Vuex 等等，这些数据层方案对视图层实际上都会有入侵，有没有一种防腐层解决方案可以与视图层彻底解耦呢？以 RxJS 为代表的 Observable 方案在这时可能是最好的选择。<br><img src="https://www.xieyadong.com/markdown/2022-02-25-11-19-01.webp" alt="前端选型"><br>RxJS 是 ReactiveX 项目的 JavaScript 实现，而 ReactiveX 最早是 LINQ 的一个扩展，由微软的架构师 Erik Meijer 领导的团队开发。该项目目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流。目前 RxJS 在开发中经常被作为响应式编程开发工具使用，但是在构建防腐层的场景中，RxJS 代表的 Observable 方案同样可以发挥巨大作用。<br><img src="https://www.xieyadong.com/markdown/147622932-628454f5-fba2-45c8-808d-1fbc4ad734c0.webp" alt="RxJS"></p><p>选择 RxJS 主要基于以下几点考虑：</p><ul><li>统一不同数据源的能力：RxJS 可以将 websocket、http 请求、甚至用户操作、页面点击等转换为统一的 Observable 对象。</li><li>统一不同类型数据的能力：RxJS 将异步数据和同步数据统一为 Observable 对象。</li><li>丰富的数据加工能力：RxJS 提供了丰富的 Operator 操作符，可以对 Observable 在订阅前进行预先加工和高层封装。</li><li>与 Promise 无缝切换：RxJS 的 Observable 可以与 Promise 互相转换，这意味着 RxJS 的所有概念可以被完整封装在数据层，对视图层可以只暴露 Promise。<br>当在引入 RxJS 将所有类型的接口转换为 Observable 对象后，前端的视图组件将仅依赖 Observable，并与接口实现的细节解耦，同时，Observable 可以与 Promise 相互转换，在视图层获得的是单纯的 Promise，可以与任意数据层方案和框架搭配使用。</li></ul><p>除了转换为 Promise 之外，开发者也可以与 RxJS 在渲染层的解决方案，例如 rxjs-hooks 混用，获得更好的开发体验。<br><img src="https://www.xieyadong.com/markdown/2022-02-25-11-20-14.webp" alt="解决方案"></p><h4 id="RxJS-实现示例"><a href="#RxJS-实现示例" class="headerlink" title="RxJS 实现示例"></a>RxJS 实现示例</h4><p>参照上文的防腐层设计，我们在开头的仪表盘项目中实现以 RxJS Observable 为核心的防腐层代码。<br><img src="https://www.xieyadong.com/markdown/2022-02-25-11-20-37.webp" alt="方案"></p><p>其中防腐层的核心代码如下</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">import</span> <span class="token punctuation">{</span> forkJoin<span class="token punctuation">,</span> map<span class="token punctuation">,</span> mergeMap<span class="token punctuation">,</span> Observable<span class="token punctuation">,</span> lastValueFrom <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"rxjs"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> fromFetch <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"rxjs/fetch"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getMemoryFreeObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Observable<span class="token operator">&lt;</span><span class="token keyword">number</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">fromFetch</span><span class="token punctuation">(</span><span class="token string">"/api/v1/memory/free"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">mergeMap</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getMemoryUsageObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Observable<span class="token operator">&lt;</span><span class="token keyword">number</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">fromFetch</span><span class="token punctuation">(</span><span class="token string">"/api/v1/memory/usage"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">mergeMap</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getMemoryUsagePercent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Promise<span class="token operator">&lt;</span><span class="token keyword">number</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">lastValueFrom</span><span class="token punctuation">(</span>    <span class="token function">forkJoin</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">getMemoryFreeObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getMemoryUsageObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>      <span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">[</span>usage<span class="token punctuation">,</span> free<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span>usage <span class="token operator">/</span> <span class="token punctuation">(</span>usage <span class="token operator">+</span> free<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getMemoryFree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Promise<span class="token operator">&lt;</span><span class="token keyword">number</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">lastValueFrom</span><span class="token punctuation">(</span><span class="token function">getMemoryFreeObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getMemoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Promise<span class="token operator">&lt;</span><span class="token keyword">number</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">lastValueFrom</span><span class="token punctuation">(</span><span class="token function">getMemoryUsageObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>MemoryUsagePercent 的实现代码如下，此时该组件将不再依赖具体的接口，而直接依赖防腐层的实现。</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useEffect<span class="token punctuation">,</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"react"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> getMemoryUsagePercent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./service"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">MemoryUsagePercent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>usage<span class="token punctuation">,</span> setUsage<span class="token punctuation">]</span> <span class="token operator">=</span> useState<span class="token operator">&lt;</span><span class="token keyword">number</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token punctuation">(</span>async <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> result <span class="token operator">=</span> await <span class="token function">getMemoryUsagePercent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">setUsage</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">></span>Usage<span class="token punctuation">:</span> <span class="token punctuation">{</span>usage<span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">default</span> MemoryUsagePercent<span class="token punctuation">;</span></code></pre><h6 id="返回字段调整"><a href="#返回字段调整" class="headerlink" title="返回字段调整"></a>返回字段调整</h6><p>返回字段变更时，防腐层可以有效拦截接口对组件的影响，当 /api/v2/quota/free 与 /api/v2/quota/usage 的返回数据变更为以下结构时<br><img src="https://www.xieyadong.com/markdown/147622955-745ea7fe-98a2-4642-8be1-b89b6d986f85.webp" alt="更改"></p><p><code>{ requestId: string; data: number;}</code></p><p>我们只需要调整防腐层的两行代码，而组件层的代码不再需要变动</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getMemoryFree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Observable<span class="token operator">&lt;</span><span class="token keyword">number</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">fromFetch</span><span class="token punctuation">(</span><span class="token string">"/api/v2/memory/free"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>    <span class="token function">mergeMap</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token operator">+</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> data<span class="token punctuation">.</span>data<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getMemoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Observable<span class="token operator">&lt;</span><span class="token keyword">number</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">fromFetch</span><span class="token punctuation">(</span><span class="token string">"/api/v2/memory/usage"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>    <span class="token function">mergeMap</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token operator">+</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> data<span class="token punctuation">.</span>data<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在 Observable 化的防腐层中，会存在高阶 Observable 与 低阶 Observable 两种设计，在上文的例子中，Free Observable 和 Usage Observable 为低阶封装，而 Usage Observable 利用 Free 和 Usage 的 Observable 进行了高阶封装，当低阶封装改动时，由于 Observable 本身的特性，高阶封装经常是不需要进行任何改动的，这也是防腐层给我们带来的额外好处。<br><img src="https://www.xieyadong.com/markdown/2022-02-25-11-26-32.webp" alt="observable"></p><h6 id="调用方式改变"><a href="#调用方式改变" class="headerlink" title="调用方式改变"></a>调用方式改变</h6><p>当调用方式发生改变时，防腐层同样可以发挥作用。/api/v3/memory 直接返回了 free 与 usage 的数据，接口格式如下。<br><img src="https://www.xieyadong.com/markdown/147622966-144f4c98-3d96-4aa6-b240-6a8dbfb7fa63.webp" alt="调用方式"></p><pre class=" language-ts"><code class="language-ts"><span class="token punctuation">{</span>  requestId<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>    free<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>    usage<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>防腐层代码只需要进行如下更新，就可以保障组件层代码无需修改，请注意这时 getMemoryUsagePercent 无需进行任何修改。</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">import</span> <span class="token punctuation">{</span> map<span class="token punctuation">,</span> mergeMap<span class="token punctuation">,</span> Observable<span class="token punctuation">,</span> lastValue <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"rxjs"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> fromFetch <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"rxjs/fetch"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getMemoryObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Observable<span class="token operator">&lt;</span><span class="token punctuation">{</span>  free<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  usage<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">fromFetch</span><span class="token punctuation">(</span><span class="token string">"/api/v3/memory"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>    <span class="token function">mergeMap</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> data<span class="token punctuation">.</span>data<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getMemoryFreeObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Observable<span class="token operator">&lt;</span><span class="token keyword">number</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">getMemoryObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> data<span class="token punctuation">.</span>free<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getMemoryUsageObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Observable<span class="token operator">&lt;</span><span class="token keyword">number</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">getMemoryObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> data<span class="token punctuation">.</span>usage<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getMemoryUsagePercent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Promise<span class="token operator">&lt;</span><span class="token keyword">number</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">lastValue</span><span class="token punctuation">(</span>    <span class="token function">getMemoryObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>      <span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> usage<span class="token punctuation">,</span> free <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span>usage <span class="token operator">/</span> <span class="token punctuation">(</span>usage <span class="token operator">+</span> free<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h6 id="多版本共存使用"><a href="#多版本共存使用" class="headerlink" title="多版本共存使用"></a>多版本共存使用</h6><p>当前端代码需要在多套环境下部署时，部分环境下 v3 的接口可用，而部分环境下只有 v2 的接口部署，此时我们依然可以在防腐层屏蔽环境的差异。<br><img src="https://www.xieyadong.com/markdown/147622974-cc8b2bcf-fdc5-4407-b9fa-66aa47e514c2.webp" alt="版本共存"></p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">import</span> <span class="token punctuation">{</span> forkJoin<span class="token punctuation">,</span> map<span class="token punctuation">,</span> mergeMap<span class="token punctuation">,</span> Observable<span class="token punctuation">,</span> race <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"rxjs"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> fromFetch <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"rxjs/fetch"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getMemoryLegacyObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Observable<span class="token operator">&lt;</span><span class="token punctuation">{</span>  free<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  usage<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> legacyUsage <span class="token operator">=</span> <span class="token function">fromFetch</span><span class="token punctuation">(</span><span class="token string">"/api/v2/memory/usage"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>    <span class="token function">mergeMap</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> legacyFree <span class="token operator">=</span> <span class="token function">fromFetch</span><span class="token punctuation">(</span><span class="token string">"/api/v2/memory/free"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>    <span class="token function">mergeMap</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">forkJoin</span><span class="token punctuation">(</span><span class="token punctuation">[</span>legacyUsage<span class="token punctuation">,</span> legacyFree<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>usage<span class="token punctuation">,</span> free<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>    free<span class="token punctuation">:</span> free<span class="token punctuation">.</span>data<span class="token punctuation">.</span>free<span class="token punctuation">,</span>    usage<span class="token punctuation">:</span> usage<span class="token punctuation">.</span>data<span class="token punctuation">.</span>usage<span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getMemoryObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Observable<span class="token operator">&lt;</span><span class="token punctuation">{</span>  free<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  usage<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> current <span class="token operator">=</span> <span class="token function">fromFetch</span><span class="token punctuation">(</span><span class="token string">"/api/v3/memory"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>    <span class="token function">mergeMap</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> data<span class="token punctuation">.</span>data<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">race</span><span class="token punctuation">(</span><span class="token function">getMemoryLegacyObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> current<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getMemoryFreeObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Observable<span class="token operator">&lt;</span><span class="token keyword">number</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">getMemoryObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> data<span class="token punctuation">.</span>free<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getMemoryUsageObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Observable<span class="token operator">&lt;</span><span class="token keyword">number</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">getMemoryObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> data<span class="token punctuation">.</span>usage<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getMemoryUsagePercent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Promise<span class="token operator">&lt;</span><span class="token keyword">number</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">lastValue</span><span class="token punctuation">(</span>    <span class="token function">getMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>      <span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> usage<span class="token punctuation">,</span> free <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span>usage <span class="token operator">/</span> <span class="token punctuation">(</span>usage <span class="token operator">+</span> free<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>通过 race 操作符，当 v2 与 v3 任何一个版本的接口可用时，防腐层都可以正常工作，在组件层无需再关注接口受环境的影响。</p><h6 id="额外应用"><a href="#额外应用" class="headerlink" title="额外应用"></a>额外应用</h6><p>防腐层不仅仅是多了一层对接口的封装与隔离，它还能起到以下作用。</p><h6 id="概念映射"><a href="#概念映射" class="headerlink" title="概念映射"></a>概念映射</h6><p>接口语义与前端需要数据的语义有时并不能完全对应，当在组件层直接调用接口时，所有开发者都需要对接口与界面的语义映射足够了解。有了防腐层后，防腐层提供的调用方法包含了数据的真实语义，减少了开发者的二次理解成本。</p><h6 id="格式适配"><a href="#格式适配" class="headerlink" title="格式适配"></a>格式适配</h6><p>在很多情况下，接口返回的数据结构与格式与前端需要的数据格式并不符合，通过在防腐层增加数据转换逻辑，可以降低接口数据对业务代码的入侵。在以上的案例里，我们封装了 getMemoryUsagePercent 的数据返回，使得组件层可以直接使用百分比数据，而不需要再次进行转换。</p><h6 id="接口缓存"><a href="#接口缓存" class="headerlink" title="接口缓存"></a>接口缓存</h6><p>对于多种业务依赖同一接口的情况，我们可以通过防腐层增加缓存逻辑，从而有效降低接口的调用压力。</p><p>与格式适配类似，将缓存逻辑封装在防腐层可以避免组件层对数据的二次缓存，并可以对缓存数据集中管理，降低代码的复杂度，一个简单的缓存示例如下。</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name">CacheService</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> cache<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>key<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">any</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">of</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">fromFetch</span><span class="token punctuation">(</span><span class="token string">"/api/v3/memory"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>        <span class="token function">mergeMap</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> data<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">tap</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>cache <span class="token operator">=</span> data<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h6 id="稳定性兜底"><a href="#稳定性兜底" class="headerlink" title="稳定性兜底"></a>稳定性兜底</h6><p>当接口稳定性较差时，通常的做法是在组件层对 response error 的情况进行处理，这种兜底逻辑通常比较复杂，组件层的维护成本会很高。我们可以通过防腐层对稳定性进行兜底，当接口出错时可以返回兜底业务数据，由于兜底数据统一维护在防腐层，后续的测试与修改也会更加方便。在上文中的多版本共存的防腐层中，增加以下代码，此时即使 v2 和 v3 接口都无法返回数据，前端仍然可以保持可用。</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">return</span> <span class="token function">race</span><span class="token punctuation">(</span><span class="token function">getMemoryLegacy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> current<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>  <span class="token operator">+</span><span class="token function">catchError</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">of</span><span class="token punctuation">(</span><span class="token punctuation">{</span> usage<span class="token punctuation">:</span> <span class="token string">"-"</span><span class="token punctuation">,</span> free<span class="token punctuation">:</span> <span class="token string">"-"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍在 DDD 中上下文协作中的防腐层的基本原理和概念，并介绍其在前端生态中的实践。并且使用 RxJs 实现防腐层的代码示例。RxJS 在防腐层构建场景下提供的更多的是 Observable 化的能力。改造后的前端架构将不再直接依赖接口实现，不会入侵现有前端数据层设计，还可以承担概念映射、格式适配、接口缓存、稳定性兜底等能力。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTY5MDMxNA==&amp;mid=2455759990&amp;idx=1&amp;sn=e07d74e7447d89572cac6b3702af63ae&amp;chksm=8c686a53bb1fe3453d7a783aec40a0d1efebc5f3bf742dc4129d37b818118aa6f78c7ccfd467&amp;scene=27#wechat_redirect">领域驱动设计</a></li><li><a href="https://www.bilibili.com/video/BV1C34y167NR/?zw">基于 Observable 构建稳健前端应用</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> DDD </tag>
            
            <tag> 领域驱动设计 </tag>
            
            <tag> RxJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 组件性能优化</title>
      <link href="2022/11/15/react-zu-jian-xing-neng-you-hua/"/>
      <url>2022/11/15/react-zu-jian-xing-neng-you-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="React-组件性能优化"><a href="#React-组件性能优化" class="headerlink" title="React 组件性能优化"></a>React 组件性能优化</h1><p>React 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以我们的业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）</p><p>渲染（Render）何时会被触发</p><p>○ 组件挂载<br>React 组件构建并将 DOM 元素插入页面的过程称为挂载。当组件首次渲染的时候会调用 render，这个过程不可避免。</p><p>○ setState() 方法被调用<br>setState 是 React 中最常用的命令，通常情况下，执行 setState 会触发 render。但是这里有个点值得关注，执行 setState 的时候一定会重新渲染吗？答案是不一定。当 setState 传入 null 的时候或者 state 的值没有发生改变时，并不会触发 render</p><p>○ 父组件重新渲染<br>只要父组件重新渲染了，即使传入子组件的 props 未发生变化，那么未做处理的子组件也会重新渲染，进而触发 render。</p><p>优化点：<br>1、不必要的更新是性能优化的基础；<br>2、减少计算的量。主要减少重复计算，对于函数式组件来说，每次 render 都会重新从头开始函数调用。</p><h3 id="React-hooks-重复渲染的逻辑"><a href="#React-hooks-重复渲染的逻辑" class="headerlink" title="React hooks 重复渲染的逻辑"></a>React hooks 重复渲染的逻辑</h3><p>一个组件重新重新渲染，一般三种情况：</p><p>a. 要么是组件自己的状态改变</p><p>b. 要么是父组件重新渲染，导致子组件重新渲染，但是父组件的 props 没有改变</p><p>c. 要么是父组件重新渲染，导致子组件重新渲染，但是父组件传递的 props 改变</p><h4 id="1-父组件使用-hooks，子组件使用类组件"><a href="#1-父组件使用-hooks，子组件使用类组件" class="headerlink" title="1.父组件使用 hooks，子组件使用类组件"></a>1.父组件使用 hooks，子组件使用类组件</h4><p>父组件</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>value<span class="token punctuation">,</span> setValue<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>div<span class="token operator">></span>        state<span class="token punctuation">{</span>state<span class="token punctuation">.</span>a<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span>state<span class="token punctuation">.</span>b<span class="token punctuation">}</span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>Button        type<span class="token operator">=</span><span class="token string">"default"</span>        onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//@ts-ignore</span>          <span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//@ts-ignore</span>          <span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> <span class="token string">"state"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token operator">></span>        测试      <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>      <span class="token operator">&lt;</span>hr <span class="token operator">/</span><span class="token operator">></span>      <span class="token operator">&lt;</span>div<span class="token operator">></span>value<span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>Button        type<span class="token operator">=</span><span class="token string">"default"</span>        onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token function">setValue</span><span class="token punctuation">(</span>value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token operator">></span>        测试      <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>      <span class="token operator">&lt;</span>Demo value<span class="token operator">=</span><span class="token punctuation">{</span>state<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>子组件：</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token operator">&lt;</span>Props<span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span> props <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"demo render"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token operator">&lt;</span>div<span class="token operator">></span>        <span class="token punctuation">{</span>props<span class="token punctuation">.</span>value<span class="token punctuation">.</span>a<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>value<span class="token punctuation">.</span>b<span class="token punctuation">}</span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结论：父组件(hook)每次更新，都会导出一个新的 state 和 value 对象,子组件肯定会更新（如果不做特殊处理）</p><h4 id="2-父组件使用-hooks-子组件使用-class-PureComponent"><a href="#2-父组件使用-hooks-子组件使用-class-PureComponent" class="headerlink" title="2. 父组件使用 hooks,子组件使用 class PureComponent"></a>2. 父组件使用 hooks,子组件使用 class PureComponent</h4><p>父组件代码跟上面一样，子组件使用 PureComponent:</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>PureComponent</span><span class="token operator">&lt;</span>Props<span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span> props <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"demo render"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token operator">&lt;</span>div<span class="token operator">></span>        <span class="token punctuation">{</span>props<span class="token punctuation">.</span>value<span class="token punctuation">.</span>a<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>value<span class="token punctuation">.</span>b<span class="token punctuation">}</span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结论：结论同上，依赖的 props 改变了，因为父组件是 hook 模式，每次更新都是直接导出新的 value 和 state.</p><h4 id="3-hook-的-setState-和-类组件的-setState-有什么不一样"><a href="#3-hook-的-setState-和-类组件的-setState-有什么不一样" class="headerlink" title="3. hook 的 setState 和 类组件的 setState 有什么不一样"></a>3. hook 的 setState 和 类组件的 setState 有什么不一样</h4><p>class 的 setState，如果你传入的是对象，那么就会被异步合并，如果传入的是函数，那么就会立马执行替换，而 hook 的 setState 是直接替换.<br>实践：</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>value<span class="token punctuation">,</span> setValue<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>div<span class="token operator">></span>        state<span class="token punctuation">{</span>state<span class="token punctuation">.</span>a<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span>state<span class="token punctuation">.</span>b<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span>state<span class="token punctuation">.</span>c<span class="token punctuation">}</span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>Button        type<span class="token operator">=</span><span class="token string">"default"</span>        onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//@ts-ignore</span>          <span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//@ts-ignore</span>          <span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> b<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> <span class="token string">"state"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token operator">></span>        测试      <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>      <span class="token operator">&lt;</span>hr <span class="token operator">/</span><span class="token operator">></span>      <span class="token operator">&lt;</span>div<span class="token operator">></span>value<span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>Button        type<span class="token operator">=</span><span class="token string">"default"</span>        onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token function">setValue</span><span class="token punctuation">(</span>value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token operator">></span>        测试      <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>      <span class="token operator">&lt;</span>Demo value<span class="token operator">=</span><span class="token punctuation">{</span>state<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>结论：class 的 setState，如果你传入的是对象，那么就会被异步合并，如果传入的是函数，那么就会立马执行替换，而 hook 的 setState 是直接替换。</p><h4 id="4-父组件使用-class-子组件使用-hook"><a href="#4-父组件使用-class-子组件使用-hook" class="headerlink" title="4. 父组件使用 class 子组件使用 hook"></a>4. 父组件使用 class 子组件使用 hook</h4><p>父组件:</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>PureComponent</span> <span class="token punctuation">{</span>  state <span class="token operator">=</span> <span class="token punctuation">{</span>    count<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  onClick <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span> count <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      count<span class="token punctuation">:</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span> count <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"father render"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token operator">&lt;</span>div<span class="token operator">></span>        <span class="token operator">&lt;</span>Demo count<span class="token operator">=</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>        <span class="token operator">&lt;</span>Button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>onClick<span class="token punctuation">}</span><span class="token operator">></span>测试<span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>子组件</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name">Props</span> <span class="token punctuation">{</span>  count<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span>props<span class="token punctuation">:</span> Props<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> <span class="token string">"props"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">></span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>结论：父组件(class 组件)调用 setState,刷新自身，然后传递给 hooks 子组件，然后子组件重新调用，更新。</p><h4 id="5-hook-setState-每次都是相同的值"><a href="#5-hook-setState-每次都是相同的值" class="headerlink" title="5. hook,setState 每次都是相同的值"></a>5. hook,setState 每次都是相同的值</h4><pre class=" language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>PureComponent</span> <span class="token punctuation">{</span>  state <span class="token operator">=</span> <span class="token punctuation">{</span>    count<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    value<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  onClick <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span> value <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      value<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span> count<span class="token punctuation">,</span> value <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"father render"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token operator">&lt;</span>div<span class="token operator">></span>        <span class="token operator">&lt;</span>Demo count<span class="token operator">=</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>        <span class="token punctuation">{</span>value<span class="token punctuation">}</span>        <span class="token operator">&lt;</span>Button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>onClick<span class="token punctuation">}</span><span class="token operator">></span>测试<span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结论：由于每次设置的值都是一样的（都是 1），hooks 不会更新，同 class。</p><h4 id="6-父组件和子组件都使用-hook，父组件传递-count，子组件使用-count，父组件传入-count-给子组件"><a href="#6-父组件和子组件都使用-hook，父组件传递-count，子组件使用-count，父组件传入-count-给子组件" class="headerlink" title="6. 父组件和子组件都使用 hook，父组件传递 count，子组件使用 count，父组件传入 count 给子组件"></a>6. 父组件和子组件都使用 hook，父组件传递 count，子组件使用 count，父组件传入 count 给子组件</h4><pre class=" language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>value<span class="token punctuation">,</span> setValue<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"father render"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>Demo count<span class="token operator">=</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>      <span class="token operator">&lt;</span>div<span class="token operator">></span>value<span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>Button        onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token function">setValue</span><span class="token punctuation">(</span>value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token operator">></span>        测试      <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>子组件使用 count</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span>props<span class="token punctuation">:</span> Props<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> <span class="token string">"props"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">></span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>结论：父组件更新了 value，导致子组件也会重复渲染。</p><h4 id="7-子组件使用了-memo-子组件并没有触发更新"><a href="#7-子组件使用了-memo-子组件并没有触发更新" class="headerlink" title="7. 子组件使用了 memo,子组件并没有触发更新"></a>7. 子组件使用了 memo,子组件并没有触发更新</h4><pre class=" language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span>props<span class="token punctuation">:</span> Props<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> <span class="token string">"props"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">></span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">memo</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>优化点：<br>React.memo、useMemo、<br>useCallback：useCallback 就是返回一个函数，只有在依赖项发生变化的时候才会更新（返回一个新的函数）</p><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><h3 id="1-类组件"><a href="#1-类组件" class="headerlink" title="1. 类组件"></a>1. 类组件</h3><p>主要是<code>shouldComponentUpdate</code>和<code>PureComponent</code>这两个 API 所提供的解决思路都是<strong>为了减少重新 render 的次数</strong>，主要是减少父组件更新而子组件也更新的情况，虽然也可以在 state 更新的时候阻止当前组件渲染，如果要这么做的话，证明你这个属性不适合作为 state，而应该作为静态属性或者放在 class 外面作为一个简单的变量 。</p><h3 id="2-函数式组件"><a href="#2-函数式组件" class="headerlink" title="2.函数式组件"></a>2.函数式组件</h3><h4 id="2-1-React-memo"><a href="#2-1-React-memo" class="headerlink" title="2.1 React.memo"></a>2.1 React.memo</h4><p>通过 <code>React.memo</code> 包裹的组件在 props 不变的情况下，这个被包裹的组件是不会重新渲染的，会直接复用最近一次渲染的结果。这个效果基本跟类组件里面的 PureComponent 效果极其类似，只是前者用于函数组件，后者用于类组件</p><p>原写法：</p><pre class=" language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// index.js</span><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"react"</span><span class="token punctuation">;</span><span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">"react-dom"</span><span class="token punctuation">;</span><span class="token keyword">import</span> Child <span class="token keyword">from</span> <span class="token string">"./child"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>title<span class="token punctuation">,</span> setTitle<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">"这是一个 title"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">"App"</span><span class="token operator">></span>      <span class="token operator">&lt;</span>h1<span class="token operator">></span><span class="token punctuation">{</span>title<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTitle</span><span class="token punctuation">(</span><span class="token string">"title 已经改变"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>改名字<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>      <span class="token operator">&lt;</span>Child name<span class="token operator">=</span><span class="token string">"桃桃"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>Child<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> rootElement <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> rootElement<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在同级目录有一个 child.js</p><pre class=" language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// child.js</span><span class="token keyword">import</span> React <span class="token keyword">from</span><span class="token string">"react"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>name<span class="token punctuation">)</span>  <span class="token keyword">return</span><span class="token operator">&lt;</span>h1<span class="token operator">></span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span><span class="token punctuation">}</span>exportdefault Child</code></pre><p>优化后的 child 组件</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">import</span> React <span class="token keyword">from</span><span class="token string">"react"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>name<span class="token punctuation">)</span>  <span class="token keyword">return</span><span class="token operator">&lt;</span>h1<span class="token operator">></span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span><span class="token punctuation">}</span>exportdefault React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span>Child<span class="token punctuation">)</span></code></pre><h5 id="React-memo-高级用法"><a href="#React-memo-高级用法" class="headerlink" title="React.memo 高级用法"></a>React.memo 高级用法</h5><p>默认情况下其只会对 props 的复杂对象做浅层对比(浅层对比就是只会对比前后两次 props 对象引用是否相同，不会对比对象里面的内容是否相同)，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。</p><p>React 官网 areEqual 返回 true 表示相等。</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/* 使用 props 渲染 */</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">areEqual</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> nextProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/*  如果把 nextProps 传入 render 方法的返回结果与  将 prevProps 传入 render 方法的返回结果一致则返回 true，  否则返回 false  */</span><span class="token punctuation">}</span>exportdefault React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span>MyComponent<span class="token punctuation">,</span> areEqual<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="2-2-useCallback"><a href="#2-2-useCallback" class="headerlink" title="2.2 useCallback"></a>2.2 useCallback</h4><p>首先看代码</p><p>父组件 index.js</p><pre class=" language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// index.js</span><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"react"</span><span class="token punctuation">;</span><span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">"react-dom"</span><span class="token punctuation">;</span><span class="token keyword">import</span> Child <span class="token keyword">from</span> <span class="token string">"./child"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>title<span class="token punctuation">,</span> setTitle<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">"这是一个 title"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>subtitle<span class="token punctuation">,</span> setSubtitle<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">"我是一个副标题"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> callback <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">setTitle</span><span class="token punctuation">(</span><span class="token string">"标题改变了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">"App"</span><span class="token operator">></span>      <span class="token operator">&lt;</span>h1<span class="token operator">></span><span class="token punctuation">{</span>title<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>      <span class="token operator">&lt;</span>h2<span class="token operator">></span><span class="token punctuation">{</span>subtitle<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setSubtitle</span><span class="token punctuation">(</span><span class="token string">"副标题改变了"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>改副标题<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>      <span class="token operator">&lt;</span>Child onClick<span class="token operator">=</span><span class="token punctuation">{</span>callback<span class="token punctuation">}</span> name<span class="token operator">=</span><span class="token string">"桃桃"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> rootElement <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> rootElement<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>子组件 child.js</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">"react"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span><span class="token operator">></span>      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>onClick<span class="token punctuation">}</span><span class="token operator">></span>改标题<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>      <span class="token operator">&lt;</span>h1<span class="token operator">></span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">default</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span>Child<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在函数式组件里每次重新渲染，函数组件都会重头开始重新执行，那么这两次创建的 callback 函数肯定发生了改变，所以导致了子组件重新渲染。</p><p>useCallback 使用方法</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">const</span> callback <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token function">doSomething</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> memoizedCallback <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>把函数以及依赖项作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，这个 memoizedCallback 只有在依赖项有变化的时候才会更新。</p><p>那么可以将 index.js 修改为这样：</p><pre class=" language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// index.js</span><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useCallback <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"react"</span><span class="token punctuation">;</span><span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">"react-dom"</span><span class="token punctuation">;</span><span class="token keyword">import</span> Child <span class="token keyword">from</span> <span class="token string">"./child"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>title<span class="token punctuation">,</span> setTitle<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">"这是一个 title"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>subtitle<span class="token punctuation">,</span> setSubtitle<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">"我是一个副标题"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> callback <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">setTitle</span><span class="token punctuation">(</span><span class="token string">"标题改变了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 通过 useCallback 进行记忆 callback，并将记忆的 callback 传递给 Child</span>  <span class="token keyword">const</span> memoizedCallback <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">"App"</span><span class="token operator">></span>      <span class="token operator">&lt;</span>h1<span class="token operator">></span><span class="token punctuation">{</span>title<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>      <span class="token operator">&lt;</span>h2<span class="token operator">></span><span class="token punctuation">{</span>subtitle<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setSubtitle</span><span class="token punctuation">(</span><span class="token string">"副标题改变了"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>改副标题<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>      <span class="token operator">&lt;</span>Child onClick<span class="token operator">=</span><span class="token punctuation">{</span>memoizedCallback<span class="token punctuation">}</span> name<span class="token operator">=</span><span class="token string">"桃桃"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> rootElement <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> rootElement<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这样我们就可以看到只会在首次渲染的时候打印出桃桃，当点击改副标题和改标题的时候是不会打印桃桃的。</p><p>如果我们的 callback 传递了参数，当参数变化的时候需要让它重新添加一个缓存，可以将参数放在 useCallback 第二个参数的数组中，作为依赖的形式，使用方式跟 useEffect 类似。</p><h4 id="2-3-useMemo"><a href="#2-3-useMemo" class="headerlink" title="2.3 useMemo"></a>2.3 useMemo</h4><p>对于如何减少计算的量，就是 useMemo 来做的，接下来我们看例子。</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> setNum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 一个非常耗时的一个计算函数</span>  <span class="token comment" spellcheck="true">// result 最后返回的值是 49995000</span>  <span class="token keyword">function</span> <span class="token function">expensiveFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      result <span class="token operator">+</span><span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 49995000</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">const</span> base <span class="token operator">=</span> <span class="token function">expensiveFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">"App"</span><span class="token operator">></span>      <span class="token operator">&lt;</span>h1<span class="token operator">></span>count：<span class="token punctuation">{</span>num<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setNum</span><span class="token punctuation">(</span>num <span class="token operator">+</span> base<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个例子功能很简单，就是点击 +1 按钮，然后会将现在的值(num) 与 计算函数 (expensiveFn) 调用后的值相加，然后将和设置给 num 并显示出来，在控制台会输出 49995000。</p><h5 id="可能产生性能问题"><a href="#可能产生性能问题" class="headerlink" title="可能产生性能问题"></a>可能产生性能问题</h5><p>就算是一个看起来很简单的组件，也有可能产生性能问题，通过这个最简单的例子来看看还有什么值得优化的地方。</p><p>首先我们把 expensiveFn 函数当做一个计算量很大的函数(比如你可以把 i 换成 10000000)，然后当我们每次点击 +1 按钮的时候，都会重新渲染组件，而且都会调用 expensiveFn 函数并输出 49995000。由于每次调用 expensiveFn 所返回的值都一样，所以我们可以想办法将计算出来的值缓存起来，每次调用函数直接返回缓存的值，这样就可以做一些性能优化</p><h5 id="useMemo-做计算结果缓存"><a href="#useMemo-做计算结果缓存" class="headerlink" title="useMemo 做计算结果缓存"></a>useMemo 做计算结果缓存</h5><p>首先介绍一下 useMemo 的基本的使用方法，详细的使用方法可见</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">computeExpensiveValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 计算量很大的代码</span>  <span class="token keyword">return</span> xxx<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> memoizedValue <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span>computeExpensiveValue<span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>useMemo 的第一个参数就是一个函数，这个函数返回的值会被缓存起来，同时这个值会作为 useMemo 的返回值，第二个参数是一个数组依赖，如果数组里面的值有变化，那么就会重新去执行第一个参数里面的函数，并将函数返回的值缓存起来并作为 useMemo 的返回值 。</p><p>了解了 useMemo 的使用方法，然后就可以对上面的例子进行优化，优化代码如下：</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> setNum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">expensiveFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      result <span class="token operator">+</span><span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">const</span> base <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span>expensiveFn<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">"App"</span><span class="token operator">></span>      <span class="token operator">&lt;</span>h1<span class="token operator">></span>count：<span class="token punctuation">{</span>num<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setNum</span><span class="token punctuation">(</span>num <span class="token operator">+</span> base<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>执行上面的代码，然后现在可以观察无论我们点击 +1 多少次，只会输出一次 49995000，这就代表 expensiveFn 只执行了一次，达到了我们想要的效果.</p><p>useMemo 的使用场景主要是用来缓存计算量比较大的函数结果，可以避免不必要的重复计算，有过 vue 的使用经历同学可能会觉得跟 Vue 里面的计算属性有异曲同工的作用。</p><p>不过另外提醒两点：</p><p>一、如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值；</p><p>二、计算量如果很小的计算函数，也可以选择不使用 useMemo，因为这点优化并不会作为性能瓶颈的要点，反而可能使用错误还会引起一些性能问题。</p><h2 id="React-懒加载"><a href="#React-懒加载" class="headerlink" title="React 懒加载"></a>React 懒加载</h2><h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><pre class=" language-ts"><code class="language-ts"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Suspense <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"react"</span><span class="token punctuation">;</span><span class="token keyword">const</span> OtherComponent <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"./OtherComponent"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>Suspense fallback<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&lt;</span>div<span class="token operator">></span>Loading<span class="token operator">...</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">}</span><span class="token operator">></span>        <span class="token operator">&lt;</span>OtherComponent <span class="token operator">/</span><span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>Suspense<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在 React 16.6 中实现了 lazy 和 suspense，可以直接来做懒加载。在上述代码中，通过<code>import()</code>、<code>React.lazy</code>、<code>Suspense</code>共同一起实现了 React 的懒加载。</p><h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><p>React.lazy 的源码实现如下：</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">function</span> lazy<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> R<span class="token operator">></span><span class="token punctuation">(</span>ctor<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> Thenable<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> R<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">:</span> LazyComponent<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> lazyType <span class="token operator">=</span> <span class="token punctuation">{</span>    $$<span class="token keyword">typeof</span><span class="token punctuation">:</span> REACT_LAZY_TYPE<span class="token punctuation">,</span>    _ctor<span class="token punctuation">:</span> ctor<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// React uses these fields to store the result.</span>    _status<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>    _result<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> lazyType<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以看到其返回了一个 LazyComponent 对象。</p><p>而对于 LazyComponent 对象的解析：</p><pre class=" language-ts"><code class="language-ts"><span class="token operator">...</span><span class="token keyword">case</span> LazyComponent<span class="token punctuation">:</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> elementType <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>elementType<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">mountLazyComponent</span><span class="token punctuation">(</span>    current<span class="token punctuation">,</span>    workInProgress<span class="token punctuation">,</span>    elementType<span class="token punctuation">,</span>    updateExpirationTime<span class="token punctuation">,</span>    renderExpirationTime<span class="token punctuation">,</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">...</span></code></pre><pre class=" language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">mountLazyComponent</span><span class="token punctuation">(</span>  _current<span class="token punctuation">,</span>  workInProgress<span class="token punctuation">,</span>  elementType<span class="token punctuation">,</span>  updateExpirationTime<span class="token punctuation">,</span>  renderExpirationTime<span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token operator">...</span>  <span class="token keyword">let</span> Component <span class="token operator">=</span> <span class="token function">readLazyComponentType</span><span class="token punctuation">(</span>elementType<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">...</span><span class="token punctuation">}</span></code></pre><pre class=" language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// Pending = 0, Resolved = 1, Rejected = 2</span><span class="token keyword">export</span> <span class="token keyword">function</span> readLazyComponentType<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>lazyComponent<span class="token punctuation">:</span> LazyComponent<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">:</span> T <span class="token punctuation">{</span>  <span class="token keyword">const</span> status <span class="token operator">=</span> lazyComponent<span class="token punctuation">.</span>_status<span class="token punctuation">;</span>  <span class="token keyword">const</span> result <span class="token operator">=</span> lazyComponent<span class="token punctuation">.</span>_result<span class="token punctuation">;</span>  <span class="token keyword">switch</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> Resolved<span class="token punctuation">:</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> Component<span class="token punctuation">:</span> T <span class="token operator">=</span> result<span class="token punctuation">;</span>      <span class="token keyword">return</span> Component<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">case</span> Rejected<span class="token punctuation">:</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> error<span class="token punctuation">:</span> mixed <span class="token operator">=</span> result<span class="token punctuation">;</span>      <span class="token keyword">throw</span> error<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">case</span> Pending<span class="token punctuation">:</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> thenable<span class="token punctuation">:</span> Thenable<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> mixed<span class="token operator">></span> <span class="token operator">=</span> result<span class="token punctuation">;</span>      <span class="token keyword">throw</span> thenable<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// lazyComponent 首次被渲染</span>      lazyComponent<span class="token punctuation">.</span>_status <span class="token operator">=</span> Pending<span class="token punctuation">;</span>      <span class="token keyword">const</span> ctor <span class="token operator">=</span> lazyComponent<span class="token punctuation">.</span>_ctor<span class="token punctuation">;</span>      <span class="token keyword">const</span> thenable <span class="token operator">=</span> <span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      thenable<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>        <span class="token punctuation">(</span>moduleObject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>lazyComponent<span class="token punctuation">.</span>_status <span class="token operator">===</span> Pending<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">const</span> defaultExport <span class="token operator">=</span> moduleObject<span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">;</span>            lazyComponent<span class="token punctuation">.</span>_status <span class="token operator">=</span> Resolved<span class="token punctuation">;</span>            lazyComponent<span class="token punctuation">.</span>_result <span class="token operator">=</span> defaultExport<span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>lazyComponent<span class="token punctuation">.</span>_status <span class="token operator">===</span> Pending<span class="token punctuation">)</span> <span class="token punctuation">{</span>            lazyComponent<span class="token punctuation">.</span>_status <span class="token operator">=</span> Rejected<span class="token punctuation">;</span>            lazyComponent<span class="token punctuation">.</span>_result <span class="token operator">=</span> error<span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// Handle synchronous thenables.</span>      <span class="token keyword">switch</span> <span class="token punctuation">(</span>lazyComponent<span class="token punctuation">.</span>_status<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> Resolved<span class="token punctuation">:</span>          <span class="token keyword">return</span> lazyComponent<span class="token punctuation">.</span>_result<span class="token punctuation">;</span>        <span class="token keyword">case</span> Rejected<span class="token punctuation">:</span>          <span class="token keyword">throw</span> lazyComponent<span class="token punctuation">.</span>_result<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      lazyComponent<span class="token punctuation">.</span>_result <span class="token operator">=</span> thenable<span class="token punctuation">;</span>      <span class="token keyword">throw</span> thenable<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>从上述代码中可以看出，对于最初 <code>React.lazy()</code> 所返回的 <code>LazyComponent</code> 对象，其 _status 默认是 -1，所以首次渲染时，会进入 <code>readLazyComponentType</code> 函数中的 default 的逻辑，这里才会真正异步执行 <code>import(url)</code>操作，由于并未等待，随后会检查模块是否 Resolved，如果已经 Resolved 了（已经加载完毕）则直接返回<code>moduleObject.default</code>（动态加载的模块的默认导出），否则将通过 throw 将 thenable 抛出到上层。</p><h5 id="Suspense-原理"><a href="#Suspense-原理" class="headerlink" title="Suspense 原理"></a>Suspense 原理</h5><p>由于 React 捕获异常并处理的代码逻辑主要是在 throwException 中的逻辑，简单描述一下处理过程，React 捕获到异常之后，会判断异常是不是一个 thenable，如果是则会找到 SuspenseComponent ，如果 thenable 处于 pending 状态，则会将其 children 都渲染成 fallback 的值，一旦 thenable 被 resolve 则 SuspenseComponent 的子组件会重新渲染一次。</p><p>为了便于理解，我们也可以用 componentDidCatch 实现一个自己的 Suspense 组件，如下：</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name">Suspense</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  state <span class="token operator">=</span> <span class="token punctuation">{</span>    promise<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token function">componentDidCatch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 判断 err 是否是 thenable</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>      err <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>      <span class="token punctuation">(</span><span class="token keyword">typeof</span> err <span class="token operator">===</span> <span class="token string">"object"</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> err <span class="token operator">===</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>      <span class="token keyword">typeof</span> err<span class="token punctuation">.</span>then <span class="token operator">===</span> <span class="token string">"function"</span>    <span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> promise<span class="token punctuation">:</span> err <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        err<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            promise<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span> fallback<span class="token punctuation">,</span> children <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span> promise <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">{</span>promise <span class="token operator">?</span> fallback <span class="token punctuation">:</span> children<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="什么是thenable？？"><a href="#什么是thenable？？" class="headerlink" title="什么是thenable？？"></a>什么是<code>thenable</code>？？</h3><p>在 promise 的使用中，判断某个值是不是真正的 promise 是很关键的。<br>简单做法：我用 promise 构造函数，直接 new 一个 promise，就算是查它的类型，我直接使用 instanceof promise 来判断不就好了么？这有什么好讲的？<br>缺点：从其它浏览器窗口接到的 promise，这个 promise 可能与当前窗口不同，所以那种检查方式无法识别 promise 实例。<br>所以我们需要自己识别<br>then()作为 promise 的配套组件，我们只需要验证有没有 then()就可以了，所以，我们提出了 thenable 的概念<br>thenable：任何含有 then()方法的对象或函数。</p><p>它的结构是不是很像 promise，它们都有一个 then()。</p><p>所以，我们无法找出 promise 时，就退而求其次，先找类似 promise 的，也就是 thenable。</p><p>所以判断的时候判断他是不是 thenable 通过代码中的判断就可以。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="为什么-useCallback-和-useMemo-更加糟糕"><a href="#为什么-useCallback-和-useMemo-更加糟糕" class="headerlink" title="为什么 useCallback 和 useMemo 更加糟糕"></a>为什么 useCallback 和 useMemo 更加糟糕</h4><p>性能优化不是免费的，它们总是带来成本，但这并不总是带来好处来抵消成本,所以我们采用 useCallback 和 useMemo 做性能优化，应该是做到花费的成本大于收入的成本</p><p>首先，我们需要知道 useCallback,useMemo 本身也有开销。useCallback,useMemo 会「记住」一些值，同时在后续 render 时，将依赖数组中的值取出来和上一次记录的值进行比较，如果不相等才会重新执行回调函数，否则直接返回「记住」的值。这个过程本身就会消耗一定的内存和计算资源。因此，过度使用 useCallback,useMemo 可能会影响程序的性能,并且也加大了维护成本，毕竟代码更加复杂化了。</p><h4 id="什么时候使用-useMemo-和-useCallback？"><a href="#什么时候使用-useMemo-和-useCallback？" class="headerlink" title="什么时候使用 useMemo 和 useCallback？"></a>什么时候使用 useMemo 和 useCallback？</h4><p>使用 useMemo 和 useCallback 出于这两个目的</p><ol><li><p>保持引用相等<br>对于组件内部用到的 object、array、函数等，如果用在了其他 Hook 的依赖数组中，或者作为 props 传递给了下游组件，应该使用 useMemo 和 useCallback</p></li><li><p>自定义 Hook 中暴露出来的 object、array、函数等，都应该使用 useMemo 和 useCallback,以确保当值相同时，引用不发生变化（你可以理解成是第一种说法的衍生，即自定义 hooks 比作组件，因为一个函数组件 state 一变化就会重新执行函数）<br>昂贵的计算。<br>比如上面例子的 expensive 函数</p></li></ol><p>无需使用 useMemo 和 useCallback 的场景</p><p>如果返回的值是原始值： string, boolean, null, undefined, number, symbol（不包括动态声明的 Symbol），一般不需要使用 useMemo 和 useCallback<br>仅在组件内部用到的 object、array、函数等（没有作为 props 传递给子组件），且没有用到其他 Hook 的依赖数组中，一般不需要使用 useMemo 和 useCallback</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于性能瓶颈可能对于小项目遇到的比较少，毕竟计算量小、业务逻辑也不复杂，但是对于大项目，很可能是会遇到性能瓶颈的，但是对于性能优化有很多方面：网络、关键路径渲染、打包、图片、缓存等等方面，具体应该去优化 目前可以通过接入前端监控的方式，去排查相应的性能问题。 本次分享只介绍了性能优化中的冰山一角： React 组件性能优化。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://thoamsy.github.io/blogs/react-lazy/">React Lazy 的实现原理</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651557426&amp;idx=1&amp;sn=e2b6bee7bb8fcc9fdfaed14a82aeb0e8&amp;chksm=802559f3b752d0e59f27d17259ac31c658fd89fe87b2755079ec31c3d8696821226b7eba4bcd&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1584015775726&amp;sharer_shareid=827ddc86f3743a5ae1362c6a1314c273%23rd">React 函数式组件性能优化指南</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651557629&amp;idx=1&amp;sn=18a9e3bc2adb1b527ff482aa3e690ea2&amp;chksm=8025593cb752d02a07cbde1519bad7457109cb8ab966b046d3e6da53e5402165e15c97ff4dad&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1577448539461&amp;sharer_shareid=827ddc86f3743a5ae1362c6a1314c273%23rd">React 也能 “用上” computed 属性</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651557566&amp;idx=2&amp;sn=fea4e36daca905123fdf842af946844a&amp;chksm=8025597fb752d069e6c63f8a4268046b7b5810930c2e11f565016716e44226d4aa834af7901c&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1584016712520&amp;sharer_shareid=827ddc86f3743a5ae1362c6a1314c273%23rd">性能！！让你的 React 组件跑得再快一点</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-native</title>
      <link href="2022/11/04/react-native/"/>
      <url>2022/11/04/react-native/</url>
      
        <content type="html"><![CDATA[<h2 id="react-native"><a href="#react-native" class="headerlink" title="react-native"></a>react-native</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>React Native 可以让我们开发者使用 JavaScript 和 React 开发我们的应用，使用 React Native 的组件和 API 通过 JavaScriptCore 和 Native 之间进行交互，React Native 使用的基础组件和原生应用完全一致，使我们通过 JSX 的写法可以获得和用 Objective-C 或 Java 编写的应用几乎相同的体验</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li><p><strong>简单原理</strong></p><p>在 React Native 框架中，JSX 源码通过 React Native 框架编译后，通过对应平台的 Bridge 实现了与原生框架的通信。如果我们在程序中调用了 React Native 提供的 API，那么 React Native 框架就通过 Bridge 调用原生框架中的方法。 因为 React Native 的底层为 React 框架，所以如果是 UI 层的变更，那么就映射为虚拟 DOM 后进行 diff 算法，diff 算法计算出变动后的 JSON 数据，最终由 Native 层将此 JSON 数据映射渲染到原生 App 的页面元素上，最终实现了在项目中只需要控制 state 以及 props 的变更来引起 iOS 与 Android 平台的 UI 变更</p></li><li><p><strong>启动流程</strong></p><p>以 IOS 启动流程为例：</p><ol><li>创建 RCTRootView -&gt; 设置窗口根控制器的 View,把 RN 的 View 添加到窗口上显示</li><li>创建 RCTBridge -&gt; 桥接对象,管理 JS 和 OC 交互，做中转 JS 和 OC</li><li>创建 RCTBatchedBridge -&gt; 批量桥架对象，JS 和 OC 交互具体实现都在这个类中</li><li>执行[RCTBatchedBridge loadSource] -&gt; 加载 JS 源码</li><li>执行[RCTBatchedBridge initModulesWithDispatchGroup] -&gt; 创建 OC 模块表</li><li>执行[RCTJSCExecutor injectJSONText] -&gt; 往 JS 中插入 OC 模块表</li><li>执行完 JS 代码，回调 OC，调用 OC 中的组件</li><li>完成 UI 渲染</li></ol></li><li><p><strong>通信原理</strong></p><ol><li><p>Objective-C 和 JavaScript 两端都保存了一份配置表，里面标记了所 Objective-C 暴露给 JavaScript 的模块和方法。这样，无论是哪一方调用另一方的方法，实际上传递的数据只有 ModuleId、MethodId 和 Arguments 这三个元素，它们分别表示类、方法和方法参数，当 Objective-C 接收到这三个值后，就可以通过 runtime 唯一确定要调用的是哪个函数，然后调用这个函数。</p></li><li><p>Objective-C 调用 JavaScript：Objective-C 开辟一个单独的线程运行 JavaScript 代码，调用 JavaScript 可以直接发送事件</p></li><li><p>JavaScript 调用 Objective-C：在调用 Objective-C 代码时，JavaScript 会解析出方法的 moduleID、methodID 和 params 并放入到 MessageQueue 中，等待 Objective-C 主动拿走，或者超时后主动发送给 Objective-C。</p></li></ol></li></ul><h3 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h3><ul><li><p><strong>数据持久化</strong></p><ol><li><p>当存储一些用户信息数据或者需要保存一些信息到本地时，可以使用 React Native 提供的 AsyncStorage API 它是一个简单的、异步的、持久化的 Key-Value 存储系统，它对于 App 来说是全局性的。可用来代替 LocalStorage。在 iOS 上，AsyncStorage 在原生端的实现是把较小值存放在序列化的字典中，而把较大值写入单独的文件。在 Android 上，AsyncStorage 会尝试使用 RocksDB，或退而选择 SQLite。JS 代码提供了对原生实现的一个封装，以提供一个更清晰的 JS API、抛出真正的 Error 对象，以及简单的单项对象操作函数。每个方法都会返回一个 Promise 对象。</p><ol start="2"><li>因为 redux 的 store 数据存在内存中，所以当应用进程被杀掉以后，store 中的数据会消失所以需要把 store 中的数据存储到本地时，可以使用 redux 的中间件 redux-persist，他会在应用重启以后，恢复本地数据到 store 中</li></ol></li></ol></li><li><p><strong>网络请求</strong></p><p>React Native 提供了和 web 标准一致的 Fetch API，同样 React Native 中已经内置了 XMLHttpRequest API。一些基于 XMLHttpRequest 封装的第三方库也可以使用.</p></li><li><p><strong>三方和原生支持</strong></p><p>当有一些操作或组件，诸如文件下载，文件流操作，视频播放，图片上传等，React Native 不支持，或支持度很差时，这是就需要从社区搜索组件，解决问题，文件下载可以 使用 react-native-fs，文件流处理可以使用 fn-fetch-blob，视频播放可以使用 react-native-video 进行封装，便于使用，<br>此外当第三方组件都不能很好的支持项目时，原生的支持必不可少，比如地理定位，React Native 不支持国内环境，又不至于为了一个定位信息，引入一整个三方地图包，所以我们可以使用原生提供的方法，比如分享，原生集成了分享功能，我们不需要为了分享功能引入过多的三方 SDK 包，又比如图片选择上传，第三方的组件样式定制性很差，而且存在很多 bug，比如还有全局弹框。</p></li><li><p><strong>路由</strong></p></li></ul><p>React-native 的路由 react-navigation 和 react 单页应用的路由 react-router 有什么区别呢？</p><p>在 web 浏览器中，当用户点击某个链接时，该 url 就会被推倒浏览器的历史记录堆栈里面当用户店里返回按钮时，浏览器户从历史堆栈顶部删除正在访问的页面，因此当前页就成了以前访问过的页面，然而 React Native 没有像 Web 浏览器那样的内置全局历史堆栈。首先 SPA 网站路由，导航方式一般分为 history 路由和 hash 路由，对于基于 history 的路由，它通过 history.pushState 来修改 url（ 它只会将路由信息推入浏览器的历史导航栈里面，不会刷新页面，也不会向服务器发送请求），通过 popstate 事件来监听前进/后退事件.React-router 的实现主要是依赖了一个 window.history 加强版的 history 库，history 库导出了一个对象，其中，location 属性是对 window.location 的加强，listen 方法是注册一个监听（通过发布订阅模式实现的一个 transitionManager 注册监听，当发生路由跳转时，会将 location 传入到监听函数中）和提供 push，replace 等方法来修改历史记录栈的 State 并触发之前注册的监听事件。React-router 自己则包含 Router 路由容器组件，和 Route 路由栈组件，其中，Router 组件通过监听，来获得 location 对象不断变化的值，然后通过 react 16 新的 context Api 注入到 context.Provider 中，每个 Route 路由栈则通过 context.consumer 获得注入的 location 对象。</p><p>Route 中则通过当前配置的路由参数和 location 的参数是否匹配和其他一些规则，决定自己是否显示 React Native 中并没有 history 对象，但是可以在内存中模拟实现，而且实现方式和 history 是基本相同的 React Navigation 的 stack navigator 为应用提供了一种在屏幕之间切换并管理导航历史记录的方式。如果应用程序只使用一个 stack navigator ，则它在概念上类似于 Web 浏览器处理导航状态的方式 - 当用户与它进行交互时，应用程序会从导航堆栈中新增和删除页面，这会导致用户看到不同的页面。Web 浏览器和 React Navigation 工作原理的一个主要区别是：React Navigation 的 stack navigator 提供了在 Android 和 iOS 设备上，在堆栈中的路由之间导航时你期望的手势和动画。</p><h3 id="常见问题及解决方案"><a href="#常见问题及解决方案" class="headerlink" title="常见问题及解决方案"></a>常见问题及解决方案</h3><ul><li><p><strong>样式问题</strong></p><ol><li><p>阴影样式</p><p>React Native 安卓不支持阴影样式属性，可以是用第三方库 react-native-shadow 来解决，依赖 react-native-shadow 实现</p></li><li><p>边框样式</p><p>React Native 安卓不支持 dashed 或者 dotted 样式，IOS 支持也有部分问题，同样，可以使用 react-native-svg 进行绘制</p></li><li><p>渐变样式</p><p>不支持渐变样式设置，需要使用第三方插件 react-native-linear-gradient</p></li><li><p>边框宽度</p><p>在设置的边框或者高度小于 1 时，比如 0.5，会出现显示不出来的情况，不同平台和不同的屏幕像素密度会导致不同的结果，可搜索手机的设备像素比相关问题查看，一种 hack 的解决方式是设置 1 的高度，在设置 border-bottom 为 0.5。还可以是用 RN 的 StyleSheet.hairlineWidth 设置为平台最细的宽度</p></li><li><p>定位</p><p>React Native 不支持 fixed 定位，所以在实现诸如头部固定，按钮固定在底部，和其他常见 fixed 定位需求时，需要采用变通的方式，例如底部按钮，可采用 flex 布局，或者绝对定位的方式实现，但是如果页面有键盘弹出时，安卓的底部的定位元素会被键盘顶起，此时，可以配置安卓目录下的 windowSoftInputMode=”adjustNothing” 配置解决此问题</p></li></ol></li><li><p><strong>组件问题</strong></p><ol><li><p>Modal 组件</p><p>Android Modal 组件无法延伸到状态栏之后，导致 Modal 实现的弹框蒙层顶部会有一个白条，一种简单的解决办法是在 Modal 中，设置安卓的状态栏背景和 Modal 的背景颜色一致，然后设置状态栏文字颜色为白色，这种办法，会导致 Modal 弹出的时候，会有状态栏的闪动，体验不是很好，还有一种解决方式是封装安卓原生 Modal</p></li><li><p>TextInput 组件</p><p>React Native 版本 &lt;= 0.54 IOS Input 不能在 onChangText 事件对 value 属性进行正常赋值，所以只能通过升级版本来解决，但是 RN 版本的升级或造成很多依赖发生改变，出现不可控的情况，所以应尽量避免升级</p></li><li><p>Touchable</p><p>React Native 安卓 Touchable 类组件溢出不显示 bug,可利用 View 组件溢出可正常显示，在里面使用 Touchable 组件的 hack 方式</p></li><li><p>Picker</p><p>React Native 只有 DatePickerIOS ，Picker 组件使用起来也不便利，建议使用第三方组件 react-native-picker</p></li><li><p>SafeAreaView</p><p>SafeAreaView 的目的是让你在一个安全的可是区域渲染内容，具体来说就是因为目前有 iPhone X 这样的带有“刘海”的全面屏设备，所以需要避免内容渲染到不可见的“刘海”范围内。本组件目前仅支持 iOS 设备以及 iOS 11 或更高版本。但是在 IphoneXS 上，并不能正常显示，所以需要判断机型来针对设置</p></li><li><p>Toast</p><p>目前 React Native 只有 安卓有吐司提示，所以可以使用第三方库 react-native-root-toast 来替代安卓和 IOS，也可以使用 IOS 原生提供的 Toast 方法</p></li></ol></li><li><p><strong>其他问题</strong></p><ol><li><p>setTimeout</p><p>setTimeout 当应用进入后台以后 js 停止运行，会停止计时，但实际情况计时应该持续进行，一种解决方式可以只用时间戳，每次计算前后时间戳的差值，来达到目的</p></li><li><p>全局弹框</p><p>原生+RN+H5 的混合开发模式下，在 RN 跳转到原生，在跳转到 RN，或者其他复杂的情况下，路由会有几个层，此时，RN Home 页面的弹框监听或者其他方式，都不能实现让弹框显示在最上层，所以在实现如单点登录，登录失效，需要在任何页面弹出弹框的需求时，可以调用原生的弹框，因为，原生的弹框在最上层，所以可以任何位置调起弹框</p></li><li><p>设备识别</p><p>因为 iphoneXS 等机型的出现，第三方组件在识别机型时并不能识别出来，但是很多兼容处理需要针对 iphoneXS 来进行处理。因为 iphoneX XS XS Max 的屏幕分辨率各不一样，所以可以先判断是 IOS 设备，然后根据分辨率来判断机型。</p></li><li><p>键盘遮挡</p><p>手机上弹出的键盘常常会挡住当前的视图。KeybordAvioodingView 组件可以自动根据键盘的位置，调整自身的 position 或底部的 padding，以避免被遮挡。</p></li><li><p>路由重复跳转</p><p>在进行路由跳转时。如果点击过快，可能会出现路由栈中添加了两层路由，可以用路由的 navigate 方法替换 push 方法，因为 push 方法是直接向路由栈中添加路由，navigate 方法会根据路由栈是否有要跳转的路由来进行判断</p></li><li><p>地理定位</p><p>React Native 的地理定位对于国内用户来说是不可用的状态，所以可以使用高德或者百度的第三方库 或者使用原生提供的方法</p></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> react-native </tag>
            
            <tag> RN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typescript学习</title>
      <link href="2022/11/04/typescript-xue-xi/"/>
      <url>2022/11/04/typescript-xue-xi/</url>
      
        <content type="html"><![CDATA[<h4 id="一、TS-的优势"><a href="#一、TS-的优势" class="headerlink" title="一、TS 的优势"></a>一、TS 的优势</h4><ul><li><p>类型声明就是很好的文档；</p></li><li><p>增加代码的可读性和维护性；</p></li><li><p>提供最新的 JavaScipt 特性，建立更健壮的组件；</p></li></ul><h4 id="二、TS-基础"><a href="#二、TS-基础" class="headerlink" title="二、TS 基础"></a>二、TS 基础</h4><h5 id="TS-基础类型"><a href="#TS-基础类型" class="headerlink" title="TS 基础类型"></a>TS 基础类型</h5><pre><code>* boolean、number、string、array、元组、枚举、any、void、null和undefined、never* 例：元组 let x: [string, number] = ["hello", 0]</code></pre><h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><pre class=" language-TS"><code class="language-TS">    enum Colors { Red, Yellow, Blue }    Colors['Red'] === 0 // true  从0开始递增    Colors[0] === 'Red' // 相互映射    // 枚举事实上会编译成如下    var Color;    (function (Color) {        Color[Color["Red"] = 0] = "Red";        Color[Color["Yellow"] = 1] = "Yellow";        Color[Color["Blue"] = 2] = "Blue";    })(Color || (Color = {}));</code></pre><ul><li><p>手动赋值</p><p>枚举的值是可以二次赋值的，被重新赋值的后一项会接着上一项的 key 递增;</p><p>如果两个枚举值重复了，不会报错，但是值会被覆盖;</p><p>可以为小数或者负数，递增步数仍然为 1;</p><p>配合断言，可以让枚举不是数字;</p></li></ul><h6 id="接口及接口的高阶用法"><a href="#接口及接口的高阶用法" class="headerlink" title="接口及接口的高阶用法"></a>接口及接口的高阶用法</h6><pre><code>interface Dog {    color: string;    width: number;}</code></pre><ul><li>接口继承接口</li></ul><pre class=" language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name">Fa</span> <span class="token punctuation">{</span>  surname<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">interface</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Fa</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> obj<span class="token punctuation">:</span> Son <span class="token operator">=</span> <span class="token punctuation">{</span>  surname<span class="token punctuation">:</span> <span class="token string">"z"</span><span class="token punctuation">,</span>  name<span class="token punctuation">:</span> <span class="token string">"zc"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>接口继承类</li></ul><pre class=" language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name">Fa</span> <span class="token punctuation">{</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">suck</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">interface</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Fa</span> <span class="token punctuation">{</span>  <span class="token function">suck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h5><p>指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p><ul><li>泛型约束</li></ul><p>明确知道泛型有哪些属性和方法时候，可以通过 extends 进行泛型约束， 写在声明函数名的后面</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name">hasLengthProp</span> <span class="token punctuation">{</span>  length<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> Test<span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">hasLengthProp</span><span class="token operator">></span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> T<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>泛型还可以约束泛型,相当于泛型的继承</li></ul><h5 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h5><p>就是说声明两个同样的接口、类或者函数，会进行合并操作。</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name">Alarm</span> <span class="token punctuation">{</span>  price<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  <span class="token function">alert</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">interface</span> <span class="token class-name">Alarm</span> <span class="token punctuation">{</span>  weight<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  <span class="token function">alert</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 相当于</span><span class="token keyword">interface</span> <span class="token class-name">Alarm</span> <span class="token punctuation">{</span>  price<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  weight<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  <span class="token function">alert</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="奇淫技巧"><a href="#奇淫技巧" class="headerlink" title="奇淫技巧"></a>奇淫技巧</h5><ul><li>typeof - 获取变量的类型</li><li>keyof - 获取类型的键</li></ul><p>组合 typeof 与 keyof - 捕获键的名称</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">const</span> colors <span class="token operator">=</span> <span class="token punctuation">{</span>  red<span class="token punctuation">:</span> <span class="token string">"red"</span><span class="token punctuation">,</span>  blue<span class="token punctuation">:</span> <span class="token string">"blue"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span>type Colors <span class="token operator">=</span> keyof <span class="token keyword">typeof</span> colors<span class="token punctuation">;</span><span class="token keyword">let</span> color<span class="token punctuation">:</span> Colors<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 'red' | 'blue'</span>color <span class="token operator">=</span> <span class="token string">"red"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span>color <span class="token operator">=</span> <span class="token string">"blue"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span>color <span class="token operator">=</span> <span class="token string">"anythingElse"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Error</span></code></pre><ul><li>in - 遍历键名<br>特殊类型<br>嵌套接口类型</li></ul><pre class=" language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name">Producer</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>  cost<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  production<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">interface</span> <span class="token class-name">Province</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>  demand<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  price<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  producers<span class="token punctuation">:</span> Producer<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> data<span class="token punctuation">:</span> Province <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">"Asia"</span><span class="token punctuation">,</span>  demand<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span>  price<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>  producers<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"Byzantium"</span><span class="token punctuation">,</span> cost<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> production<span class="token punctuation">:</span> <span class="token number">9</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"Attalia"</span><span class="token punctuation">,</span> cost<span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span> production<span class="token punctuation">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"Sinope"</span><span class="token punctuation">,</span> cost<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> production<span class="token punctuation">:</span> <span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">interface</span> <span class="token class-name">Play</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>  type<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">interface</span> <span class="token class-name">Plays</span> <span class="token punctuation">{</span>  <span class="token punctuation">[</span>key<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">]</span><span class="token punctuation">:</span> Play<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> plays<span class="token punctuation">:</span> Plays <span class="token operator">=</span> <span class="token punctuation">{</span>  hamlet<span class="token punctuation">:</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"Hamlet"</span><span class="token punctuation">,</span> type<span class="token punctuation">:</span> <span class="token string">"tragedy"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token string">"as-like"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"As You Like It"</span><span class="token punctuation">,</span> type<span class="token punctuation">:</span> <span class="token string">"comedy"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  othello<span class="token punctuation">:</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"Othello"</span><span class="token punctuation">,</span> type<span class="token punctuation">:</span> <span class="token string">"tragedy"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h4 id="三、TS-高阶"><a href="#三、TS-高阶" class="headerlink" title="三、TS 高阶"></a>三、TS 高阶</h4><h5 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h5><p>TypeScript 允许你覆盖它的推断，并且能以你任何你想要的方式分析它，这种机制被称为「类型断言」。</p><p>例如：</p><pre class=" language-ts"><code class="language-ts">    <span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>        bar<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>        bas<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">const</span> foo<span class="token punctuation">:</span> Foo <span class="token operator">=</span> <span class="token punctuation">{</span>        foo<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>        foo<span class="token punctuation">.</span>bas <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li><p>双重断言</p><p>例如：以下的例子将会报错，尽管使用者已经使用了类型断言：</p></li></ul><pre class=" language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">handler</span><span class="token punctuation">(</span>event<span class="token punctuation">:</span> Event<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> element <span class="token operator">=</span> event as HTMLElement<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Error: 'Event' 和 'HTMLElement' 中的任何一个都不能赋值给另外一个</span><span class="token punctuation">}</span></code></pre><ul><li>如果你仍然想使用那个类型，你可以使用双重断言。首先断言成兼容所有类型的 any，编译器将不会报错：</li></ul><pre class=" language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">handler</span><span class="token punctuation">(</span>event<span class="token punctuation">:</span> Event<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> element <span class="token operator">=</span> event as <span class="token keyword">any</span> as HTMLElement<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span><span class="token punctuation">}</span></code></pre><ul><li>ps: TypeScript 是怎么确定单个断言是否足够<br>当 S 类型是 T 类型的子集，或者 T 类型是 S 类型的子集时，S 能被成功断言成 T。这是为了在进行类型断言时提供额外的安全性，完全毫无根据的断言是危险的，如果你想这么做，你可以使用 any。</li></ul><h5 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h5><pre><code>通常，你会得到一个类似于 Type string is not assignable to type 'foo' 的错误，如下：</code></pre><pre class=" language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">iTakeFoo</span><span class="token punctuation">(</span>foo<span class="token punctuation">:</span> <span class="token string">"foo"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">const</span> test <span class="token operator">=</span> <span class="token punctuation">{</span>  someProp<span class="token punctuation">:</span> <span class="token string">"foo"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">iTakeFoo</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>someProp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Error: Argument of type string is not assignable to parameter of type 'foo'</span></code></pre><p>这是由于 test 被推断为 { someProp: string }，我们可以采用一个简单的类型断言来告诉 TypeScript 你想推断的字面量：</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">iTakeFoo</span><span class="token punctuation">(</span>foo<span class="token punctuation">:</span> <span class="token string">"foo"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">const</span> test <span class="token operator">=</span> <span class="token punctuation">{</span>  someProp<span class="token punctuation">:</span> <span class="token string">"foo"</span> as <span class="token string">"foo"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">iTakeFoo</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>someProp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span></code></pre><p>或者使用类型注解的方式，来帮助 TypeScript 推断正确的类型：</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">iTakeFoo</span><span class="token punctuation">(</span>foo<span class="token punctuation">:</span> <span class="token string">"foo"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>type Test <span class="token operator">=</span> <span class="token punctuation">{</span>  someProp<span class="token punctuation">:</span> <span class="token string">"foo"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> test<span class="token punctuation">:</span> Test <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 推断 `someProp` 永远是 'foo'</span>  someProp<span class="token punctuation">:</span> <span class="token string">"foo"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">iTakeFoo</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>someProp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span></code></pre><h5 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h5><p>类型保护允许你使用更小范围下的对象类型。</p><ul><li>typeof</li><li>instanceof</li><li>in 操作符可以安全的检查一个对象上是否存在一个属性，它通常也被做为类型保护使用</li><li>字面量类型保护</li></ul><pre class=" language-ts"><code class="language-ts">type Foo <span class="token operator">=</span> <span class="token punctuation">{</span>  kind<span class="token punctuation">:</span> <span class="token string">"foo"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 字面量类型</span>  foo<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>type Bar <span class="token operator">=</span> <span class="token punctuation">{</span>  kind<span class="token punctuation">:</span> <span class="token string">"bar"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 字面量类型</span>  bar<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">doStuff</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> Foo <span class="token operator">|</span> Bar<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>arg<span class="token punctuation">.</span>kind <span class="token operator">===</span> <span class="token string">"foo"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Error</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 一定是 Bar</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Error</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>使用定义的类型保护（用户自定义方法）</li></ul><h5 id="类型别名和字面量类型"><a href="#类型别名和字面量类型" class="headerlink" title="类型别名和字面量类型"></a>类型别名和字面量类型</h5><ul><li>类型别名 alias</li><li>字面量类型<br>例如：在这里，我们创建了一个被称为 foo 变量，它仅接收一个字面量值为 Hello 的变量：</li></ul><pre class=" language-ts"><code class="language-ts"><span class="token keyword">let</span> foo<span class="token punctuation">:</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span>foo <span class="token operator">=</span> <span class="token string">"Bar"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Error: 'bar' 不能赋值给类型 'Hello'</span></code></pre><p>它们本身并不是很实用，但是可以在一个联合类型中组合创建一个强大的（实用的）抽象</p><pre class=" language-ts"><code class="language-ts">type CardinalDirection <span class="token operator">=</span> <span class="token string">"North"</span> <span class="token operator">|</span> <span class="token string">"East"</span> <span class="token operator">|</span> <span class="token string">"South"</span> <span class="token operator">|</span> <span class="token string">"West"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">move</span><span class="token punctuation">(</span>distance<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">,</span> direction<span class="token punctuation">:</span> CardinalDirection<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"North"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Nurth"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Error</span></code></pre><h5 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h5><pre class=" language-ts"><code class="language-ts">type isBool<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">=</span> T <span class="token keyword">extends</span> <span class="token class-name">boolean</span> <span class="token operator">?</span> <span class="token keyword">true</span> <span class="token punctuation">:</span> <span class="token keyword">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// type t1 = false</span>type t1 <span class="token operator">=</span> isBool<span class="token operator">&lt;</span><span class="token keyword">number</span><span class="token operator">></span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// type t2 = true</span>type t2 <span class="token operator">=</span> isBool<span class="token operator">&lt;</span><span class="token keyword">false</span><span class="token operator">></span><span class="token punctuation">;</span></code></pre><h5 id="延迟推断类型"><a href="#延迟推断类型" class="headerlink" title="延迟推断类型"></a>延迟推断类型</h5><pre class=" language-ts"><code class="language-ts">type ParamType<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">=</span> T <span class="token keyword">extends</span> <span class="token punctuation">(</span>param<span class="token punctuation">:</span> infer P<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">any</span> <span class="token operator">?</span> P <span class="token punctuation">:</span> T<span class="token punctuation">;</span><span class="token keyword">interface</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>  age<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span><span class="token punctuation">}</span>type Func <span class="token operator">=</span> <span class="token punctuation">(</span>user<span class="token punctuation">:</span> User<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">void</span><span class="token punctuation">;</span>type Param <span class="token operator">=</span> ParamType<span class="token operator">&lt;</span>Func<span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Param = User</span>type AA <span class="token operator">=</span> ParamType<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// string</span>type ElementOf<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">=</span> T <span class="token keyword">extends</span> <span class="token class-name">Array</span><span class="token operator">&lt;</span>infer E<span class="token operator">></span> <span class="token operator">?</span> E <span class="token punctuation">:</span> never<span class="token punctuation">;</span>type TTuple <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span>type ToUnion <span class="token operator">=</span> ElementOf<span class="token operator">&lt;</span>TTuple<span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// string | number</span></code></pre><h4 id="四、常用技巧"><a href="#四、常用技巧" class="headerlink" title="四、常用技巧"></a>四、常用技巧</h4><h5 id="使用-const-enum-维护常量列表"><a href="#使用-const-enum-维护常量列表" class="headerlink" title="使用 const enum 维护常量列表"></a>使用 const enum 维护常量列表</h5><pre class=" language-ts"><code class="language-ts"><span class="token keyword">const</span> <span class="token keyword">enum</span> STATUS <span class="token punctuation">{</span>  TODO <span class="token operator">=</span> <span class="token string">"TODO"</span><span class="token punctuation">,</span>  DONE <span class="token operator">=</span> <span class="token string">"DONE"</span><span class="token punctuation">,</span>  DOING <span class="token operator">=</span> <span class="token string">"DOING"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">todos</span><span class="token punctuation">(</span>status<span class="token punctuation">:</span> STATUS<span class="token punctuation">)</span><span class="token punctuation">:</span> Todo<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token function">todos</span><span class="token punctuation">(</span>STATUS<span class="token punctuation">.</span>TODO<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="Partial（可选）-amp-Pick（选择）"><a href="#Partial（可选）-amp-Pick（选择）" class="headerlink" title="Partial（可选） &amp; Pick（选择）"></a>Partial（可选） &amp; Pick（选择）</h5><pre class=" language-ts"><code class="language-ts">type Partial<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token punctuation">[</span>P <span class="token keyword">in</span> keyof T<span class="token punctuation">]</span><span class="token operator">?</span><span class="token punctuation">:</span> T<span class="token punctuation">[</span>P<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>type Pick<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> K <span class="token keyword">extends</span> <span class="token class-name">keyof</span> T<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token punctuation">[</span>P <span class="token keyword">in</span> K<span class="token punctuation">]</span><span class="token punctuation">:</span> T<span class="token punctuation">[</span>P<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">interface</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>  id<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  age<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// type PartialUser = { id?: number; age?: number; name?: string }</span>type PartialUser <span class="token operator">=</span> Partial<span class="token operator">&lt;</span>User<span class="token operator">></span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// type PickUser = { id: number; age: number }</span>type PickUser <span class="token operator">=</span> Pick<span class="token operator">&lt;</span>User<span class="token punctuation">,</span> <span class="token string">"id"</span> <span class="token operator">|</span> <span class="token string">"age"</span><span class="token operator">></span><span class="token punctuation">;</span></code></pre><h5 id="Exclude（包含）-amp-Omit（排除）"><a href="#Exclude（包含）-amp-Omit（排除）" class="headerlink" title="Exclude（包含） &amp; Omit（排除）"></a>Exclude（包含） &amp; Omit（排除）</h5><pre class=" language-ts"><code class="language-ts">type Exclude<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> U<span class="token operator">></span> <span class="token operator">=</span> T <span class="token keyword">extends</span> <span class="token class-name">U</span> <span class="token operator">?</span> never <span class="token punctuation">:</span> T<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// type A = 'a'</span>type A <span class="token operator">=</span> Exclude<span class="token operator">&lt;</span><span class="token string">"x"</span> <span class="token operator">|</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"x"</span> <span class="token operator">|</span> <span class="token string">"y"</span> <span class="token operator">|</span> <span class="token string">"z"</span><span class="token operator">></span><span class="token punctuation">;</span>type Omit<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> K <span class="token keyword">extends</span> <span class="token class-name">keyof</span> <span class="token keyword">any</span><span class="token operator">></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Exclude<span class="token operator">&lt;</span>keyof T<span class="token punctuation">,</span> K<span class="token operator">></span><span class="token operator">></span><span class="token punctuation">;</span><span class="token keyword">interface</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>  id<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  age<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// type PickUser = { age: number; name: string }</span>type OmitUser <span class="token operator">=</span> Omit<span class="token operator">&lt;</span>User<span class="token punctuation">,</span> <span class="token string">"id"</span><span class="token operator">></span><span class="token punctuation">;</span></code></pre><h5 id="巧用-never-类型"><a href="#巧用-never-类型" class="headerlink" title="巧用 never 类型"></a>巧用 never 类型</h5><pre class=" language-ts"><code class="language-ts">type FunctionPropertyNames<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token punctuation">[</span>K <span class="token keyword">in</span> keyof T<span class="token punctuation">]</span><span class="token punctuation">:</span> T<span class="token punctuation">[</span>K<span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">Function</span> <span class="token operator">?</span> K <span class="token punctuation">:</span> never<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">[</span>keyof T<span class="token punctuation">]</span><span class="token punctuation">;</span>type NonFunctionPropertyNames<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token punctuation">[</span>K <span class="token keyword">in</span> keyof T<span class="token punctuation">]</span><span class="token punctuation">:</span> T<span class="token punctuation">[</span>K<span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">Function</span> <span class="token operator">?</span> never <span class="token punctuation">:</span> K<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">[</span>keyof T<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">interface</span> <span class="token class-name">Part</span> <span class="token punctuation">{</span>  id<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>  subparts<span class="token punctuation">:</span> Part<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">updatePart</span><span class="token punctuation">(</span>newName<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span><span class="token punctuation">}</span>type T40 <span class="token operator">=</span> FunctionPropertyNames<span class="token operator">&lt;</span>Part<span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 'updatePart'</span>type T41 <span class="token operator">=</span> NonFunctionPropertyNames<span class="token operator">&lt;</span>Part<span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 'id' | 'name' | 'subparts'</span></code></pre><h5 id="混合类（mixins）"><a href="#混合类（mixins）" class="headerlink" title="混合类（mixins）"></a>混合类（mixins）</h5><p>TypeScript (和 JavaScript) 类只能严格的单继承<br>从可重用组件构建类的另一种方式是通过基类来构建它们，这种方式称为混合。<br>这个主意是简单的，采用函数 B 接受一个类 A，并且返回一个带有新功能的类的方式来替代 A 类扩展 B 来获取 B 上的功能，前者中的 B 即是混合。</p><p>传入一个构造函数；<br>创建一个带有新功能，并且扩展构造函数的新类；<br>返回这个新类;</p><pre class=" language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// 所有 mixins 都需要</span>type Constructor<span class="token operator">&lt;</span>T <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">:</span> <span class="token keyword">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> T<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 添加属性的混合例子</span><span class="token keyword">function</span> TimesTamped<span class="token operator">&lt;</span>TBase <span class="token keyword">extends</span> <span class="token class-name">Constructor</span><span class="token operator">></span><span class="token punctuation">(</span>Base<span class="token punctuation">:</span> TBase<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> Base <span class="token punctuation">{</span>    timestamp <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 添加属性和方法的混合例子</span><span class="token keyword">function</span> Activatable<span class="token operator">&lt;</span>TBase <span class="token keyword">extends</span> <span class="token class-name">Constructor</span><span class="token operator">></span><span class="token punctuation">(</span>Base<span class="token punctuation">:</span> TBase<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> Base <span class="token punctuation">{</span>    isActivated <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>    <span class="token function">activate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>isActivated <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">deactivate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>isActivated <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 简单的类</span><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>  name <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 添加 TimesTamped 的 User</span><span class="token keyword">const</span> TimestampedUser <span class="token operator">=</span> <span class="token function">TimesTamped</span><span class="token punctuation">(</span>User<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 添加 TimesTamped 和 Activatable 的类</span><span class="token keyword">const</span> TimestampedActivatableUser <span class="token operator">=</span> <span class="token function">TimesTamped</span><span class="token punctuation">(</span><span class="token function">Activatable</span><span class="token punctuation">(</span>User<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用组合类</span><span class="token keyword">const</span> timestampedUserExample <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TimestampedUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>timestampedUserExample<span class="token punctuation">.</span>timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> timestampedActivatableUserExample <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TimestampedActivatableUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>timestampedActivatableUserExample<span class="token punctuation">.</span>timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>timestampedActivatableUserExample<span class="token punctuation">.</span>isActivated<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="类型兼容性"><a href="#类型兼容性" class="headerlink" title="类型兼容性"></a>类型兼容性</h5><p>类型兼容性用于确定一个类型是否能赋值给其他类型<br>例如：任何类型都能被赋值给 any，这就是指类型的兼容。</p><ul><li>结构化<br>TS 对象是一种结构类型，这意味着只要结构匹配，名称也就无关紧要了。</li></ul><pre class=" language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>  x<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  y<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">public</span> x<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">,</span> <span class="token keyword">public</span> y<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> p<span class="token punctuation">:</span> Point<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok, 因为是结构化的类型</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point2D</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="使用可辨识联合并保证每个-case-被处理"><a href="#使用可辨识联合并保证每个-case-被处理" class="headerlink" title="使用可辨识联合并保证每个 case 被处理"></a>使用可辨识联合并保证每个 case 被处理</h5><ul><li>当类中含有字面量成员时，我们可以用该类的属性来辨析联合类型。<br>例：考虑 Square 和 Rectangle 的联合类型 Shape。Square 和 Rectangle 有共同成员 kind，因此 kind 存在于 Shape 中。</li></ul><pre class=" language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name">Square</span> <span class="token punctuation">{</span>  kind<span class="token punctuation">:</span> <span class="token string">"square"</span><span class="token punctuation">;</span>  size<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">interface</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>  kind<span class="token punctuation">:</span> <span class="token string">"rectangle"</span><span class="token punctuation">;</span>  width<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  height<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span><span class="token punctuation">}</span>type Shape <span class="token operator">=</span> Square <span class="token operator">|</span> Rectangle<span class="token punctuation">;</span></code></pre><p>如果你使用类型保护风格的检查（==、===、!=、!==）或者使用具有判断性的属性（在这里是 kind），TypeScript 将会认为你会使用的对象类型一定是拥有特殊字面量的，并且它会为你自动把类型范围变小：</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">area</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> Shape<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>kind <span class="token operator">===</span> <span class="token string">"square"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 现在 TypeScript 知道 s 的类型是 Square</span>    <span class="token comment" spellcheck="true">// 所以你现在能安全使用它</span>    <span class="token keyword">return</span> s<span class="token punctuation">.</span>size <span class="token operator">*</span> s<span class="token punctuation">.</span>size<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 不是一个 square ？因此 TypeScript 将会推算出 s 一定是 Rectangle</span>    <span class="token keyword">return</span> s<span class="token punctuation">.</span>width <span class="token operator">*</span> s<span class="token punctuation">.</span>height<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通常，联合类型的成员有一些自己的行为（代码），即保证每个 case 都被处理</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name">Square</span> <span class="token punctuation">{</span>  kind<span class="token punctuation">:</span> <span class="token string">"square"</span><span class="token punctuation">;</span>  size<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">interface</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>  kind<span class="token punctuation">:</span> <span class="token string">"rectangle"</span><span class="token punctuation">;</span>  width<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  height<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 有人仅仅是添加了 `Circle` 类型</span><span class="token comment" spellcheck="true">// 我们可能希望 TypeScript 能在任何被需要的地方抛出错误</span><span class="token keyword">interface</span> <span class="token class-name">Circle</span> <span class="token punctuation">{</span>  kind<span class="token punctuation">:</span> <span class="token string">"circle"</span><span class="token punctuation">;</span>  radius<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span><span class="token punctuation">}</span>type Shape <span class="token operator">=</span> Square <span class="token operator">|</span> Rectangle <span class="token operator">|</span> Circle<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">area</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> Shape<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">switch</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>kind<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token string">"square"</span><span class="token punctuation">:</span>      <span class="token keyword">return</span> s<span class="token punctuation">.</span>size <span class="token operator">*</span> s<span class="token punctuation">.</span>size<span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token string">"rectangle"</span><span class="token punctuation">:</span>      <span class="token keyword">return</span> s<span class="token punctuation">.</span>width <span class="token operator">*</span> s<span class="token punctuation">.</span>height<span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token string">"circle"</span><span class="token punctuation">:</span>      <span class="token keyword">return</span> Math<span class="token punctuation">.</span>PI <span class="token operator">*</span> s<span class="token punctuation">.</span>radius <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>      <span class="token keyword">const</span> _exhaustiveCheck<span class="token punctuation">:</span> never <span class="token operator">=</span> s<span class="token punctuation">;</span>      <span class="token keyword">return</span> _exhaustiveCheck<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="索引类型：获取索引类型和索引值类型"><a href="#索引类型：获取索引类型和索引值类型" class="headerlink" title="索引类型：获取索引类型和索引值类型"></a>索引类型：获取索引类型和索引值类型</h5><p>可以用字符串访问 JavaScript 中的对象（TypeScript 中也一样），用来保存对其他对象的引用<br>当你传入一个其他对象至索引时，这是因为 JavaScript 会在得到结果之前会先调用 .toString 方法。<br>数组有点稍微不同，对于一个 number 类型的索引，JavaScript 引擎将会尝试去优化（这取决于它是否是一个真的数组、存储的项目结构是否匹配等）。</p><ul><li><p>索引类型：对象、数组、symbols</p></li><li><p>索引值类型：string 和 number</p></li><li><p>设计模式：索引签名的嵌套</p></li><li><p>在 JavaScript 社区你将会见到很多滥用索引签名的 API。如 JavaScript 库中使用 CSS 的常见模式：</p></li></ul><pre class=" language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name">NestedCSS</span> <span class="token punctuation">{</span>  color<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// strictNullChecks=false 时索引签名可为 undefined</span>  <span class="token punctuation">[</span>selector<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">string</span> <span class="token operator">|</span> NestedCSS<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> example<span class="token punctuation">:</span> NestedCSS <span class="token operator">=</span> <span class="token punctuation">{</span>  color<span class="token punctuation">:</span> <span class="token string">"red"</span><span class="token punctuation">,</span>  <span class="token string">".subclass"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    color<span class="token punctuation">:</span> <span class="token string">"blue"</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>尽量不要使用这种把字符串索引签名与有效变量混合使用。如果属性名称中有拼写错误，这个错误不会被捕获到：<br>取而代之，我们把索引签名分离到自己的属性里，如命名为 nest（或者 children、subnodes 等）：</p><pre class=" language-ts"><code class="language-ts">  <span class="token keyword">interface</span> <span class="token class-name">NestedCSS</span> <span class="token punctuation">{</span>    color<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>    nest<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>      <span class="token punctuation">[</span>selector<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">]</span><span class="token punctuation">:</span> NestedCSS<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">const</span> example<span class="token punctuation">:</span> NestedCSS <span class="token operator">=</span> <span class="token punctuation">{</span>    color<span class="token punctuation">:</span> <span class="token string">'red'</span><span class="token punctuation">,</span>    nest<span class="token punctuation">:</span> <span class="token punctuation">{</span>      <span class="token string">'.subclass'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>        color<span class="token punctuation">:</span> <span class="token string">'blue'</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">const</span> failsSliently<span class="token punctuation">:</span> NestedCSS <span class="token punctuation">{</span>    colour<span class="token punctuation">:</span> <span class="token string">'red'</span>  <span class="token comment" spellcheck="true">// TS Error: 未知属性 'colour'</span>  <span class="token punctuation">}</span></code></pre><ul><li>索引排除某些属性<br>有时，你需要把属性合并至索引签名（虽然我们并不建议这么做，你应该使用上文中提到的嵌套索引签名的形式），如下例子：</li></ul><pre class=" language-ts"><code class="language-ts">type FieldState <span class="token operator">=</span> <span class="token punctuation">{</span>  value<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>type FromState <span class="token operator">=</span> <span class="token punctuation">{</span>  isValid<span class="token punctuation">:</span> <span class="token keyword">boolean</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Error: 不符合索引签名</span>  <span class="token punctuation">[</span>filedName<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">]</span><span class="token punctuation">:</span> FieldState<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>TypeScript 会报错，因为添加的索引签名，并不兼容它原有的类型，使用交叉类型可以解决上述问题：</p><pre class=" language-ts"><code class="language-ts">type FieldState <span class="token operator">=</span> <span class="token punctuation">{</span>  value<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>type FormState <span class="token operator">=</span> <span class="token punctuation">{</span> isValid<span class="token punctuation">:</span> <span class="token keyword">boolean</span> <span class="token punctuation">}</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>fieldName<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">]</span><span class="token punctuation">:</span> FieldState <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>请注意尽管你可以声明它至一个已存在的 TypeScript 类型上，但是你不能创建如下的对象：</p><pre class=" language-ts"><code class="language-ts">type FieldState <span class="token operator">=</span> <span class="token punctuation">{</span>  value<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>type FormState <span class="token operator">=</span> <span class="token punctuation">{</span> isValid<span class="token punctuation">:</span> <span class="token keyword">boolean</span> <span class="token punctuation">}</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>fieldName<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">]</span><span class="token punctuation">:</span> FieldState <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 将它用于从某些地方获取的 JavaScript 对象</span><span class="token keyword">declare</span> <span class="token keyword">const</span> foo<span class="token punctuation">:</span> FormState<span class="token punctuation">;</span><span class="token keyword">const</span> isValidBool <span class="token operator">=</span> foo<span class="token punctuation">.</span>isValid<span class="token punctuation">;</span><span class="token keyword">const</span> somethingFieldState <span class="token operator">=</span> foo<span class="token punctuation">[</span><span class="token string">"something"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用它来创建一个对象时，将不会工作</span><span class="token keyword">const</span> bar<span class="token punctuation">:</span> FormState <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 'isValid' 不能赋值给 'FieldState'</span>  isValid<span class="token punctuation">:</span> <span class="token keyword">false</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h5 id="this-的类型"><a href="#this-的类型" class="headerlink" title="this 的类型"></a>this 的类型</h5><p>通过 ThisType 我们可以在对象字面量中键入 this，并提供通过上下文类型控制 this 类型的便捷方式。它只有在 –noImplicitThis 的选项下才有效。<br>现在，在对象字面量方法中的 this 类型，将由以下决定：</p><ul><li>如果这个方法显示指定了 this 参数，那么 this 具有该参数的类型。（下例子中 bar）</li><li>否则，如果方法由带 this 参数的签名进行上下文键入，那么 this 具有该参数的类型。（下例子中 foo）</li><li>否则，如果 –noImplicitThis 选项已经启用，并且对象字面量中包含由 ThisType<t> 键入的上下文类型，那么 this 的类型为 T。</t></li><li>否则，如果 –noImplicitThis 选项已经启用，并且对象字面量中不包含由 ThisType<t> 键入的上下文类型，那么 this 的类型为该上下文类型。</t></li><li>否则，如果 –noImplicitThis 选项已经启用，this 具有该对象字面量的类型。</li><li>否则，this 的类型为 any。</li></ul><pre class=" language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// Compile with --noImplicitThis</span>type Point <span class="token operator">=</span> <span class="token punctuation">{</span>  x<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  y<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  <span class="token function">moveBy</span><span class="token punctuation">(</span>dx<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">,</span> dy<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> p<span class="token punctuation">:</span> Point <span class="token operator">=</span> <span class="token punctuation">{</span>  x<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>  y<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>  <span class="token function">moveBy</span><span class="token punctuation">(</span>dx<span class="token punctuation">,</span> dy<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+</span><span class="token operator">=</span> dx<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// this has type Point</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">+</span><span class="token operator">=</span> dy<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// this has type Point</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>  x<span class="token punctuation">:</span> <span class="token string">"hello"</span><span class="token punctuation">,</span>  <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// { x: string, f(n: number): void }</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token punctuation">{</span>  x<span class="token punctuation">:</span> <span class="token string">"hello"</span><span class="token punctuation">,</span>  <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> message<span class="token punctuation">:</span> <span class="token keyword">string</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// { message: string }</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><hr><h4 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h4><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzA4ODUzNTE2Nw==&amp;mid=2451046381&amp;idx=1&amp;sn=eba11644f1ac8254cf148d7d7bca75c7&amp;chksm=87cbe6fdb0bc6febb4eed20df2cd25c3d566d7a66b186751c212a0243cb31d65234aee331cc7&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1569634214253&amp;sharer_shareid=827ddc86f3743a5ae1362c6a1314c273%23rd">TypeScript 技巧拾遗</a></li><li><a href="https://jkchao.github.io/typescript-book-chinese/">深入理解 TypeScript</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> TS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react&amp;react-router</title>
      <link href="2022/11/04/react-he-react-router/"/>
      <url>2022/11/04/react-he-react-router/</url>
      
        <content type="html"><![CDATA[<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="React-初识"><a href="#React-初识" class="headerlink" title="React 初识"></a>React 初识</h3><ul><li><p><strong>补充知识：ES6 类与继承</strong></p><ol><li><p><strong>ES5 构造函数 和 ES6 类的区别?</strong></p><p>ES6 类可以理解为 ES5 构造函数的语法糖，因为 ES6 类的大部分功能特性都可以使用 ES5 构造函数去模拟实现，类中所有的方法包括 constructor 都是定义在类的 prototype 原型上，ES5 的构造函数相当于 ES6 类的 constructor</p></li><li><p><strong>ES5 继承 和 ES6 继承的区别?</strong></p><p>ES5 的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先获得父类实例对象的属性和方法（所以必须先调用 super 方法），然后再用子类的构造函数修改 this。</p><p>Class 作为构造函数的语法糖，存在两条继承链</p><p>（1）子类的<strong>proto</strong>属性，表示构造函数的继承，总是指向父类</p><p>（2）子类 prototype 属性的<strong>proto</strong>属性，表示方法的继承，总是指向父类的 prototype 属性</p></li></ol></li><li><p><strong>JSX 写法</strong></p></li></ul><p>从本质上讲，JSX 只是为 React.createElement()函数提供的语法糖，返回一个 React Element</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Clock</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> date<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  onClick <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token operator">&lt;</span>div<span class="token operator">></span>        <span class="token operator">&lt;</span>h1<span class="token operator">></span>Hello<span class="token punctuation">,</span> world<span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>        <span class="token operator">&lt;</span>h2<span class="token operator">></span>It is <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>date<span class="token punctuation">.</span><span class="token function">toLocaleTimeString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>onClick<span class="token punctuation">}</span><span class="token operator">></span>Hello<span class="token punctuation">,</span> world<span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>代码转化后：</p><ul><li><p><strong>组件命名为什么必须是大写的？</strong></p><p>React.createElement(type,config,children)创建 React Element 的过程中,React 会根据 type 的大小写区分如果是大写，对应的是 React 组件，如果是小写，React 会把他映射为原生的 DOM</p></li><li><p><strong>补充知识：</strong> ES6+ class 静态属性，静态方法， 实例属性</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 静态属性和讲台方法可以被子类继承，不会被实例继承</span><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 静态方法</span>  <span class="token keyword">static</span> <span class="token function">classMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 静态属性</span>  <span class="token keyword">static</span> classProp <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 实例属性</span>  state <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"zz"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 相当于</span>  <span class="token comment" spellcheck="true">// constructor(){</span>  <span class="token comment" spellcheck="true">// state = {name:'zz'};</span>  <span class="token comment" spellcheck="true">// }</span>  <span class="token comment" spellcheck="true">// 所以我们可以使用实例属性替换constructor的写法</span><span class="token punctuation">}</span></code></pre></li></ul><h3 id="React-组件"><a href="#React-组件" class="headerlink" title="React 组件"></a>React 组件</h3><p>React 组件分为两类，一类是类组件，一类是函数组件，不论是类组件还是函数式组件，最终都要返回 React Element。如果是类组件，就先实例化然后调用 render 方法<br>如果是函数组件，则直接调用。</p><p>那么 react 是如何区分类组件和函数式组件?<br>通过判断函数是否是 Component 的实例，PureCompnent 同样继承自 Component，也是 Component 的实例</p><ul><li><p><strong>Component 和 PureCompnent</strong></p><ol><li><p><strong>Component 组件</strong></p><p>父组件重新渲染后，子组件会经历 componentWillReceiveProps(或者 getDerivedStateFromProps，两者不能同时存在),和 shouldComponentUpdate 生命周期，其中，shouldComponentUpdate 生命周期，返回 true，则表示会重新渲染，返回 false，则表示不会重新渲染，继承自 Component 的组件默认返回 true，所以其子组件也必然会重新渲染。</p></li><li><p><strong>PureComponent</strong></p><p>针对 Component 子组件会重新渲染的问题，PureComponent 则会在 shouldComponent 生命周期阶段，对 props 的值进行一次比较，基本类型会判断其是否相当（===），复杂数据类型会判断其指针是否指向同一个对象。控制其是否重新渲染。</p></li></ol></li><li><p><strong>Function Component</strong></p><p>在没有 Hooks API 之前，Function Component 函数式组件，没有自己的生命周期，没有自己的 state，只是传入一个 props，返回一个 React Element。 非常适合写一些简单的组件，比如数据展示型组件</p><p>React 16.8 之后，Hooks API 可以为函数组件加上生命周期和 state 等特性</p></li></ul><h3 id="组件的-state-和-props"><a href="#组件的-state-和-props" class="headerlink" title="组件的 state 和 props"></a>组件的 state 和 props</h3><ul><li><p><strong>组件的 state</strong></p><p>一般情况下，组件的需要管理的状态我们可以放在 this.state 中，如果是一些常量，或者改变后也不影响页面的重新渲染，比如过提交的数据，我们可以定义为实例的属性或者在组件依赖的变量</p><p>不能直接更新状态，必须使用<strong>setState</strong>更新状态</p></li><li><p><strong>更新 state</strong></p><ol><li><p>异步更新 state</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  comment<span class="token punctuation">:</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 可以传入第二个参数，为更新state之后的回调函数</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>  <span class="token punctuation">{</span>    comment<span class="token punctuation">:</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"state更新完成"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>同步更新 state</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 传入一个函数，接收当前state和props为参数，返回一个对象，为更新后的state</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prevState<span class="token punctuation">,</span> props<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>  counter<span class="token punctuation">:</span> prevState<span class="token punctuation">.</span>counter <span class="token operator">+</span> props<span class="token punctuation">.</span>increment<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol></li><li><p><strong>组件的 props</strong></p><ol><li><p><strong>props 是只读的</strong></p><p>props 是 React 组件的输入，不应该以任何方式修改他们，我们可以使用 state 来作为替代。</p></li><li><p><strong>children</strong></p><p>children 是一个特殊的属性，，它总是指代标签之前的子代，</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Welcome</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">&lt;</span>p<span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>children<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span>Welcome<span class="token operator">></span>hello world<span class="token operator">&lt;</span><span class="token operator">/</span>Welcome<span class="token operator">></span><span class="token comment" spellcheck="true">// 等同于 ===</span><span class="token operator">&lt;</span>Welcome children<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'hello world'</span><span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">></span></code></pre></li><li><p><strong>key 和 ref</strong></p><p>key 和 ref 不是 props，key 和 ref 会做单独的处理，key 用作 react diff 阶段的优化，ref 则指代组件实例</p></li></ol></li></ul><h3 id="组件的生命周期（v16-3-之前版本）"><a href="#组件的生命周期（v16-3-之前版本）" class="headerlink" title="组件的生命周期（v16.3 之前版本）"></a>组件的生命周期（v16.3 之前版本）</h3><ul><li><p><strong>组件挂载流程</strong>:</p><p><img src="https://raw.githubusercontent.com/s1p21/hexo/master/source/images/react-lifeCycle.jpg"></p></li><li><p><strong>生命周期介绍</strong>：</p><ol><li><p><strong>getDefaultProps</strong>（createClass 写法）</p><p>获取初始属性</p></li><li><p><strong>getInitialState</strong> (createClass 写法)</p><p>获取初始状态</p></li><li><p><strong>componentWillMount</strong></p><p>render 之前执行，在初始化渲染之前做最后更改 state 的操作,可以用于初始化 state 的操作</p><p>这个函数里面的写法，都可以被 constructor 和 componentDidMount 里写法替代，根据 props 初始化 state 可以写在 constructor 里面，发起网络请求可以写在 componentDidMount 里面</p></li><li><p><strong>render</strong></p><p>render 阶段会调用 render()方法，返回一个 react element</p></li><li><p><strong>componentDidMount</strong></p><p>初始化渲染之后执行，虚拟 dom 挂载到真实的 dom 节点上，这个生命周期及之后才可以使用使用 ref 和访问真实的 dom 节点，一般在这个生命周期进行网络请求，事件监听等操作。</p></li><li><p><strong>componentWillUpdate</strong></p><p>组件 props 和 state 发生变化时，重新 render 方法之前执行，注意，这个生命周期不能使用 setState 来修改状态，函数调用之后接收 nextProps 和 nextState 来进行操作</p></li><li><p><strong>componentDidUpdate</strong></p><p>可以在其子组件树中的任何位置捕获 JavaScript 错误，记录这些错误并显示回退 UI，而不是崩溃的组件树。错误边界在渲染期间，生命周期方法以及整个树下的构造函数中捕获错误。</p><p>组件更新之后调用，如果在组件更新之后需要 DOM 操作，可以使用该方法，该方法接受 prevProps 和 prevState</p></li><li><p><strong>componentWillUnmount</strong></p><p>卸载组件之前调用，可以用来取消 componentDidMount 中添加的监听事件，清空计时器，清空创建的 DOM 等操作</p></li><li><p><strong>componentWillReceiveProps</strong></p><p>组件接受 props 时触发，父组件重新渲染，一般也会导致传入子组件 props 的变化，所以会触发此生命周期</p></li><li><p><strong>shouldComponentUpdate</strong></p><p>性能优化最重要的一个生命周期，如果监控到组件频繁刷新，使用此函数进行性能优化</p></li></ol></li></ul><h3 id="组件的新生命周期（v16-3-及之后版本）"><a href="#组件的新生命周期（v16-3-及之后版本）" class="headerlink" title="组件的新生命周期（v16.3 及之后版本）"></a>组件的新生命周期（v16.3 及之后版本）</h3><p>由于 React 16.3 版本 fiber 架构的引入，三个生命周期被标记为不安全（UNSAFE_），因为 componentWillMount，componentWillReceiveProps，componentWillUpdate 都在 reconciliation 过程中，可能在初始化渲染之前，或者更新渲染前被执行多次，在新的版本中应避免使用，17 版本之后可能会被删除。</p><p><img src="https://raw.githubusercontent.com/s1p21/hexo/master/source/images/react-newLifeCycle.png"></p><ul><li><p><strong>被标记为不安全的生命周期</strong></p><p>UNSAFE_componentWillMount</p><p>UNSAFE_componentWillReceiveProps</p><p>UNSAFE_componentWillUpdate</p></li><li><p><strong>新增的生命周期</strong></p><ol><li><p><strong>static getDerivedStateFormProps</strong></p><p>新的 react 版本在初始化，newProps 传入，包括 setState 和 forceUpdate 都会触发 getDerivedStateFormProps 生命周期</p><p>使用场景：组件的 state 管理着组件的状态，传入组件的 props，同样可以初始化为组件的 state，如果想让组件功能更灵活，就需要每次传入 props，都会根据传入的 props 改变组件内部的 state，这就是这个生命周期常见的应用场景</p></li><li><p><strong>static getSnapshotBeforeUpdate</strong></p><p>组件更新前获取其状态的快照</p><p>注意 这两个都是静态方法，不能再其里面使用 this</p></li><li><p><strong>componentDidCatch</strong></p><p>新增的错误处理钩子，见我们的项目</p></li></ol></li><li><p><strong>总结：生命周期该怎么用</strong></p><ol><li>constructor（并不属于生命周期 - 初始化 state，初始化参数）</li><li>componentDidMount - 网络请求，添加监听事件等</li><li>static getDerivedStateFormPorps - 组件 props 变化时更新 state</li><li>shouldComponentUpdate - 通过判断新传入的 props，优化性能，避免重复渲染</li><li>static getSnapshopBeforeUpdate - 很少用，组件更新之前捕获一些信息（例如滚动位置）</li><li>componentDidUpdate - 组件更新完成后的一些操作</li><li>componentWillUnmount - 卸载监听事件，卸载计时器等</li><li>componentDidCatch - 错误捕捉</li></ol><p>不要用:</p><ol><li>componentWillMount - constructor 和 componentDidMount 替代</li><li>componentWillReceiveProps - getDerivedStateFormPorps 替代</li><li>componentWillUpdate() - getSnapshotBeforeUpdate 替代</li></ol></li></ul><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><ul><li><p><strong>constructor 绑定（react 推荐）</strong></p><p>在 constructor 中进行绑定，只在实例化过程中绑定一次，缺点是每一事件都需要自己手动绑定</p></li><li><p><strong>调用时绑定</strong></p><p>在事件函数触发后使用 bind 绑定 this，缺点是每触发一次事件，都会进行一次绑定，产生一个新的方法指针，并且如果函数作为属性传入子组件的时候，子组件可能进行额外的重新渲染，有少许性能问题</p></li><li><p><strong>箭头函数绑定</strong></p><p>在事件函数触发后使用箭头函数绑定 this，有和上面一样的问题</p></li><li><p><strong>实例属性（方法）初始化（推荐）</strong></p><p>利用属性初始化语法，将方法初始化为箭头函数，因此在创建函数的时候就绑定了 this。</p></li><li><p><strong>事件传参</strong></p><p>如果事件类型相同，我们可以通过传参来避免写多个相同的函数</p><pre class=" language-js"><code class="language-js">onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">onClick</span><span class="token punctuation">(</span><span class="token string">'type'</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre></li></ul><h3 id="组件间的通信"><a href="#组件间的通信" class="headerlink" title="组件间的通信"></a>组件间的通信</h3><ul><li><p><strong>props</strong></p><p>父组件向子组件通信，层级深的话需连续传递</p></li><li><p><strong>回调函数</strong></p><p>也是 props，只不过 props 是个函数，子组件向父组件通信，层级深的话需连续传递</p></li><li><p><strong>发布订阅模式</strong></p><p>适用跨层级的情况，或者组件的静态方法和实例间的通信</p></li><li><p><strong>redux</strong></p><p>redux 通过 dispath 一个 action，更新全局的 state，然后同步状态给需要的组件</p></li><li><p><strong>其他可选方案</strong></p><ol><li><p><strong>Context</strong></p><p>可以把需要共享的状态，定义在两个组件的公共父节点，使用 Context 进行管理<br>不常见，一般使用 Context 管理路由，组件主题，国际化等</p></li><li><p><strong>ref</strong></p><p>使用 ref 获取子组件的实例，然后调用实例上的方法。<br>虽然官方并不推荐使用 ref，但设计组件或者模块通信时很常见，例如 Modal 类组件</p></li></ol></li></ul><h3 id="列表-amp-key"><a href="#列表-amp-key" class="headerlink" title="列表 &amp; key"></a>列表 &amp; key</h3><p>当我们的子组件是一个数组时，key 帮助 React 识别哪些元素改变了，比如被添加或删除</p><p>如果是固定的 UI 列表，可以使用 index 作为 key， 如果是数据列表，一定要避免使用 index</p><p>一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用来自数据 id 来作为元素的 key</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">const</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> listItems <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">number</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>  <span class="token operator">&lt;</span>li key<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">number</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>    <span class="token punctuation">{</span><span class="token keyword">number</span><span class="token punctuation">}</span>  <span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在虚拟 dom diff 时，react 和 vue 的异同？</p><h3 id="高阶组件（属性劫持场景）"><a href="#高阶组件（属性劫持场景）" class="headerlink" title="高阶组件（属性劫持场景）"></a>高阶组件（属性劫持场景）</h3><p><strong>补充知识：ES6 装饰器 注意：需要配置 babel 插件</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。</span><span class="token comment" spellcheck="true">// 1. 类的装饰</span><span class="token comment" spellcheck="true">// 装饰器是一个函数，入参为被装饰的类</span><span class="token keyword">function</span> <span class="token function">testable</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>  target<span class="token punctuation">.</span>isTestable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span>@testable<span class="token keyword">class</span> <span class="token class-name">MyTestableClass</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span>MyTestableClass<span class="token punctuation">.</span>isTestable<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span><span class="token comment" spellcheck="true">// 2. 类方法的装饰</span><span class="token keyword">function</span> <span class="token function">readonly</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> name<span class="token punctuation">,</span> descriptor<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// descriptor对象同Object.defineProperty第三个参数</span>  descriptor<span class="token punctuation">.</span>writable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> descriptor<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>  @readonly  <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>first<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>last<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>高阶组件是什么</strong></p><p>高阶组件（higherOrderComponent），简称 HOC，本质上就是一个函数，只是参数为组件，返回值为一个新的组件，主要用于复用组件的逻辑，之前 react 通过 createClass 创建组件时，主要通过 MixIn 的方式复用逻辑<br>高阶组件在项目开发中非常常见，对理解三方组件源码也非常重要<br><strong>高阶组件的约定</strong></p><ol><li><p><strong>不要改变原始组件。使用组合</strong></p><p>不要改变原始组件，会产生一些不良后果</p></li></ol><pre class=" language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">logProps</span><span class="token punctuation">(</span>InputComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>  InputComponent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>componentWillReceiveProps <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Current props: '</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Next props: '</span><span class="token punctuation">,</span> nextProps<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 返回原始的 input 组件，暗示它已经被修改。</span>  <span class="token keyword">return</span> InputComponent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 每次调用 logProps 时，增强组件都会有 log 输出。</span><span class="token keyword">const</span> EnhancedComponent <span class="token operator">=</span> <span class="token function">logProps</span><span class="token punctuation">(</span>InputComponent<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol start="2"><li><p><strong>将不相关的 props 传递给被包裹的组件</strong></p><p>对需要处理的属性进行劫持，剩下的属性不做改变</p><pre class=" language-ts"><code class="language-ts"><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 过滤掉非此 HOC 额外的 props，且不要进行透传</span>  <span class="token keyword">const</span> <span class="token punctuation">{</span> extraProp<span class="token punctuation">,</span> <span class="token operator">...</span>passThroughProps <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 将 props 注入到被包装的组件中。</span>  <span class="token comment" spellcheck="true">// 通常为 state 的值或者实例方法。</span>  <span class="token keyword">const</span> injectedProp <span class="token operator">=</span> someStateOrInstanceMethod<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 将 props 传递给被包装组件</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>WrappedComponent      injectedProp<span class="token operator">=</span><span class="token punctuation">{</span>injectedProp<span class="token punctuation">}</span>      <span class="token punctuation">{</span><span class="token operator">...</span>passThroughProps<span class="token punctuation">}</span>    <span class="token operator">/</span><span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p><strong>最大化可组合性</strong></p><p>当我们需要传入其他参数时，一般使用函数柯里化的方式，举例：</p><pre class=" language-ts"><code class="language-ts"><span class="token function">LayoutHoc</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 当需要额外参数时，采用函数柯里化的方式</span><span class="token function">NavHoc</span><span class="token punctuation">(</span><span class="token punctuation">{</span>title<span class="token punctuation">:</span> <span class="token string">'标题'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>（component）</code></pre></li><li><p><strong>包装显示名称以便轻松调试</strong></p><p>为了方便调试，可以设置显示名称，以表明它是 HOC 的产物。</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">withLayout</span><span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">class</span> <span class="token class-name">WithSubscription</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">/* ... */</span><span class="token punctuation">}</span>  withLayout <span class="token operator">=</span> <span class="token template-string"><span class="token string">`withLayout(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">getDisplayName</span><span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 或者</span>  withLayout <span class="token operator">=</span> <span class="token template-string"><span class="token string">`WrappedComponent(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">getDisplayName</span><span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span><span class="token punctuation">;</span>  <span class="token keyword">return</span> withLayout<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">getDisplayName</span><span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> WrappedComponent<span class="token punctuation">.</span>displayName <span class="token operator">||</span> WrappedComponent<span class="token punctuation">.</span>name <span class="token operator">||</span> <span class="token string">'Component'</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>例如设置高阶组件的 displayName 为 WappedComponent()</p></li></ol><p><strong>高阶组件的注意事项</strong></p><ol><li><p><strong>不要在 render 方法中使用 HOC</strong></p><pre class=" language-ts"><code class="language-ts"><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 每次调用 render 函数都会创建一个新的 EnhancedComponent</span>  <span class="token comment" spellcheck="true">// EnhancedComponent1 !== EnhancedComponent2</span>  <span class="token keyword">const</span> EnhancedComponent <span class="token operator">=</span> <span class="token function">enhance</span><span class="token punctuation">(</span>MyComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！</span>  <span class="token keyword">return</span> <span class="token operator">&lt;</span>EnhancedComponent <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p><strong>复制静态方法</strong></p><p>组件被包裹。这意味着新组件没有原始组件的任何静态方法。<br>使用 hoist-non-react-statics 自动拷贝所有非 React 静态方法<br>自认为，类的静态方法使用在另外一个组件外的使用场景并不常见<br>如果有需要，也可以额外导出这个静态方法</p></li><li><p><strong>Refs 不会被传递</strong></p><p>props 传递给包裹的组件，然后经包裹的组件处理，传给被包裹的组件，但是 key 和 refs 并不属于 props 的范畴，react 对两者专门处理</p><p>这个问题，我们自己可以在包裹组件内部，拿到被包裹组件的 ref，然后通过回调函数传给包裹的组件，常见的三方库，都会提供给这么一个方法，例如 antd 组件库的 Form.create 之后可以通过 wrappedComponentRef 方法拿到被包裹的组件。</p><p>React 16.3 之后针对 ref 透传的问题，可以使用 forwardRef API</p></li></ol><p><strong>高阶组件的使用场景</strong></p><ol><li><p><strong>通用布局</strong></p><p>例如通用的容器样式，底部导航，头部导航</p></li><li><p><strong>通用功能</strong></p><p>例如通用的错误捕捉，手势反馈<br>比如多个 List 列表（Dropdown 下拉框等等数据展示类的组件）的样式是相同的，只是获取数据源的地址是不同的<br>我们通过封装一个高阶组件，传入不同的地址，然后把得到的数据传给我们的组件</p></li><li><p><strong>渲染劫持</strong></p><p>例如我们的组件需要做权限校验，每次进入页面，判断是否登录，没有登录跳转到登录页<br>我们就可以在高阶组件里面进行判断，控制渲染的结果</p></li><li><p><strong>其他场景</strong></p><p>正常情况下，我们都是要做代码分割的，我们可以在高阶组件里面动态引入组件，组件返回前，渲染 loading 组件，否则渲染我们要动态加载的组件，react-loadable 等第三方库，都是基于此原理进行设计的</p></li></ol><p><strong>其他</strong></p><p>以上我们都是通过对属性的劫持方式使用高阶组件，另外一种方式，可以使用反向继承的方式使用<br>也就是，让我们返回的组件继承我们传入的组件，这样，我们就可以操作传入组件的原型，增强生命周期等等</p><h3 id="render-props（渲染属性）"><a href="#render-props（渲染属性）" class="headerlink" title="render props（渲染属性）"></a>render props（渲染属性）</h3><p>渲染属性只是一个小技巧，和高阶组件一样，解决代码复用的问题</p><ol><li>我们给组件的某个属性传一个函数，例如 render 属性</li><li>这个函数有些特殊，例如 mouse =&gt; (<p>鼠标的位置是 {mouse.x}，{mouse.y}</p>)}，入参是组件传入，返回值是一个 React Element</li><li>组件里面执行这个函数，然后把相同逻辑处理后的结果，比如说，鼠标的位置，网络请求回来的数据传给这个传入的函数 this.props.render(data)</li><li>这样，我们就复用了组件的逻辑</li><li>当然，不一定要用 render 属性，很常见的一种做法是使用 children 属性</li><li>因为 children 属性可以写在标签里面，让我们的代码更清晰</li></ol><pre class=" language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name">Mouse</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>handleMouseMove <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>handleMouseMove<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">handleMouseMove</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      x<span class="token punctuation">:</span> event<span class="token punctuation">.</span>clientX<span class="token punctuation">,</span>      y<span class="token punctuation">:</span> event<span class="token punctuation">.</span>clientY    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span> height<span class="token punctuation">:</span> <span class="token string">'100%'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span> onMouseMove<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleMouseMove<span class="token punctuation">}</span><span class="token operator">></span>        <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">}</span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span>Mouse render<span class="token operator">=</span><span class="token punctuation">{</span>mouse <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>  <span class="token operator">&lt;</span>p<span class="token operator">></span>鼠标的位置是 <span class="token punctuation">{</span>mouse<span class="token punctuation">.</span>x<span class="token punctuation">}</span>，<span class="token punctuation">{</span>mouse<span class="token punctuation">.</span>y<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">></span><span class="token comment" spellcheck="true">// children</span><span class="token operator">&lt;</span>Mouse<span class="token operator">></span>  <span class="token punctuation">{</span>mouse <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>鼠标的位置是 <span class="token punctuation">{</span>mouse<span class="token punctuation">.</span>x<span class="token punctuation">}</span>，<span class="token punctuation">{</span>mouse<span class="token punctuation">.</span>y<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>Mouse<span class="token operator">></span></code></pre><ul><li><p><strong>react children 类型</strong></p><p>children 可以是数组，函数，对象，字符串，数字，null</p></li></ul><h3 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h3><ul><li><p><strong>this.refs[‘ref’]</strong>(已淘汰)</p></li><li><p><strong>回调函数</strong></p><p>当我们传入一个回调函数给 ref 属性，react 会在组件挂载到真实 dom 后，把组件的实例传入函数，然后我们可以用一个值来接收这个实例</p><pre class=" language-ts"><code class="language-ts"><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>        <span class="token operator">&lt;</span>div<span class="token operator">></span>            <span class="token operator">&lt;</span>Buttion ref<span class="token operator">=</span><span class="token punctuation">{</span>ref<span class="token operator">=</span><span class="token operator">></span><span class="token keyword">this</span><span class="token punctuation">.</span>btnRef<span class="token operator">=</span>ref<span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用</span><span class="token keyword">this</span><span class="token punctuation">.</span>btnRef</code></pre></li><li><p><strong>createRef</strong></p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>btnRef <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>        <span class="token operator">&lt;</span>div<span class="token operator">></span>            <span class="token operator">&lt;</span>Buttion ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>btnRef<span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用</span><span class="token keyword">this</span><span class="token punctuation">.</span>btnRef<span class="token punctuation">.</span>current</code></pre></li></ul><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><ul><li><p><strong>旧的 context</strong>（不要记，了解即可）</p><p>使用：</p><p>父组件定义 childContextTypes，子组件 getChildContext，具体用法省略。。。</p><p>缺点：</p><p>1.代码冗余：代码量多</p><p>2.传递效率：虽然功能上 context 可以跨层级传递，但是本质上 context 也是同 props 一样一层一层的往下传递的，当层级过深的时候还是会出现效率问题</p><p>3.shouldComponentUpdate：由于 context 的传递也是一层一层传递，因此它也会受到 shouldComponent 的阻断</p></li><li><p><strong>新的 context 基本使用</strong></p></li></ul><pre class=" language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">const</span> MyContext <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span>defaultValue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// index.js</span><span class="token operator">&lt;</span>MyContext<span class="token punctuation">.</span>Provider value<span class="token operator">=</span><span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'zz'</span><span class="token punctuation">}</span><span class="token operator">></span> <span class="token comment" spellcheck="true">// 子组件</span>  <span class="token operator">&lt;</span>MyContext<span class="token punctuation">.</span>Consumer<span class="token operator">></span>        <span class="token punctuation">{</span><span class="token punctuation">{</span>name<span class="token punctuation">}</span> <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token operator">&lt;</span><span class="token operator">/</span>MyContext<span class="token punctuation">.</span>Consumer<span class="token operator">></span></code></pre><h3 id="React-其他-API"><a href="#React-其他-API" class="headerlink" title="React 其他 API"></a>React 其他 API</h3><ul><li><p><strong>Fragment</strong></p><pre class=" language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// 当我们想渲染一组组件，如列表，但不想为其添加额外父节点，可以使用Fragment。</span><span class="token comment" spellcheck="true">// key 是唯一可以传递给 Fragment 的属性。未来可能会添加对其他属性的支持，例如事件。</span><span class="token keyword">function</span> <span class="token function">Glossary</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>dl<span class="token operator">></span>      <span class="token punctuation">{</span>props<span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>        <span class="token comment" spellcheck="true">// 没有`key`，React 会发出一个关键警告</span>        <span class="token operator">&lt;</span>React<span class="token punctuation">.</span>Fragment key<span class="token operator">=</span><span class="token punctuation">{</span>item<span class="token punctuation">.</span>id<span class="token punctuation">}</span><span class="token operator">></span>          <span class="token operator">&lt;</span>dt<span class="token operator">></span><span class="token punctuation">{</span>item<span class="token punctuation">.</span>term<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>dt<span class="token operator">></span>          <span class="token operator">&lt;</span>dd<span class="token operator">></span><span class="token punctuation">{</span>item<span class="token punctuation">.</span>description<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>dd<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>React<span class="token punctuation">.</span>Fragment<span class="token operator">></span>      <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>dl<span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 短语法，不支持 key 或属性。</span><span class="token operator">&lt;</span><span class="token operator">></span>  <span class="token operator">&lt;</span>td<span class="token operator">></span>Hello<span class="token operator">&lt;</span><span class="token operator">/</span>td<span class="token operator">></span>  <span class="token operator">&lt;</span>td<span class="token operator">></span>World<span class="token operator">&lt;</span><span class="token operator">/</span>td<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">></span></code></pre></li><li><p><strong>forwardRef</strong></p><ol><li><p><strong>使用高阶组件引起的问题</strong></p><p>因为 key 和 ref 是特殊的配置，不能像属性一样传递给子组件，所以我们高阶组件以后，再对高阶组件使用 ref，拿到的是包裹组件的实例，不能拿到我们想要的被包裹组件的实例。没有 forwardRef 之前，我们需要在高阶组件内部获取被包裹组件的实例，然后通过回调传给父组件</p></li><li><p><strong>forwardRef 透传</strong></p></li></ol></li><li><p><strong>lazy 和 Suspense</strong></p><p>这项新功能使得可以不借助任何附加库就能通过代码分割（code splitting）延迟加载 react 组件。<br>之前我们要用 react-loadable 等库 达到这一目的</p><p>区分：动态加载组件的 loading 和 网络请求未返回数据的 loading</p><ol><li><p><strong>使用方式</strong></p><p>注意:React.lazy 和 Suspense 技术还不支持服务端渲染。</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">const</span> OtherComponent <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./OtherComponent'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>Suspense fallback<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&lt;</span>div<span class="token operator">></span>Loading<span class="token operator">...</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">}</span><span class="token operator">></span>        <span class="token operator">&lt;</span>OtherComponent <span class="token operator">/</span><span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>Suspense<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p><strong>react-loadable</strong></p></li></ol></li><li><p><strong>memo</strong></p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">const</span> MyComponent <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/* 使用 props 渲染 */</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>React.memo 为高阶组件<br>如果你的函数组件在给定相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 React.memo 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。以此提高性能</p><p>默认情况下其只会做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。例如使用 lodash 的 isEqual 函数</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/* 使用 props 渲染 */</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">areEqual</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> nextProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/*  如果把 nextProps 传入 render 方法的返回结果与  将 prevProps 传入 render 方法的返回结果一致则返回 true，  否则返回 false  */</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">default</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span>MyComponent<span class="token punctuation">,</span> areEqual<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>Portal</strong></p><pre class=" language-ts"><code class="language-ts">ReactDOM<span class="token punctuation">.</span><span class="token function">createPortal</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> container<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 fragment。</span><span class="token comment" spellcheck="true">// 第二个参数（container）是一个 DOM 元素。</span></code></pre><p>createPortal 的出现为 弹窗、对话框 等脱离文档流的组件开发提供了便利<br><a href="https://react.docschina.org/docs/portals.html">官方示例</a></p></li></ul><h3 id="Hooks-API"><a href="#Hooks-API" class="headerlink" title="Hooks API"></a>Hooks API</h3><ul><li><p><strong>什么是 Hooks</strong></p></li><li><p><strong>Hooks 的优势</strong></p><ol><li>减少层级的嵌套</li></ol></li></ul><h2 id="React-原理"><a href="#React-原理" class="headerlink" title="React 原理"></a>React 原理</h2><h3 id="React-到底是什么？"><a href="#React-到底是什么？" class="headerlink" title="React 到底是什么？"></a>React 到底是什么？</h3><ul><li><p><strong>源码目录</strong></p><pre class=" language-javascript"><code class="language-javascript">├── build <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> 构建后的输出目录├── fixtures <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> React 开发的测试用例├── packages <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> 源码目录，我们主要剖析目录│   ├── create<span class="token operator">-</span>subscription <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> 在组件里订阅额外数据的工具│   ├── events <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> 事件处理│   ├── interaction<span class="token operator">-</span>tracking <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> 跟踪交互事件│   ├── react <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> 核心代码│   ├── react<span class="token operator">-</span>art <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> 矢量图形库│   ├── react<span class="token operator">-</span>dom <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> DOM 渲染相关│   ├── react<span class="token operator">-</span>is <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> React 元素类型相关│   ├── react<span class="token operator">-</span>native<span class="token operator">-</span>renderer <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> react<span class="token operator">-</span>native 渲染相关│   ├── react<span class="token operator">-</span>noop<span class="token operator">-</span>renderer <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> Fiber 测试相关│   ├── react<span class="token operator">-</span>reconciler <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> React 调制器│   ├── react<span class="token operator">-</span>scheduler <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> 规划 React 初始化，更新等等│   ├── react<span class="token operator">-</span>test<span class="token operator">-</span>renderer <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> 实验性的 React 渲染器│   ├── shared <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> 通用代码│   ├── simple<span class="token operator">-</span>cache<span class="token operator">-</span>provider <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> 为 React 应用提供缓存│   ├── server <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> 服务端渲染│   ├── sfc <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> <span class="token punctuation">.</span>vue 文件解析│   ├── shared <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> 整个项目通用代码├── scripts <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> 公共的lint，build，test和release等相关的文件│   ├── eslint <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> 语法规则和代码风格│   ├── flow <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> Flow 类型声明│   ├── git <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> git钩子的目录│   ├── jest <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> JavaScript 测试目录│   ├── release <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> 自动发布新版本脚本│   ├── rollup <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> rollup 构建目录├── <span class="token punctuation">.</span>babelrc <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> babel 配置文件├── <span class="token punctuation">.</span>editorconfig <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> 编辑器语法规范配置├── <span class="token punctuation">.</span>eslintignore <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> eslint 忽略配置├── <span class="token punctuation">.</span>eslintrc <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> eslint 配置文件├── <span class="token punctuation">.</span>gitattributes <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> 给 attributes 路径名的简单文本文件├── <span class="token punctuation">.</span>gitignore <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> git 忽略配置├── <span class="token punctuation">.</span>mailmap <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> 邮件列表档案├── <span class="token punctuation">.</span>nvmrc <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> nvm 配置文件├── <span class="token punctuation">.</span>prettierrc<span class="token punctuation">.</span>js <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> prettierrc 配置文件├── <span class="token punctuation">.</span>watchmanconfig <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> watchman 配置文件├── appveyor<span class="token punctuation">.</span>yml <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> GitHub 托管项目的自动化集成├── AUTHORS <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> 开发者列表档案├── CHANGELOG<span class="token punctuation">.</span>md <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> 更新日志├── CODE_OF_CONDUCT<span class="token punctuation">.</span>md <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> Code <span class="token keyword">of</span> Conduct├── CONTRIBUTING<span class="token punctuation">.</span>md <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> Contributing to React├── dangerfile<span class="token punctuation">.</span>js <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> 提高 Code Review 体验├── netlify<span class="token punctuation">.</span>toml <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> 持续集成静态网站├── <span class="token keyword">package</span><span class="token operator">-</span>lock<span class="token punctuation">.</span>json <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> npm 加锁文件├── <span class="token keyword">package</span><span class="token punctuation">.</span>json <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> 项目管理文件├── README<span class="token punctuation">.</span>md <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> 项目文档├── yarn<span class="token punctuation">.</span>lock <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> yarn 加锁文件</code></pre></li><li><p><strong>了解：multirepo 和 monorepo</strong></p><p>通常，我们会根据业务或者是功能把 package 分别放入单独的 repository 中进行维护，此方式可以简单地称为 multirepo。而 monorepo 是将所有的相关 package 都放入一个 repository 来管理。例如 Babel 官方维护了众多独立的 plugin、olyfill、preset。遵循了 monorepo 的方式，将它们放入一个相同的 repo 中。</p><p>monorepo 优点：</p><ol><li><p>一个的 lint，build，test 和 release 流程；</p></li><li><p>统一的地方处理 issue；</p></li><li><p>方便管理版本和依赖；</p></li><li><p>跨项目操作和修改变得容易；</p></li></ol></li><li><p><strong>React 是什么？</strong></p><ol><li><p><strong>入口</strong></p><p>React 的核心入口文件是 packages/react/index.js:</p><pre class=" language-ts"><code class="language-ts"><span class="token string">'use strict'</span><span class="token punctuation">;</span><span class="token keyword">const</span> React <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./src/React'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// TODO: decide on the top-level export form.</span><span class="token comment" spellcheck="true">// This is hacky but makes it work with both Rollup and Jest.</span><span class="token keyword">module</span><span class="token punctuation">.</span>exports <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token keyword">default</span> <span class="token operator">||</span> React<span class="token punctuation">;</span></code></pre></li><li><p><strong>实际的 React</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> React <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 专门处理 children的函数</span>  <span class="token comment" spellcheck="true">// 因为children可以是数组，可以是函数，可以是null，也可能是number，string等类型，</span>  <span class="token comment" spellcheck="true">// 所以react给我们暴露出一个方便操作children的函数</span>  Children<span class="token punctuation">:</span> <span class="token punctuation">{</span>    map<span class="token punctuation">,</span>    forEach<span class="token punctuation">,</span>    count<span class="token punctuation">,</span>    toArray<span class="token punctuation">,</span>    only<span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 创建ref的函数</span>  createRef<span class="token punctuation">,</span>  Component<span class="token punctuation">,</span>  PureComponent<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 创建Context</span>  createContext<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//forwardRef 是 Ref 的转发，或者叫穿透，它能够让父组件访问到子组件的 Ref，从而操作子组件的 DOM</span>  forwardRef<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//lazy() 提供了动态 import 组件的能力，实现代码分割。</span>  lazy<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//memo() 只能作用在简单的函数组件上，本质是一个高阶函数，可以自动帮助组件执行shouldComponentUpdate()</span>  memo<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// Fragment组件其作用是可以将一些子元素添加到 DOM tree 上且不需要为这些元素提供额外的父节点，相当于 render 返回数组元素。</span>  Fragment<span class="token punctuation">:</span> REACT_FRAGMENT_TYPE<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//StrictMode 可以在开发阶段开启严格模式，发现应用存在的潜在问题，提升应用的健壮性</span>  StrictMode<span class="token punctuation">:</span> REACT_STRICT_MODE_TYPE<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//Suspense 作用是在等待组件时 suspend（暂停）渲染，并显示加载标识。搭配lazy使用</span>  Suspense<span class="token punctuation">:</span> REACT_SUSPENSE_TYPE<span class="token punctuation">,</span>  createElement<span class="token punctuation">:</span> __DEV__ <span class="token operator">?</span> createElementWithValidation <span class="token punctuation">:</span> createElement<span class="token punctuation">,</span>  cloneElement<span class="token punctuation">:</span> __DEV__ <span class="token operator">?</span> cloneElementWithValidation <span class="token punctuation">:</span> cloneElement<span class="token punctuation">,</span>  createFactory<span class="token punctuation">:</span> __DEV__ <span class="token operator">?</span> createFactoryWithValidation <span class="token punctuation">:</span> createFactory<span class="token punctuation">,</span>  isValidElement<span class="token punctuation">:</span> isValidElement<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 是否是react element</span>  version<span class="token punctuation">:</span> ReactVersion<span class="token punctuation">,</span>  unstable_ConcurrentMode<span class="token punctuation">:</span> REACT_CONCURRENT_MODE_TYPE<span class="token punctuation">,</span>  unstable_Profiler<span class="token punctuation">:</span> REACT_PROFILER_TYPE<span class="token punctuation">,</span>  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED<span class="token punctuation">:</span>    ReactSharedInternals<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li></ol></li></ul><h3 id="React-Component"><a href="#React-Component" class="headerlink" title="React Component"></a>React Component</h3><p>React Component 就是我们的类组件或者函数式组件, 是一个函数</p><h3 id="React-Element"><a href="#React-Element" class="headerlink" title="React Element"></a>React Element</h3><p>React Element 是类组件的 render 方法的返回值，或者函数组件的返回值，也就是我们写的 JSX，最后返回一个对象</p><pre class=" language-ts"><code class="language-ts">    <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">"App"</span><span class="token operator">></span><span class="token operator">&lt;</span>p<span class="token operator">></span>Hello Word<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// JSX 部分经 babel 转移后</span>React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">,</span><span class="token punctuation">{</span> className<span class="token punctuation">:</span> <span class="token string">"App"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"p"</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token string">"Hello Word"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 最后的返回值为</span>    <span class="token punctuation">{</span>      type<span class="token punctuation">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>      props<span class="token punctuation">:</span> <span class="token punctuation">{</span>        className<span class="token punctuation">:</span> <span class="token string">'app'</span><span class="token punctuation">,</span>        children<span class="token punctuation">:</span> <span class="token punctuation">{</span>          type<span class="token punctuation">:</span> <span class="token string">'p'</span>          children<span class="token punctuation">:</span> <span class="token string">'Hello Word'</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// createElement(type,props,chidren)包含三个参数</span>    <span class="token comment" spellcheck="true">// 如果type为字符串时，代表是普通的节点，如div，span</span>    <span class="token comment" spellcheck="true">// 如果type为一个函数或一个类时，它代表自定义的节点，如</span>    <span class="token keyword">class</span> <span class="token class-name">Button</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>        <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>                <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">"App"</span><span class="token operator">></span>                <span class="token operator">&lt;</span>p<span class="token operator">></span>Hello Word<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>              <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>            <span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 或者</span>    <span class="token keyword">const</span> Button <span class="token operator">=</span> <span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>            <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">"App"</span><span class="token operator">></span>                <span class="token operator">&lt;</span>p<span class="token operator">></span>Hello Word<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>        <span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// jsx部分转化为</span>    <span class="token punctuation">{</span>      type<span class="token punctuation">:</span> Button<span class="token punctuation">,</span>      props<span class="token punctuation">:</span> <span class="token punctuation">{</span>        className<span class="token punctuation">:</span> <span class="token string">'app'</span><span class="token punctuation">,</span>        children<span class="token punctuation">:</span> <span class="token punctuation">{</span>          type<span class="token punctuation">:</span> <span class="token string">'p'</span>          children<span class="token punctuation">:</span> <span class="token string">'Hello Word'</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token template-string"><span class="token string">``</span></span>`<span class="token operator">-</span> <span class="token operator">**</span>React 渲染器<span class="token operator">**</span>  React 的定位是一个构建用户界面的，使用 JavaScript 语言开发的 UI 库，可以使用多种方式渲染这些组件，输出用户界面，很大程度上达到了跨平台的能力，在这些不同场景，渲染的主体很明显是不一样的  <span class="token number">1</span><span class="token punctuation">.</span>  在 web 应用中，react<span class="token operator">-</span>dom 模块将 React 组件渲染为 DOM  <span class="token number">2</span><span class="token punctuation">.</span>  在 react<span class="token operator">-</span>native 中，react<span class="token operator">-</span>native<span class="token operator">-</span>render 将 React 组件渲染为移动端原生 View  <span class="token number">3</span><span class="token punctuation">.</span>  react<span class="token operator">-</span>art 将 React 组件渲染为矢量图形### React 渲染流程（不涉及 Fiber）<span class="token operator">-</span> <span class="token operator">**</span>首次渲染<span class="token operator">**</span>  <span class="token number">1</span><span class="token punctuation">.</span>  我们通过 <span class="token keyword">import</span> 引入了的 React Component（Class <span class="token class-name">Component</span> 或者 <span class="token keyword">Function</span> Component），为一个函数  <span class="token number">2</span><span class="token punctuation">.</span>  我们会用 JSX 的方式，使用一个<span class="token operator">&lt;</span>List <span class="token operator">/</span><span class="token operator">></span>（Component Element）或者<span class="token operator">&lt;</span>div <span class="token operator">/</span><span class="token operator">></span> <span class="token punctuation">(</span>Dom Element<span class="token punctuation">)</span>的 React Element，  <span class="token number">3</span><span class="token punctuation">.</span>  React Element 会被 createElement 函数转化为一个对象，对象的 type 可以为 List<span class="token punctuation">,</span> 指向我们引入的组件，或者为 <span class="token string">'div'</span><span class="token punctuation">,</span>表示 dom 节点  <span class="token number">4</span><span class="token punctuation">.</span>  子代 React Element 也会被转化一个对象，作为父对象的 props<span class="token punctuation">.</span>children 属性  <span class="token number">5</span><span class="token punctuation">.</span>  所以，我们的应用<span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">></span> <span class="token punctuation">,</span>会被转为为一个大的 React Element 树，也就是虚拟 DOM 树  <span class="token number">6</span><span class="token punctuation">.</span>  ReactDOM 的 render 方法会将我们的虚拟 DOM 树渲染为浏览器端的真实 DOM，并挂载到我们指定的容器中  <span class="token number">7</span><span class="token punctuation">.</span>  在挂载到真实 DOM 的过程中，会依次触发组件的生命周期函数（willMount，didMount）<span class="token operator">-</span> <span class="token operator">**</span>更新阶段<span class="token operator">**</span>  <span class="token number">1</span><span class="token punctuation">.</span>  我们的类组件会继承自 React<span class="token punctuation">.</span>Component 函数，Component 原型上含有 setState 函数  <span class="token number">2</span><span class="token punctuation">.</span>  当我们的通过 setState 更改或者 props 重新传入，触发组件的更新  <span class="token number">3</span><span class="token punctuation">.</span>  react 会通过 diff 算法，比对前后两个虚拟 DOM 树，计算出差异队列，处理并提交更新### ReactDom 挂载流程### React 类型与生命周期### React Diff<span class="token operator">-</span> <span class="token operator">**</span>传统 Diff<span class="token operator">**</span>  diff 算法即差异查找算法；对于 Html DOM 结构即为 tree 的差异查找算法；而对于计算两颗树的差异时间复杂度为 O（n<span class="token operator">^</span><span class="token number">3</span>）<span class="token punctuation">,</span>显然成本太高，React 不可能采用这种传统算法；<span class="token operator">-</span> <span class="token operator">**</span>React Diff<span class="token operator">**</span>  <span class="token number">1</span><span class="token punctuation">.</span>  <span class="token operator">**</span>diff 策略<span class="token operator">**</span>      React 用三个策略将 <span class="token function">O</span><span class="token punctuation">(</span>n<span class="token operator">^</span><span class="token number">3</span><span class="token punctuation">)</span>复杂度降为 <span class="token function">O</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>复杂度  <span class="token number">2</span><span class="token punctuation">.</span>  Tree Diff  <span class="token number">3</span><span class="token punctuation">.</span>  Component Diff  <span class="token number">4</span><span class="token punctuation">.</span>  Element Diff<span class="token operator">-</span> <span class="token operator">**</span>stack reconciler 和 fiber reconciler<span class="token operator">**</span>### 事件系统### React Fiber## react<span class="token operator">-</span>router### 基本使用<span class="token operator">-</span> <span class="token operator">**</span>JSX 配置方式<span class="token operator">**</span></code></pre>  <router>      <route path="/" component="{App}">        <route path="about" component="{About}">        <route path="inbox" component="{Inbox}">          <route path="messages/:id" component="{Message}">        </route>      </route>  </route></route></router>  ```<ul><li><p><strong>对象的配置方式</strong></p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">const</span> routeConfig <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>    component<span class="token punctuation">:</span> App<span class="token punctuation">,</span>    childRoutes<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'about'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> About <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'inbox'</span><span class="token punctuation">,</span>        component<span class="token punctuation">:</span> Inbox<span class="token punctuation">,</span>        childRoutes<span class="token punctuation">:</span> <span class="token punctuation">[</span>          <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/messages/:id'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> Message <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'messages/:id'</span><span class="token punctuation">,</span>            onEnter<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>nextState<span class="token punctuation">,</span> replaceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token function">replaceState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'/messages/'</span> <span class="token operator">+</span> nextState<span class="token punctuation">.</span>params<span class="token punctuation">.</span>id<span class="token punctuation">)</span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span>        <span class="token punctuation">]</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre></li></ul><h3 id="路由配置详解"><a href="#路由配置详解" class="headerlink" title="路由配置详解"></a>路由配置详解</h3><ul><li><strong>Router</strong></li><li></li></ul><h3 id="页面缓存与路由守卫"><a href="#页面缓存与路由守卫" class="headerlink" title="页面缓存与路由守卫"></a>页面缓存与路由守卫</h3><ul><li><p><strong>页面缓存</strong></p><p>react 中没有 keep-alive 组件, 如果想实现此功能需要自己实现，通过样式来控制组件的显示（display：none | block;），但是这可能会导致问题，例如切换组件时，无法使用动画；另一个实现思路可以使用 React.createPortal 把组件都挂载到了整个 App 的外面，然后把组件的 DOM 移动到需要展示的位置。</p></li><li><p><strong>路由守卫</strong></p><p>react-router V4 之后中没有路由守卫的 API，作者认为 JSX 更灵活，我们可以在执行渲染的过程中执行此操作，如果想实现此功能需要自己实现，可以使用 react-router 提供的另一个库，react-router-config，提供 matchRoutes 和 renderRoutes 两个函数，matchRoutrs 用于匹配路由，renderRoutes 用于渲染路由</p></li></ul><h3 id="react-router-redux"><a href="#react-router-redux" class="headerlink" title="react-router-redux"></a>react-router-redux</h3><ul><li><strong>react-router-redux 介绍</strong></li></ul><p>react-router-redux 将 react-router 和 redux 集成到一起，用 redux 的方式去操作 react-router。<br>例如，react-router 中跳转需要调用 router.push(path)，<br>集成了 react-router-redux 跳转可以 store.dispatch(push(url))。<br>本质上，是把 react-router 自己维护的状态，例如 location、history、path 等等，也交给 redux 管理。<br>一般情况下，是没有必要使用这个库的。</p><h3 id="react-router-V5"><a href="#react-router-V5" class="headerlink" title="react-router V5"></a>react-router V5</h3><p>此版本侧重于稳定性和兼容性，带来了一系列改进和新特性，并且完全向后兼容 4.x 版本，功能和改进很明显，但是没有破坏性的变化，所以如果已经使用了 4.x 的版本，则可以在不改变代码的情况下直接使用 v5 版本</p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dva&amp;umi&amp;redux</title>
      <link href="2022/11/04/dva-umi-redux/"/>
      <url>2022/11/04/dva-umi-redux/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><strong>app</strong></li></ul><ol><li><p>我们通过 dva(opts)创建的一个 app 是一个对象，包含 use,modal,router,start 等方法</p></li><li><p>调用 use 方法引入插件</p></li><li><p>使用 modal 方法，传入一个 modal，dva 会把 modal，push 进一个数组，effects 会按 saga 的启动<br>流程处理，reducers 会 redux 的流程处理</p></li><li><p>router 就是直接传入一个生成 router 的函数，dva 内部会为其传入 app 实例</p></li><li><p>start 就是完成所有的初始化，启动 saga 的监听等</p></li></ol><ul><li><strong>model</strong></li></ul><p>我们为需要数据管理的页面或者模块创建一个 model，包含：</p><ol><li><p>namespace</p><p>命名空间，对应全局 state 的属性，所以不能重复</p></li><li><p>state</p><p>当前页面的初始状态，优先级低于传给 dva() 的 opts.initialState</p><pre class=" language-ts"><code class="language-ts">app<span class="token punctuation">.</span><span class="token function">model</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  namespace<span class="token punctuation">:</span> <span class="token string">"home"</span><span class="token punctuation">,</span>  state<span class="token punctuation">:</span> <span class="token punctuation">{</span>    count<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 相当于</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">dva</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  initialState<span class="token punctuation">:</span> <span class="token punctuation">{</span>    home<span class="token punctuation">:</span> <span class="token punctuation">{</span>      count<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>effect</p><p>以 key/value 格式定义 effect。用于处理异步操作和业务逻辑，不直接修改 state</p><pre class=" language-ts"><code class="language-ts"><span class="token operator">*</span> <span class="token function">getListData</span><span class="token punctuation">(</span><span class="token punctuation">{</span>payload<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>call<span class="token punctuation">,</span> put<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> listData <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">call</span><span class="token punctuation">(</span>API<span class="token punctuation">.</span>getListData<span class="token punctuation">,</span> payload<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">yield</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    type<span class="token punctuation">:</span> <span class="token string">'setListData'</span><span class="token punctuation">,</span>    payload<span class="token punctuation">:</span> listData  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre></li><li><p>reducer</p><p>以 key/value 格式定义 reducer。用于处理同步操作，唯一可以修改 state 的地方，由 action 触发</p><pre class=" language-ts"><code class="language-ts"><span class="token function">setListData</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token punctuation">{</span>    <span class="token operator">...</span>state<span class="token punctuation">,</span>    listData<span class="token punctuation">:</span> action<span class="token punctuation">.</span>payload<span class="token punctuation">.</span>listData  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre></li><li><p>subscription</p><p>以 key/value 格式定义 subscription。subscription 是订阅，用于订阅一个数据源，然后根据需要 dispatch 相应的 action。在 app.start() 时被执行，数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等。</p></li></ol><h3 id="dva-使用"><a href="#dva-使用" class="headerlink" title="dva 使用"></a>dva 使用</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> dva <span class="token keyword">from</span> <span class="token string">"dva"</span><span class="token punctuation">;</span><span class="token keyword">import</span> createLoading <span class="token keyword">from</span> <span class="token string">"dva-loading"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> createLogger <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"redux-logger"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> createBrowserHistory <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"history"</span><span class="token punctuation">;</span><span class="token keyword">const</span> history <span class="token operator">=</span> <span class="token function">createBrowserHistory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 1. Initialize</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">dva</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  history<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 指定给路由用的 history，默认是 hashHistory</span>  initialState<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 指定初始state，优先级高于 model 中的 state，默认是 {}</span>  onAction<span class="token punctuation">:</span> <span class="token function">createLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 中间件</span>  <span class="token function">onEffect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// effect副作用发生的钩子</span>  <span class="token function">onReducer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// reducer的增强</span>  <span class="token function">onStateChange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// store的state变更的钩子</span>  <span class="token function">onHmr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 热更新的钩子</span>  <span class="token function">extraEnhancers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 额外的增强器</span>  <span class="token function">extraReducers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 额外的reducer</span>  <span class="token function">onError</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 错误发生的钩子</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 2. Plugins</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">createLoading</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//  createLoading()返回:</span><span class="token comment" spellcheck="true">//{</span><span class="token comment" spellcheck="true">//    extraReducers: extraReducers,</span><span class="token comment" spellcheck="true">//    onEffect: onEffect</span><span class="token comment" spellcheck="true">//  }</span><span class="token comment" spellcheck="true">// 所以dva-loading的原理是添加了额外的管理全局loading的reduce，</span><span class="token comment" spellcheck="true">// 并且在effect发生时dispatch一个更改loading的action</span><span class="token comment" spellcheck="true">// 在state的loading的effects里面以effect的（key/value）的方式表示effect的执行状态</span><span class="token comment" spellcheck="true">// 请求开始标记为 true ，请求结束标记为 false</span><span class="token comment" spellcheck="true">// 3. Model</span>app<span class="token punctuation">.</span><span class="token function">model</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./models/example1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">model</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./models/example2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 4. Router</span>app<span class="token punctuation">.</span><span class="token function">router</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./router"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 5. Start</span>app<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token string">"#root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="dva-图解"><a href="#dva-图解" class="headerlink" title="dva 图解"></a>dva 图解</h3><p><img src="https://raw.githubusercontent.com/s1p21/hexo/master/source/images/dva-pic.png" alt="图解 DAV"></p><h2 id="dva-源码解读"><a href="#dva-源码解读" class="headerlink" title="dva 源码解读"></a>dva 源码解读</h2><h3 id="dva-流程分析"><a href="#dva-流程分析" class="headerlink" title="dva 流程分析"></a>dva 流程分析</h3><p>dva 项目包含四个包：</p><ul><li><p><strong>dva-immer</strong></p></li><li><p><strong>dva-loading</strong></p><p>管理全局 loading 的插件</p></li><li><p><strong>dva-core</strong>（区分 dva 和 dva-core）</p><ol><li><p>我们执行 dva 的方法，const app = dva(opts)，会使用 dva-core 的 create 方法创建的 app</p></li><li><p>这时会新建 Plugin 的实例 plugin，使用 plugin.use(hooksAndOpts)，hooksAndOpts 就是上面的 opts</p></li><li><p>传入 hooksAndOpts 会被 plugin 实例的 hooks 属性收集，对 hooks 进行添加或重新赋值，详情看源码解析</p></li><li><p>最后 dva-core 的 create 方法返回的 app，包含 model，use，start 等方法，dva 是对其增加 router 和覆盖 start 等方法</p></li><li><p>当我们执行 app.model(model)方法，实际就是把 model 用 push 方法收集到一个数组，我们的 models 里面有 namespace,state,reducers 和 effects 以及 subscriptions</p></li><li><p>当我们执行 app.use(plugin),最终调用的是 Plugin 实例的 use 方法，和初始化传入的默认参数是一样的行为，所以 plugin 是一个对象，对象的 key 就是我们 opts 的 key</p></li><li><p>当我们执行 dva-core 的 app.start 方法，会创建 createSagaMiddleware 和 createPromiseMiddleware</p></li><li><p>然后遍历所有的 models，以每个 model 的 namespace 为 key，用 model 的 reducers 生成每个 model 或者叫每个页面的 reducer，形成全局 reducers（注意带 s 和不带 s）</p></li><li><p>获取每个 model 的 effects，对 saga 进行收集</p></li><li><p>plugin 的 hooks 的 onReducer 为添加的 reducer 增强器（reducerEnhancer）</p></li><li><p>plugin 的 hooks 的 extraReducers 为添加的额外 reducers（extraReducers）</p></li><li><p>combineReducers 方法合并全局的 reducers 和 extraReducers，reducerEnhancer 对其进行增强，返回最终的全局 reducers</p></li><li><p>然后通过 dva-core 的 createStore 方法传入 reducers，initialState，middlewares 等参数创建 reducer 的 store</p></li><li><p>创建 store 的过程中会通过 plugin 的 hooks 的 extraEnhancers 添加额外的增强器（extraEnhancers）</p></li><li><p>plugin 的 hooks 的 onAction 为添加额外的中间件（extraMiddlewares），最终的 middlewares = [routerMiddleware(history),promiseMiddleware,sagaMiddleware,…flatten(extraMiddlewares)]</p></li><li><p>最后的 enhancers = [applyMiddleware(…middlewares), …extraEnhancers]</p></li><li><p>最终的 store 通过 redux 的 createStore(reducers, initialState, composeEnhancers(…enhancers))创建</p></li><li><p>plugin 的 hooks 的 onStateChange 用 store 的 subscribe 方法进行监听</p></li><li><p>遍历所有的 saga，执行 sagaMiddleware.run 进行监听</p></li><li><p>运行所有的 subscriptions 监听</p></li></ol></li><li><p><strong>dva</strong></p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">export</span> fetch <span class="token keyword">from</span> <span class="token string">'isomorphic-fetch'</span><span class="token punctuation">;</span><span class="token keyword">export</span> dynamic <span class="token keyword">from</span> <span class="token string">'./dynamic'</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token punctuation">{</span> connect<span class="token punctuation">,</span> connectAdvanced<span class="token punctuation">,</span> useSelector<span class="token punctuation">,</span> useDispatch<span class="token punctuation">,</span> useStore<span class="token punctuation">,</span> shallowEqual <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// react-redux</span><span class="token keyword">export</span> <span class="token punctuation">{</span> bindActionCreators <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// redux</span><span class="token keyword">export</span> <span class="token punctuation">{</span> router <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// import * as router from 'react-router-dom';</span><span class="token keyword">export</span> <span class="token punctuation">{</span> saga <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// dva-core</span><span class="token keyword">export</span> <span class="token punctuation">{</span> routerRedux <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// connected-react-router, 和react-router-redux 一样，绑定路由到redux</span><span class="token comment" spellcheck="true">// 这样就可以通过dispatch一个action的方式跳转路由</span><span class="token keyword">export</span> <span class="token punctuation">{</span> createBrowserHistory<span class="token punctuation">,</span> createMemoryHistory<span class="token punctuation">,</span> createHashHistory <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// history库提供</span></code></pre><p>这个包导出的内容可以分为三个部分：</p><ol><li><p>dva 函数传入 opts 配置对象<br>使用 connected-react-router，用 redux 管理路由<br>使用 dva-core 的 create 方法创建的 app<br>添加 router 方法<br>改变 app 的 start 方法<br>start 方法如果传入 container， 在 container 容器外加上一层 dva 的 Provider，并使用 ReactDom 挂载到真实 DOM<br>如果没有传入 container，则只渲染 dva 的 Provider 的 React Element</p></li><li><p>dynamic 方法，动态加载函数</p></li><li><p>三方模块部分 API 的直接导出，如 isomorphic-fetch，redux，redux-saga，react-route，react-router-redux 等的 API</p></li></ol></li></ul><h3 id="dva-core"><a href="#dva-core" class="headerlink" title="dva-core"></a>dva-core</h3><ul><li><p><strong>checkModel.js</strong></p><ol><li>检查 model 的 namespace 必须被定义，必须是字符串并且唯一</li><li>state 可以为任何值</li><li>reducers 可以为空，PlainObject 或者数组</li><li>effects 可以为空，PlainObject</li><li>subscriptions 可以为空，PlainObject，subscription 必须为函数</li></ol></li><li><p><strong>constants.js</strong><br>就定义了一个 namespace 的分割符为 NAMESPACE_SEP = ‘/‘的常量</p></li><li><p><strong>createPromiseMiddleware.js</strong></p><p>创建 createPromiseMiddleware 的函数，主要是判断 aciton 的 type 是否是 effect 的 type<br>如果是，为其创建一个 promise 对象</p></li><li><p><strong>getReducers.js</strong></p><p>把我们每个 model 的 reducers 通过 handlerActions 函数转化为，能处理 action 的 reducer</p></li><li><p><strong>getSaga.js</strong></p><p>需要较深理解 saga。。。</p></li><li><p><strong>handleAction.js</strong></p><p>**注意!!!**：<br>全局最后的 reduce 只有一个，一个 model 里面的 reducers，是一个 key 值（也就是 action 的 type）<br>对应一个 reducer，它应该转化成像 switch，case 那样能通过判断 action 的 type 来使用对应 reducer 的函数</p><p>类似 redux-actions 的 handleActions</p></li><li><p><strong>prefixNamespace.js</strong></p><ol><li>为 model 里面的 reducers 和 sagas 的 key 加上 <strong>namespace/</strong> 的前缀</li><li>reducers 为数组的情况，第一个值为 reducers，第二个为 enhancer（例如：reducers: [realReducers, enhancer]）</li></ol></li><li><p><strong>prefixType.js</strong></p><p>为 action 的 type 加上 <strong>namespace/</strong> 的前缀</p></li><li><p><strong>prefixedDispatch.js</strong></p><p>为 dispatch 函数派发 action 的 type 加上 <strong>namespace/</strong> 的前缀，就是用的 prefixType 方法</p></li><li><p><strong>subscription.js</strong></p><p>处理所有 subscription 的函数</p></li><li><p><strong>utils.js</strong></p><p>工具函数</p></li><li><p><strong>createStore.js</strong></p><p>创建 redux 的 store 的函数</p></li><li><p><strong>index.js</strong></p><p>dva-core 的入口</p></li></ul><h2 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h2><h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><ul><li><p><strong>react 本身怎样进行状态的管理（组件间通信）？</strong></p><p>对于组件本身而言，state 能很好的管理其本身的状态，通过 props 传递 callback 函数，也可以使父子组件能很好的通信</p><p>但是如果两个通信的组件之间跨度比较大，就需要在两个组件的最小父节点，管理两个组件的状态，如果层级比较深，就会造成很多中间组件需要传递无用的 props，容易造成代码逻辑的混乱</p><p>另一种组件通信的方式是使用 emitter 等第三方库，通过发布订阅模式管理组件的通信，缺点是在代码书写中，事件在接收方不容易体现出来，造成代码逻辑的不清晰</p></li></ul><h3 id="flux-架构"><a href="#flux-架构" class="headerlink" title="flux 架构"></a>flux 架构</h3><p>redux 是 flux 架构的变种之一</p><h3 id="redux-三大原则"><a href="#redux-三大原则" class="headerlink" title="redux 三大原则"></a>redux 三大原则</h3><p>首先说明，Redux 和 React 之间没有直接关系。但是 Redux 和 React 搭配起来用最好，因为这类库允许你以 state 形式来描述界面，Redux 通过 action 的形式来发起 state 变化。</p><ul><li><strong>单一数据源</strong></li></ul><p>对比 mobx，flux 的多数据源，redux 应用只存在唯一一个 store，store 中存在唯一一个 state，也就是全局的状态（store 中还包含 substibe，dispatch 等方法）</p><ul><li><p><strong>State 是只读的</strong></p><p>state 是只读的，唯一改变 state 的方式就是，通过 store 的 dispatch 方法触发一个 action，action 是一个描述事件的普通对象，唯一一个必要的参数就是 type</p></li><li><p><strong>使用纯函数来执行修改</strong></p><p>为了描述 action 如何改变 state，需要编写 reduces，reducer 只是一些纯函数，它接收先前的 state 和派发的 action，并返回新的 state，随着应用的变法，我们可以按页面模块或者任务拆分成多个小的 reducers，分别独立的操作，最后通过，combineReducer 把所有小的 reducers 合并成一个大的 reducer</p><p><img src="/./images/redux.jpg"></p></li></ul><h3 id="redux-核心概念"><a href="#redux-核心概念" class="headerlink" title="redux 核心概念"></a>redux 核心概念</h3><ul><li><p><strong>store</strong></p><p>通过 createStore 函数创建，一个应用全局只能有一个 store，在应用的最外层</p></li><li><p><strong>state</strong></p><p>整个应用的状态，存在于 store 中</p></li><li><p><strong>subscribe</strong></p><p>store 的方法，把 listeners 添加到数组中</p></li><li><p><strong>action</strong></p><p>action 本质上是普通的 js 对象，我们约定，action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作</p><p>多数情况下，type 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放 action。</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">const</span> ADD_TODO <span class="token operator">=</span> <span class="token string">"ADD_TODO"</span><span class="token punctuation">;</span></code></pre><pre class=" language-ts"><code class="language-ts"><span class="token punctuation">{</span>  type<span class="token punctuation">:</span> ADD_TODO<span class="token punctuation">,</span>  text<span class="token punctuation">:</span> <span class="token string">'Build my first Redux app'</span><span class="token punctuation">}</span></code></pre></li><li><p><strong>action creator</strong></p><p>action creator 函数就是生成相同 type 的 action 的方法。</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">addTodo</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token punctuation">{</span>    type<span class="token punctuation">:</span> ADD_TODO<span class="token punctuation">,</span>    text<span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p><strong>dispatch</strong></p><p>store 的方法，用于派发一个 action</p></li><li><p><strong>reducer</strong></p><p>应该是”纯”函数，返回一个新的更新后的 state</p></li></ul><h3 id="redux-总结"><a href="#redux-总结" class="headerlink" title="redux 总结"></a>redux 总结</h3><p>redux 和 mvvm 一样是一种设计模式，可以用任何语言实现，官方实现是 js</p><p>redux 完整使用流程：</p><ol><li>首先通过 createStore 创建 store，需要传入一个必须的 reducer，store 内部管理着一个 state，可以通过 store.getState()获取</li><li>同时 store 还包含 subscribe,dispatch 等方法</li><li>我们在组件上使用 store.subscribe(监听函数)订阅视图，store 内部管理者一个数组，存放监听函数</li><li>我们不能直接修改 state，只能表达要修改的意图，通过 store.dispatch(action)</li><li>action 是一个纯对象，包含必要的 type，和其他任意的数据</li><li>这时 store 内部的 reducer，传入我们当前的 state，和 action，计算出新的 state</li><li>然后会遍历所有的监听函数并执行</li><li>组件拿到新的 state，并重新渲染，完成状态的同步</li></ol><h3 id="redux-表示法"><a href="#redux-表示法" class="headerlink" title="redux 表示法"></a>redux 表示法</h3><p>react 表示法<br><img src="https://raw.githubusercontent.com/s1p21/hexo/master/source/images/react-pic.png"></p><p>redux 表示法<br><img src="https://raw.githubusercontent.com/s1p21/hexo/master/source/images/redux-pic.png"></p><h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h3><p>默认情况下，createStore() 所创建的 store 没有使用 middleware，所以只支持同步数据流</p><p>reducer 也是一个纯函数，应该有确定的输入和输出</p><p>但是往往，我们需要去服务器请求数据，读取文件等等异步事件</p><h3 id="redux-插件机制"><a href="#redux-插件机制" class="headerlink" title="redux 插件机制"></a>redux 插件机制</h3><p>redux 的</p><h3 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h3><p>react-redux 是 redux 的在 react 中使用的绑定库</p><p>那么，redux 如何在 react 应用中使用呢，如何将 组件需要的 state 和 dispatch 注入到组件中，state 更新时驱动组件重新渲染？react-redux 就是专门负责干这个的,可以简单的理解，它只做了两步，一步是在全局提供一个 Store，我们的任意子组件都能获取到 Store，另一步实在我们需要状态管理的组件上，使用高阶组件，订阅监听函数，把我们需要的 state，和 dispatch 注入到组件的属性里面，这样，我们就可以在组件里面，使用 this.props[我们需要的 state]，和 this.props.dispatch()触发一个 action</p><ul><li><p><strong>Provider</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">createStore</span><span class="token punctuation">(</span>  <span class="token function">combineReducers</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span>homeReducer <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">applyMiddleware</span><span class="token punctuation">(</span>thunk<span class="token punctuation">,</span> logger<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>Provider store<span class="token operator">=</span><span class="token punctuation">{</span>store<span class="token punctuation">}</span><span class="token operator">></span>  <span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>Provider<span class="token operator">></span><span class="token punctuation">;</span></code></pre></li><li><p><strong>Connect</strong></p><ol><li><strong>mapStateToProps</strong></li><li><strong>mapDispatchToProps</strong></li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">mapStateToProps</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token punctuation">{</span> todos<span class="token punctuation">:</span> state<span class="token punctuation">.</span>todos <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> mapDispatchToProps <span class="token operator">=</span> <span class="token punctuation">{</span>  addTodo<span class="token punctuation">,</span>  deleteTodo<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">connect</span><span class="token punctuation">(</span>mapStateToProps<span class="token punctuation">,</span> mapDispatchToProps<span class="token punctuation">)</span><span class="token punctuation">(</span>TodoApp<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol start="3"><li><strong>额外配置</strong></li></ol><p>常见配置 connect(mapStateToProps,mapDispatchToProps,mergeProps,{withRef: true})</p><p>会给高阶组件一个静态方法 getWrappedInstance()，这样就可以不用自己透传 ref 了</p></li></ul><h2 id="redux-异步方案"><a href="#redux-异步方案" class="headerlink" title="redux 异步方案"></a>redux 异步方案</h2><h3 id="异步方案之-redux-thunk"><a href="#异步方案之-redux-thunk" class="headerlink" title="异步方案之 redux-thunk"></a>异步方案之 redux-thunk</h3><ul><li><strong>redux-thunk 源码</strong></li></ul><pre class=" language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// 去掉extraArgument后</span><span class="token keyword">const</span> thunk <span class="token operator">=</span>  <span class="token punctuation">(</span><span class="token punctuation">{</span> dispatch<span class="token punctuation">,</span> getState <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>  <span class="token punctuation">(</span>next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>  <span class="token punctuation">(</span>action<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> action <span class="token operator">===</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">action</span><span class="token punctuation">(</span>dispatch<span class="token punctuation">,</span> getState<span class="token punctuation">,</span> extraArgument<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">next</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 因为 applyMiddleware函数，会先将middleware依次执行并传入（{getstate,dispatch}）</span><span class="token comment" spellcheck="true">// 而后componse函数会依次为前一个middleware传入下一个middleware，最后一个middleware执行的是dispath（aciton）</span><span class="token comment" spellcheck="true">// middlewares是有先后顺序的，可以根据官方文档配置</span></code></pre><p>修改 dispatch 函数，如果是一个对象，则直接 dispatch 这个 action，如果是一个函数，则执行函数，在函数内部在触发 dispatch</p><ul><li><strong>redux 的插件为什么要这样写</strong></li></ul><pre class=" language-ts"><code class="language-ts">形如： <span class="token punctuation">(</span><span class="token punctuation">{</span> dispatch<span class="token punctuation">,</span> getState <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>action<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//因为在applyMiddleware中</span><span class="token keyword">const</span> middlewareAPI <span class="token operator">=</span> <span class="token punctuation">{</span>    getState<span class="token punctuation">:</span> store<span class="token punctuation">.</span>getState<span class="token punctuation">,</span>    dispatch<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">const</span> chain <span class="token operator">=</span> middlewares<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>middleware <span class="token operator">=</span><span class="token operator">></span> <span class="token function">middleware</span><span class="token punctuation">(</span>middlewareAPI<span class="token punctuation">)</span><span class="token punctuation">)</span>dispatch <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token operator">...</span>chain<span class="token punctuation">)</span><span class="token punctuation">(</span>store<span class="token punctuation">.</span>dispatch<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 所以第一个参数是（{dispatch, getState }）是redux注入的</span><span class="token comment" spellcheck="true">// compose函数把插件数据进行链式调用，所以 第二个参数是 next 是指的下一个插件</span></code></pre><ul><li><strong>react+redux+redux-thunk 实例</strong></li></ul><h3 id="其他异步方案"><a href="#其他异步方案" class="headerlink" title="其他异步方案"></a>其他异步方案</h3><p>redux-promise redux-saga 等等</p><h2 id="redux-源码剖析"><a href="#redux-源码剖析" class="headerlink" title="redux 源码剖析"></a>redux 源码剖析</h2><h3 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h3><p>createStore 通过传入必须的 reducer，可选的 preloadedState，和可选的增强器，返回一个 store 对象<br>主要包含 subscribe（订阅监听函数到内部 listener 数组），dispatch（内部的 reducer 接受 state 和 action，返回新的 state，同时触发所有的监听函数），和 getState（获取当前的 state）</p><pre class=" language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// 去掉了类型和参数校验的createStore</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">createStore</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> preloadedState<span class="token punctuation">,</span> enhancer<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 如果第二个参数没有传入初始的state，而是传入了enhancer(applyMiddleware函数调用的返回值，也是一个函数), 那就将第二个参数作为enhancer</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> preloadedState <span class="token operator">===</span> <span class="token string">"function"</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> enhancer <span class="token operator">===</span> <span class="token string">"undefined"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    enhancer <span class="token operator">=</span> preloadedState<span class="token punctuation">;</span>    preloadedState <span class="token operator">=</span> undefined<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> enhancer <span class="token operator">!==</span> <span class="token string">"undefined"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// enhancer为增强器，主要为增强dispatch函数，理解要看 applyMiddleware</span>    <span class="token keyword">return</span> <span class="token function">enhancer</span><span class="token punctuation">(</span>createStore<span class="token punctuation">)</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> preloadedState<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">let</span> currentReducer <span class="token operator">=</span> reducer<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当前reducer</span>  <span class="token keyword">let</span> currentState <span class="token operator">=</span> preloadedState<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当前state</span>  <span class="token keyword">let</span> currentListeners <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当前listeners</span>  <span class="token keyword">let</span> nextListeners <span class="token operator">=</span> currentListeners<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 下一个listens</span>  <span class="token keyword">let</span> isDispatching <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 是否dispatch状态中</span>  <span class="token comment" spellcheck="true">// 获取当前state</span>  <span class="token keyword">function</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> currentState<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 将监听函数push到listeners数组，返回一个卸载监听函数的方法</span>  <span class="token keyword">function</span> <span class="token function">subscribe</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    <span class="token keyword">let</span> isSubscribed <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span>    nextListeners<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isSubscribed<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      isSubscribed <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>      <span class="token keyword">const</span> index <span class="token operator">=</span> nextListeners<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span>      nextListeners<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      currentListeners <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 最终我们在我们的组件里会调用的dispatch方法，如果有异步事件会被加强，最后还是会走此事件</span>  <span class="token keyword">function</span> <span class="token function">dispatch</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      isDispatching <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// reducer接受当前的state和action，返回当前新的state</span>      currentState <span class="token operator">=</span> <span class="token function">currentReducer</span><span class="token punctuation">(</span>currentState<span class="token punctuation">,</span> action<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>      isDispatching <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 遍历所有的listeners，然后执行</span>    <span class="token keyword">const</span> listeners <span class="token operator">=</span> <span class="token punctuation">(</span>currentListeners <span class="token operator">=</span> nextListeners<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> listeners<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> listener <span class="token operator">=</span> listeners<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token function">listener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> action<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 当store被创建的时候，dispatch一个INIT的action，所有的reducer返回他们初始的state，构成初始的state树</span>  <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span> type<span class="token punctuation">:</span> ActionTypes<span class="token punctuation">.</span>INIT <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">{</span>    dispatch<span class="token punctuation">,</span>    subscribe<span class="token punctuation">,</span>    getState<span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h3><p>这个函数是用来整合多个 reducers 的, 因为 createStore 只接受一个 reducer，这个整合的过程就是将所有的 reducer 存在一个对象里。当 dispatch 一个 action 的时候，通过遍历每一个 reducer, 来计算出每个 reducer 的 state, 其中用到的优化就是每遍历一个 reducer 就会判断新旧的 state 是否发生了变化, 最后决定是返回旧 state 还是新 state</p><pre class=" language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// 这里的reducers是{key: reducer,key:reducer}的对象</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">combineReducers</span><span class="token punctuation">(</span>reducers<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> reducerKeys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>reducers<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 最终的reducers对象，只是对传入的reducers不合法的进行过滤</span>  <span class="token keyword">const</span> finalReducers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> reducerKeys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> key <span class="token operator">=</span> reducerKeys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> reducers<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      finalReducers<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> reducers<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">const</span> finalReducerKeys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>finalReducers<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 返回最终的reducer</span>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">combination</span><span class="token punctuation">(</span>state <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> hasChanged <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> nextState <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 每当dispatch一个action，遍历所有的reducer，生成一个{key:state,key:state}的全局state</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> finalReducerKeys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> key <span class="token operator">=</span> finalReducerKeys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">const</span> reducer <span class="token operator">=</span> finalReducers<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">const</span> previousStateForKey <span class="token operator">=</span> state<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">const</span> nextStateForKey <span class="token operator">=</span> <span class="token function">reducer</span><span class="token punctuation">(</span>previousStateForKey<span class="token punctuation">,</span> action<span class="token punctuation">)</span><span class="token punctuation">;</span>      nextState<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> nextStateForKey<span class="token punctuation">;</span>      hasChanged <span class="token operator">=</span> hasChanged <span class="token operator">||</span> nextStateForKey <span class="token operator">!==</span> previousStateForKey<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 判断是否有state发生改变，发生改变则返回新的state</span>    hasChanged <span class="token operator">=</span>      hasChanged <span class="token operator">||</span> finalReducerKeys<span class="token punctuation">.</span>length <span class="token operator">!==</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">return</span> hasChanged <span class="token operator">?</span> nextState <span class="token punctuation">:</span> state<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h3><p>applyMiddleware 返回一个 enhancer，enhancer 接收一个 creatStore，会在内部创建一个 store，然后对该 store 的 dispatch 函数进行改造</p><p>改造的具体方式是通过 compose 来构造一个 dispatch 链，链的具体形式就是**[中间件 1，中间件 2, ……, 中间件 N, store.dispatch]**</p><p>然后将增强的 dispatch 作为 store 新的 dispatch 暴露给用户</p><p>那用户每次 dispatch 的时候，就会依次执行每个中间件，执行完当前的，会将执行权交给下一个，直到 reducer 中，计算出新的 state</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">applyMiddleware</span><span class="token punctuation">(</span><span class="token operator">...</span>middlewares<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>createStore<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>    <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">createStore</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">let</span> dispatch <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>          <span class="token string">"Dispatching while constructing your middleware is not allowed. "</span> <span class="token operator">+</span>            <span class="token string">"Other middleware would not be applied to this dispatch."</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token keyword">const</span> middlewareAPI <span class="token operator">=</span> <span class="token punctuation">{</span>        getState<span class="token punctuation">:</span> store<span class="token punctuation">.</span>getState<span class="token punctuation">,</span>        dispatch<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token keyword">const</span> chain <span class="token operator">=</span> middlewares<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>middleware<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">middleware</span><span class="token punctuation">(</span>middlewareAPI<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      dispatch <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token operator">...</span>chain<span class="token punctuation">)</span><span class="token punctuation">(</span>store<span class="token punctuation">.</span>dispatch<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token punctuation">{</span>        <span class="token operator">...</span>store<span class="token punctuation">,</span>        dispatch<span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="bindActionCreator-s"><a href="#bindActionCreator-s" class="headerlink" title="bindActionCreator(s)"></a>bindActionCreator(s)</h3><p>只是把我们平常的写法换了一个形式，更符合函数式思想？</p><pre class=" language-ts"><code class="language-ts">  <span class="token keyword">function</span> <span class="token function">bindActionCreator</span><span class="token punctuation">(</span>actionCreator<span class="token punctuation">,</span> dispatch<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">dispatch</span><span class="token punctuation">(</span>actionCreator<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 平时的写法</span>  <span class="token punctuation">(</span>dispatch<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>    getList<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token function">actionCreator</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 使用 bindActionCreator 后的写法</span>  <span class="token punctuation">(</span>dispatch<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>    getList<span class="token punctuation">:</span> <span class="token function">bindActionCreators</span><span class="token punctuation">(</span>actionCreator<span class="token punctuation">,</span> dispatch<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h3><p>插件机制的核心代码<br>中间件组成的一个数组，最终在前一个中间件中执行下一个中间件，最后依次返回上一个中间件的函数上下文中<br>最后形成一个先入后出的洋葱模型</p><pre class=" language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// 供applyMiddleware使用</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token operator">...</span>funcs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    <span class="token keyword">return</span> funcs<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="redux-源码总结"><a href="#redux-源码总结" class="headerlink" title="redux 源码总结"></a>redux 源码总结</h3><ol><li><p>我们可以这样理解，从 applyMiddleware 开始看，这是一个柯里化函数，先后接受 middlewares，createStore 函数，createStore 参数，最后返回一个 store</p></li><li><p>然后我们 applyMiddleware(middlewares)的返回值为一个 enhancer</p></li><li><p>这时我们转回 createStore 函数，当我们传入 enhancer 时，最终会以 enhancer(createStore)(reducer, preloadedState)这个柯里化函数创建 store</p></li><li><p>这个柯里化函数，会对 createStore 创建 store 的 dispatch 函数进行加强</p></li><li><p>加强的方式就是形成一个 middleware 的调用链，可以实现 log，thunk 等各种功能</p></li><li><p>我们通过 store 的 subscribe 方法添加监听到 listeners 数组</p></li><li><p>通过 store 的 dispatch 方法，触发所有的监听</p></li><li><p>bindActionCreators 是一个单独的方法</p></li></ol><h2 id="umi"><a href="#umi" class="headerlink" title="umi"></a>umi</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>umi 是一个可插拔的企业级 react 应用框架。umi 以路由为基础的，支持路由级的按需加载。然后配以完善的插件体系，覆盖从源码到构建产物的每个生命周期，支持各种功能扩展和业务需求</p><p>roadhog 是另一个构建工具，是基于 webpack 的封装工具，目的是简化 webpack 的配置</p><p>umi 可以简单地理解为 roadhog + 路由，辅以一套插件机制，目的是通过框架的方式简化 React 开发</p><p>umi 强烈推荐使用 dva 的数据流方案，也就是只使用 dva 的核心功能</p><h3 id="umi-架构"><a href="#umi-架构" class="headerlink" title="umi 架构"></a>umi 架构</h3><p><img src="/images/umi.png"></p><h3 id="umi-能帮我做什么"><a href="#umi-能帮我做什么" class="headerlink" title="umi 能帮我做什么"></a>umi 能帮我做什么</h3><ol><li>使用 create-umi 的脚手架，搭建基础的项目架构</li><li>根据其目录约定，可以自动帮我们生成 dva 的 models 和路由</li><li>全局布局可以通过路由配置的方式帮我们添加</li><li>提供默认的配置，简化 webpack 的配置</li><li>引入一个插件级</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单页应用路由原理</title>
      <link href="2022/11/04/dan-ye-ying-yong-lu-you-yuan-li/"/>
      <url>2022/11/04/dan-ye-ying-yong-lu-you-yuan-li/</url>
      
        <content type="html"><![CDATA[<h3 id="补充知识：window-location"><a href="#补充知识：window-location" class="headerlink" title="补充知识：window.location"></a>补充知识：window.location</h3><pre class=" language-js"><code class="language-js">    http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">172.16</span><span class="token punctuation">.</span><span class="token number">49.154</span><span class="token punctuation">:</span><span class="token number">3000</span><span class="token operator">/</span>search<span class="token operator">?</span>q<span class="token operator">=</span>URL#search    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>href<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// http://172.16.49.154:3000/search?q=URL#search</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>protocol<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// http:</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>host<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 172.16.49.154:3000</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>hostname<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 172.16.49.154</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3000</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>pathname<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// search</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>search<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ?q=UR</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// #search</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>origin<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// http://172.16.49.154:3000</span></code></pre><ol><li><strong>Location.reload()</strong></li></ol><p>重新加载来自当前 URL的资源。他有一个特殊的可选参数，类型为 Boolean，该参数为true时会导致该方法引发的刷新一定会从服务器上加载数据。如果是 false或没有制定这个参数，浏览器可能从缓存当中加载页面。</p><ol start="2"><li><strong>Location.replace()</strong></li></ol><p>用给定的URL替换掉当前的资源。与 assign() 方法不同的是用 replace()替换的新页面不会被保存在会话的历史 History中，这意味着用户将不能用后退按钮转到该页面。</p><h3 id="补充知识：window-history-和-History"><a href="#补充知识：window-history-和-History" class="headerlink" title="补充知识：window.history 和 History"></a>补充知识：window.history 和 History</h3><p>window.history 是一个只读属性，用来获取 History 对象的引用，History 对象提供了操作浏览器会话历史（浏览器地址栏中访问的页面，以及当前页面中通过框架加载的页面）的接口。</p><ol><li><strong>History.length</strong></li></ol><p>会话历史中元素的数目，包括当前加载的页</p><ol start="2"><li><p><strong>History.state</strong></p><p>返回一个表示历史堆栈顶部的状态的值。</p></li><li><p><strong>History 的 back / forward / go 方法</strong></p><p>back()和 forward()表示前往上一页或者下一页, 用户可点击浏览器左上角的返回按钮和前进按钮模拟此方法. 等价于 history.go(-1)或者 history.go(1)</p><p>go（）通过当前页面的相对位置从浏览器历史记录( 会话记录 )加载页面，当整数参数超出界限时，那么这个方法没有任何效果也不会报错</p></li><li><p><strong>History.pushState / repalceState</strong></p><p>pushState() 和 repalceState 按指定的名称和 URL（如果提供该参数）将数据 push 进会话历史栈或者更新历史栈上最新的入口，页面不会跳转。</p></li></ol><pre class=" language-js"><code class="language-js">   <span class="token comment" spellcheck="true">// pushState() 需要三个参数: 一个状态对象, 一个标题 (目前被忽略), 和 (可选的) 一个URL</span>   history<span class="token punctuation">.</span><span class="token function">pushState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>foo<span class="token punctuation">:</span> <span class="token string">"bar"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token string">"page 2"</span><span class="token punctuation">,</span> <span class="token string">"bar.html"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol start="5"><li><p><strong>window.popstate 事件</strong></p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//</span>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'popstate'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol><h3 id="history-js-库"><a href="#history-js-库" class="headerlink" title="history.js 库"></a>history.js 库</h3><p>以创建 history 路由进行分析：（方便区分，分为 window.history 和 history 库）</p><ol><li><p><strong>辅助函数</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>    createLocation    <span class="token comment" spellcheck="true">// 创建history.location格式的对象</span>    <span class="token comment" spellcheck="true">// 类似 {key: '',state: '',pathname: '',search: '',hash: ''}</span>    <span class="token comment" spellcheck="true">// createLocation(path, state, key, currentLocation)</span>    <span class="token comment" spellcheck="true">// 入参path可以为string类型或者包含 {pathname: '',search: '',hash: ''}的对象</span>    <span class="token comment" spellcheck="true">// state为一个对象，初始为window.history的state，push，replace等方法可以传入一个state，history把它用来当做传入下一个页面的参数来读取</span><span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./LocationUtils'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span>  addLeadingSlash<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 路径最前面加斜杠</span>  stripTrailingSlash<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 路径最后面去斜杠</span>  hasBasename<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 创建history时，是否传入了basename属性</span>  stripBasename<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 去掉basename</span>  createPath <span class="token comment" spellcheck="true">// 创建完成路径 pathname + search + hash</span><span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./PathUtils'</span><span class="token punctuation">;</span><span class="token keyword">import</span> createTransitionManager <span class="token keyword">from</span> <span class="token string">'./createTransitionManager'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span>  canUseDOM<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 是否可以使用DOM API</span>  getConfirmation<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 跳转前确认的弹框</span>  supportsHistory<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 是否支持H5的History API</span>  supportsPopStateOnHashChange<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 是否支持onPopstate事件</span>  isExtraneousPopstateEvent <span class="token comment" spellcheck="true">// 源码注释：Ignore extraneous popstate events in WebKit.</span><span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./DOMUtils'</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>createBrowserHistory</strong></p></li></ol><pre class=" language-js"><code class="language-js"> <span class="token comment" spellcheck="true">// transitionManager 为一个发布订阅模式，</span> <span class="token comment" spellcheck="true">// 包含appendListene（添加监听），notifyListeners(触发所有监听)，</span> <span class="token comment" spellcheck="true">// setPrompt（设置一个Prompt，用于跳转前的弹框），</span> <span class="token comment" spellcheck="true">// comfirmTransitionTo(确认跳转函数)四个方法</span> <span class="token keyword">function</span> <span class="token function">createBrowserHistory</span><span class="token punctuation">(</span>props <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// ...</span>     <span class="token keyword">const</span> history <span class="token operator">=</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// globalHistory.length = window.history.length</span>         length<span class="token punctuation">:</span> globalHistory<span class="token punctuation">.</span>length<span class="token punctuation">,</span>         action<span class="token punctuation">:</span> <span class="token string">'POP'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// history内部管理的一个变量，导航的action</span>         location<span class="token punctuation">:</span> initialLocation<span class="token punctuation">,</span>         createHref<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 生成完整href地址的方法</span>         <span class="token comment" spellcheck="true">// push（path，state）方法接受path（string或者对象）和 state为参数</span>         <span class="token comment" spellcheck="true">// 随机创建一个key，调用createLocation生成要跳转路由的location</span>         <span class="token comment" spellcheck="true">// 调用createHref生成 href</span>         <span class="token comment" spellcheck="true">// 调用 transitionManager.confirmTransitionTo 主要用于跳转前的确认</span>         <span class="token comment" spellcheck="true">// 如果确认跳转，window.history.pushState({ key, state }, null, href)</span>         <span class="token comment" spellcheck="true">// history对象merge上要跳转路由的 key，state，和window.history.length</span>         <span class="token comment" spellcheck="true">// 然后出发所有监听事件（传入**location,action**）</span>         push<span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// replace与push类似</span>         replace<span class="token punctuation">,</span>         go<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// history.go()</span>         goBack<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// history.go(-1)</span>         goForward<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// history.go(1)</span>         block<span class="token punctuation">,</span>         <span class="token comment" spellcheck="true">// 重要！ listen方法使用 transitionManager.appendListene方法向订阅数组里推入一个监听函数，返回一个卸载监听的方法（这种设计模式，在react中非常常见），</span>         <span class="token comment" spellcheck="true">// 同时调用checkDOMListeners方法，此方法会在订阅数据添加上 **第一个** 监听事件后，同时发起window.addEventListener('popstate', handlePopState);</span>         <span class="token comment" spellcheck="true">// 同时会在卸载完全部监听后，**订阅数组为空时**，移除监听 window.removeEventListener('popstate', handlePopState);</span>         listen      <span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> history<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h3 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h3><p>对外暴露了 Router，Router，Switch，matchPath，withRouter 等 API</p><ol><li><strong>Router</strong></li></ol><pre class=" language-js"><code class="language-js"> <span class="token keyword">class</span> <span class="token class-name">Router</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>     <span class="token keyword">static</span> <span class="token function">computeRootMatch</span><span class="token punctuation">(</span>pathname<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 静态方法</span>         <span class="token keyword">return</span> <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">"/"</span><span class="token punctuation">,</span> url<span class="token punctuation">:</span> <span class="token string">"/"</span><span class="token punctuation">,</span> params<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> isExact<span class="token punctuation">:</span> pathname <span class="token operator">===</span> <span class="token string">"/"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>             location<span class="token punctuation">:</span> props<span class="token punctuation">.</span>history<span class="token punctuation">.</span>location         <span class="token punctuation">}</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 这是一种hack的写法，从新建实例的时候就开始对location的监听</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>_isMounted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>_pendingLocation <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>props<span class="token punctuation">.</span>staticContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">this</span><span class="token punctuation">.</span>unlisten <span class="token operator">=</span> props<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>location <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">// 如果组件以加载到真实的DOM，直接设置location的state</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_isMounted<span class="token punctuation">)</span> <span class="token punctuation">{</span>                     <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> location <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">//  如果没有，先用一个变量进行保存，等到componentDidMount后进行赋值</span>                     <span class="token keyword">this</span><span class="token punctuation">.</span>_pendingLocation <span class="token operator">=</span> location<span class="token punctuation">;</span>                 <span class="token punctuation">}</span>             <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>_isMounted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_pendingLocation<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> location<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_pendingLocation <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 卸载监听</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>unlisten<span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">unlisten</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token punctuation">(</span>             <span class="token comment" spellcheck="true">// 使用了React新的Context API，在最外层提供了history，location等供全局使用</span>             <span class="token operator">&lt;</span>RouterContext<span class="token punctuation">.</span>Provider                 children<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>children <span class="token operator">||</span> <span class="token keyword">null</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 子代属性</span>                 value<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 使用的 路由类型</span>   history<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>history<span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// history.js库封装的location，然后内部进行管理</span>   location<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>location<span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 返回类似{ path: "/", url: "/", params: {}, isExact: pathname === "/" }的匹配对象;</span>   match<span class="token punctuation">:</span> Router<span class="token punctuation">.</span><span class="token function">computeRootMatch</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>location<span class="token punctuation">.</span>pathname<span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 自定义传入的context</span>   staticContext<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>staticContext   <span class="token punctuation">}</span><span class="token punctuation">}</span>             <span class="token operator">/</span><span class="token operator">></span>         <span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><ol start="2"><li><strong>Route</strong></li></ol><pre class=" language-js"><code class="language-js"> <span class="token operator">&lt;</span>RouterContext<span class="token punctuation">.</span>Consumer<span class="token operator">></span>     <span class="token punctuation">{</span>context <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// Router组件传入this.props.location 或者 context 的 location</span>       <span class="token keyword">const</span> location <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>location <span class="token operator">||</span> context<span class="token punctuation">.</span>location<span class="token punctuation">;</span>       <span class="token keyword">const</span> match <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>computedMatch <span class="token comment" spellcheck="true">// Router组件传入computedMatch</span>         <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>computedMatch <span class="token comment" spellcheck="true">// &lt;Switch> already computed the match for us</span>         <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>path <span class="token comment" spellcheck="true">// Router组件传入path</span>         <span class="token comment" spellcheck="true">// matchPath 函数返回类似{ path: "/", url: "/", params: {}, isExact: pathname === "/" }的匹配对象</span>           <span class="token operator">?</span> <span class="token function">matchPath</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>pathname<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">)</span>           <span class="token punctuation">:</span> context<span class="token punctuation">.</span>match<span class="token punctuation">;</span>       <span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>context<span class="token punctuation">,</span> location<span class="token punctuation">,</span> match <span class="token punctuation">}</span><span class="token punctuation">;</span>       <span class="token keyword">let</span> <span class="token punctuation">{</span> children<span class="token punctuation">,</span> component<span class="token punctuation">,</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">;</span>       <span class="token operator">...</span><span class="token operator">...</span>       <span class="token comment" spellcheck="true">// 最后为每个Router提供一个新的Provider，包含history,location，match等</span>       <span class="token keyword">return</span> <span class="token punctuation">(</span>         <span class="token operator">&lt;</span>RouterContext<span class="token punctuation">.</span>Provider value<span class="token operator">=</span><span class="token punctuation">{</span>props<span class="token punctuation">}</span><span class="token operator">></span>           <span class="token punctuation">{</span>children <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isEmptyChildren</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// children不为空则渲染children</span>             <span class="token operator">?</span> children             <span class="token punctuation">:</span> props<span class="token punctuation">.</span>match <span class="token comment" spellcheck="true">//</span>               <span class="token operator">?</span> component <span class="token comment" spellcheck="true">// Router组件传入类组件 使用createElement 创建组件</span>                 <span class="token operator">?</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>component<span class="token punctuation">,</span> props<span class="token punctuation">)</span>                 <span class="token punctuation">:</span> render <span class="token comment" spellcheck="true">// Route组件传入函数组件 传入props执行</span>                   <span class="token operator">?</span> <span class="token function">render</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>                   <span class="token punctuation">:</span> <span class="token keyword">null</span>               <span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 没有匹配到返回null</span>         <span class="token operator">&lt;</span><span class="token operator">/</span>RouterContext<span class="token punctuation">.</span>Provider<span class="token operator">></span>       <span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">&lt;</span><span class="token operator">/</span>RouterContext<span class="token punctuation">.</span>Consumer<span class="token operator">></span></code></pre><ol start="3"><li><strong>withRouter</strong></li></ol><pre class=" language-js"><code class="language-js"> <span class="token operator">&lt;</span>Router <span class="token operator">...</span><span class="token operator">></span>     <span class="token operator">&lt;</span>Route <span class="token operator">...</span> <span class="token operator">/</span><span class="token operator">></span>     <span class="token operator">&lt;</span>Route <span class="token operator">...</span> <span class="token operator">/</span><span class="token operator">></span>     <span class="token operator">&lt;</span>Route <span class="token operator">...</span> <span class="token operator">/</span><span class="token operator">></span>     <span class="token comment" spellcheck="true">// 这些Route中能从props中获取到 history location match等，</span>     <span class="token comment" spellcheck="true">// 但是Route里面的子组件是没有的，</span>     <span class="token comment" spellcheck="true">// 如果想获得这些属性，可以通过props往下层传递，</span>     <span class="token comment" spellcheck="true">// 或者直接通过withRouter,它是利用RouterContext.Consumer获得</span> <span class="token operator">&lt;</span><span class="token operator">/</span>Router<span class="token operator">></span></code></pre><ol start="4"><li><p><strong>generatePath</strong></p><p>根据路径（例如：’/user/:id/:name’）和 params（例如：{id: 10001, name: ‘bob’}）生成完整路径（/user/10001/bob）的函数，就是填充 url 的字符串</p></li></ol><h3 id="react-router-dom"><a href="#react-router-dom" class="headerlink" title="react-router-dom"></a>react-router-dom</h3><ol><li><strong>导出内容</strong></li></ol><pre class=" language-js"><code class="language-js"> <span class="token keyword">export</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token string">"react-router"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 对react-router的API直接导出</span> <span class="token comment" spellcheck="true">// 导出 BrowserRouter HashRouter Link NavLink</span> <span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token keyword">as</span> BrowserRouter <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./BrowserRouter"</span><span class="token punctuation">;</span> <span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token keyword">as</span> HashRouter <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./HashRouter"</span><span class="token punctuation">;</span> <span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token keyword">as</span> Link <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./Link"</span><span class="token punctuation">;</span> <span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token keyword">as</span> NavLink <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./NavLink"</span><span class="token punctuation">;</span></code></pre><ol start="2"><li><strong>BrowserRouter</strong></li></ol><pre class=" language-js"><code class="language-js"> <span class="token keyword">class</span> <span class="token class-name">BrowserRouter</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>     history <span class="token operator">=</span> <span class="token function">createHistory</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// history库暴露的createHistory方法</span>     <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// Router 组件传入生成的history对象</span>         <span class="token keyword">return</span> <span class="token operator">&lt;</span>Router history<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>history<span class="token punctuation">}</span> children<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>children<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>       <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token keyword">export</span> <span class="token keyword">default</span> BrowserRouter<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// HashRouter 与其一样 创建history对象时使用了hash</span></code></pre><ol start="3"><li><p><strong>Link 和 NavLink</strong></p><p>Link 封装的 a 标签，NavLink 封装的 Link 组件</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>react-router 提供核心路由功能，react-router-dom 用作浏览器端路由，依赖 react-router，如果 我们写 web 应用，直接引入 react-router-dom 即可，此外还包含 react-router-native，可以用于 react-native 应用<br><img src="/./images/react-router.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> spa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flutter跨组件通信</title>
      <link href="2022/11/03/flutter-kua-zu-jian-tong-xin/"/>
      <url>2022/11/03/flutter-kua-zu-jian-tong-xin/</url>
      
        <content type="html"><![CDATA[<h1 id="flutter-跨组件通信"><a href="#flutter-跨组件通信" class="headerlink" title="flutter 跨组件通信"></a>flutter 跨组件通信</h1><p>响应式的编程框架中都会有一个永恒的主题——“状态(State)管理”，无论是在 React/Vue（两者都是支持响应式编程的 Web 开发框架）还是 Flutter 中，他们讨论的问题和解决的思想都是一致的。在 flutter 中，状态管理的一般原则是：</p><p>如果状态是组件私有的，则应该由组件自己管理；如果状态要跨组件共享，则该状态应该由各个组件共同的父元素来管理。对于组件私有的状态管理很好理解，但对于跨组件共享的状态，管理的方式就比较多了，如使用全局事件总线 EventBus，它是一个发布/订阅者模式的实现，通过它就可以实现跨组件状态同步：状态持有方（发布者）负责更新、发布状态，状态使用方（观察者）监听状态改变事件来执行一些操作。但是观察者模式来实现跨组件状态共享有一些明显的缺点：</p><ol><li>必须显示定义各种事件，不好管理</li><li>订阅者必须需显示注册状态改变回调，也必须在组件销毁时手动去解绑回调以避免内存泄漏</li></ol><p>那么，在 flutter 中有没有更好的跨组件状态管理方式了呢？答案是肯定的，就是<code>InheritedWidget</code>,它本身就是能绑定<code>InheritedWidget</code>与依赖它的子孙之间的依赖关系，并且当<code>InheritedWidget</code>数据发生变化时，可以自动更新依赖的子孙组件，这样，来实现跨组件状态管理我们只需要将跨组件共享的状态保存在<code>InheritedWidget</code>中，然后子组件引用<code>InheritedWidget</code>即可。</p><h2 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h2><h3 id="InheritedWidget-组件简介"><a href="#InheritedWidget-组件简介" class="headerlink" title="InheritedWidget 组件简介"></a>InheritedWidget 组件简介</h3><p><code>InheritedWidget</code> 是 flutter 中非常重要的功能型组件，类比于 React 中的<code>context</code>功能，提供了一种数据在组件中从上到下传递、共享的方式。</p><h3 id="InheritedWidget-源码解读"><a href="#InheritedWidget-源码解读" class="headerlink" title="InheritedWidget 源码解读"></a>InheritedWidget 源码解读</h3><h4 id="InheritedWidget-定义"><a href="#InheritedWidget-定义" class="headerlink" title="InheritedWidget 定义"></a>InheritedWidget 定义</h4><p>首先看下关于 InheritedWidget 的声明定义</p><pre><code>abstract class InheritedWidget extends ProxyWidget {  const InheritedWidget({ Key key, Widget child })    : super(key: key, child: child);  @override  InheritedElement createElement() =&gt; new InheritedElement(this);  @protected  bool updateShouldNotify(covariant InheritedWidget oldWidget);}</code></pre><p>它表示一个继承自<code>ProxyWidget</code> 的抽象类。内部没什么逻辑，除了实现了一个 <code>createElement</code> 方法之外，还定义了一个 <code>updateShouldNotify()</code> 接口。 每次当 <code>InheritedElement</code> 的实例更新时会执行该方法并传入更新之前对应的 <code>Widget</code> 对象，如果该方法返回 true 那么依赖该 Widget 的(在 build 阶段通过 <code>inheritFromWidgetOfExactType</code> 方法查找过该 Widget 的子 widget)实例会被通知进行更新；如果返回 false 则不会通知依赖项更新。这个机制和 React 框架中的 shouldComponentUpdate 机制很像.</p><h4 id="InheritedWidget-相关信息的传递机制"><a href="#InheritedWidget-相关信息的传递机制" class="headerlink" title="InheritedWidget 相关信息的传递机制"></a>InheritedWidget 相关信息的传递机制</h4><p>每个 Element 实例上都有一个 <code>_inheritedWidgets</code> 属性。该属性的类型为：</p><pre><code>HashMap&lt;Type, InheritedElement&gt;</code></pre><p>其中保存了祖先节点中出现的 <code>InheritedWidget</code> 与其对应<code>element</code>的映射关系。在<code>element</code>的<code>mount</code>阶段和<code>active</code>阶段，会执行<code>_updateInheritance()</code>方法更新这个映射关系。</p><p>对于普通<code>Element</code>实例，<code>_updateInheritance()</code>只是单纯把父<code>element</code>的<code>_inheritedWidgets</code>属性保存在自身<code>_inheritedWidgets</code>里。从而实现映射关系的层层向下传递。</p><pre><code>  void _updateInheritance() {    assert(_active);    _inheritedWidgets = _parent?._inheritedWidgets;  }</code></pre><p>由<code>InheritedWidget</code>创建的<code>InheritedElement</code>重写了该方法：</p><pre><code>  void _updateInheritance() {    assert(_active);    final Map&lt;Type, InheritedElement&gt; incomingWidgets = _parent?._inheritedWidgets;    if (incomingWidgets != null)      _inheritedWidgets = new HashMap&lt;Type, InheritedElement&gt;.from(incomingWidgets);    else      _inheritedWidgets = new HashMap&lt;Type, InheritedElement&gt;();    _inheritedWidgets[widget.runtimeType] = this;  }</code></pre><p>可以看出<code>InheritedElement</code>实例会把自身的信息添加到<code>_inheritedWidgets</code>属性中，这样其子孙<code>element</code>就可以通过前面提到的<code>_inheritedWidgets</code>的传递机制获取到此<code>InheritedElement</code>的引用。</p><h4 id="InheritedWidget-的更新通知机制"><a href="#InheritedWidget-的更新通知机制" class="headerlink" title="InheritedWidget 的更新通知机制"></a>InheritedWidget 的更新通知机制</h4><p>首先让我们回答一个小问题，前文提到<code>_inheritedWidgets</code>属性存在于<code>Element</code>实例上，而我们代码中调用的<code>inheritFromWidgetOfExactType</code>方法则存在于<code>BuildContext</code>实例之上。那么<code>BuildContext</code>是如何获取<code>Element</code>实例上的信息的呢？答案是不需要获取。因为每一个<code>Element</code>实例也都是一个<code>BuildContext</code>实例。这一点可以从<code>Element</code>的定义中得到：</p><pre><code>abstract  class  Element  extends  DiagnosticableTree  implements  BuildContext {}</code></pre><p>而每次<code>Element</code>实例执行<code>Widget</code>实例的<code>build</code>方法时传入的<code>context</code>就是该<code>Element</code>实例自身，以<code>StatelessElement</code>为例：</p><pre><code>class StatelessElement extends ComponentElement {  ...  @override  Widget build() =&gt; widget.build(this);  ...}</code></pre><p>既然可以拿到<code>InheritedWidget</code>的信息了，那接下让我们通过源码看看更新通知机制的具体实现。</p><p>首先看一下<code>inheritFromWidgetOfExactType</code>的实现：</p><pre><code>  InheritedWidget inheritFromWidgetOfExactType(Type targetType) {    assert(_debugCheckStateIsActiveForAncestorLookup());    final InheritedElement ancestor = _inheritedWidgets == null ? null : _inheritedWidgets[targetType];    if (ancestor != null) {      assert(ancestor is InheritedElement);      _dependencies ??= new HashSet&lt;InheritedElement&gt;();      _dependencies.add(ancestor);      ancestor._dependents.add(this);      return ancestor.widget;    }    _hadUnsatisfiedDependencies = true;    return null;  }</code></pre><p>首先在<code>_inheritedWidget</code>映射中查找是否有特定类型<code>InheritedWidget</code>的实例。如果有则将该实例添加到自身的依赖列表中，同时将自身添加到对应的依赖项列表中。这样该<code>InheritedWidget</code>在更新后就可以通过其<code>_dependents</code>属性知道需要通知哪些依赖了它的<code>widget</code>。</p><p>每当<code>InheritedElement</code>实例更新时，会执行实例上的``notifyClients<code>方法通知依赖了它的子</code>element<code>同步更新。</code>notifyClients`实现如下：</p><pre><code>  void notifyClients(InheritedWidget oldWidget) {    if (!widget.updateShouldNotify(oldWidget))      return;    assert(_debugCheckOwnerBuildTargetExists('notifyClients'));    for (Element dependent in _dependents) {      assert(() {        // check that it really is our descendant        Element ancestor = dependent._parent;        while (ancestor != this &amp;&amp; ancestor != null)          ancestor = ancestor._parent;        return ancestor == this;      }());      // check that it really depends on us      assert(dependent._dependencies.contains(this));      dependent.didChangeDependencies();    }  }</code></pre><p>首先执行相应<code>InheritedWidget</code>上的<code>updateShouldNotify</code>方法判断是否需要通知，如果该方法返回<code>true</code>则遍历<code>_dependents</code>列表中的<code>element</code>并执行他们的<code>didChangeDependencies()</code>方法。这样<code>InheritedWidget</code>中的更新就通知到依赖它的子<code>widget</code>中了。</p><h4 id="didChangeDependencies"><a href="#didChangeDependencies" class="headerlink" title="didChangeDependencies"></a>didChangeDependencies</h4><p>刚在之前说明了 InheritedWidget 通过调用<code>Element</code>的<code>didChangeDependencies()</code>来更新 widget，这个是指<code>state</code>的对象有一个<code>didChangeDependencies</code>的回调，在”依赖”变化时被<code>Flutter Framework</code>调用。而这个“依赖”指的就是子<code>widget</code>是否使用了父<code>widget</code>中<code>InheritedWidget</code>的数据！如果使用了，则代表子 widget 依赖有依赖<code>InheritedWidget</code>；如果没有使用则代表没有依赖。这种机制可以使子组件在所依赖的<code>InheritedWidget</code>变化时来更新自身！比如当主题、locale(语言)等发生变化时，依赖其的子 widget 的<code>didChangeDependencies</code>方法将会被调用。</p><h4 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h4><p>在上文中提到<code>InheritedWidget</code>结合<code>Element</code>中的 didChangeDependencies 的回调来实现组件间的通信，实际上，在使用的过程中我们往往只需要更新子树中依赖了<code>ShareDataWidget</code>的组件，而现在只要调用<code>setState()</code>方法，所有子节点都会被重新 build，这很没必要，那么有什么办法可以避免呢？答案是缓存！一个简单的做法就是通过封装一个<code>StatefulWidget</code>，将子<code>Widget</code>树缓存起来，此时<code>Provider</code>应运而生，在此节中将通过实现<code>Provider widget</code>来演示如何缓存，以及如何利用<code>InheritedWidget</code>来实现 Flutter 全局状态共享。</p><p>首先，我们需要一个保存需要共享的数据<code>InheritedWidget</code>，由于具体业务数据类型不可预期，为了通用性，我们使用泛型，定义一个通用的<code>InheritedProvider</code>类，它继承自<code>InheritedWidget</code>：</p><pre><code>// 一个通用的InheritedWidget，保存任需要跨组件共享的状态class InheritedProvider&lt;T&gt; extends InheritedWidget {  InheritedProvider({@required this.data, Widget child}) : super(child: child);  //共享状态使用泛型  final T data;  @override  bool updateShouldNotify(InheritedProvider&lt;T&gt; old) {    //在此简单返回true，则每次更新都会调用依赖其的子孙节点的`didChangeDependencies`。    return true;  }}</code></pre><p>数据保存的地方有了，那么接下来我们需要做的就是在数据发生变化的时候来重新构建<code>InheritedProvider</code>，那么现在就面临两个问题：</p><ol><li>数据发生变化怎么通知？</li><li>谁来重新构建<code>InheritedProvider</code>？<br>第一个问题其实很好解决，我们当然可以使用之前介绍的<code>eventBus</code>来进行事件通知，但是为了更贴近 Flutter 开发，我们使用 Flutter SDK 中提供的<code>ChangeNotifier</code>类 ，它继承自<code>Listenable</code>，也实现了一个 Flutter 风格的发布者-订阅者模式，<code>ChangeNotifier</code>定义大致如下：</li></ol><pre><code>class ChangeNotifier implements Listenable {  List listeners=[];  @override  void addListener(VoidCallback listener) {     //添加监听器     listeners.add(listener);  }  @override  void removeListener(VoidCallback listener) {    //移除监听器    listeners.remove(listener);  }  void notifyListeners() {    //通知所有监听器，触发监听器回调    listeners.forEach((item)=&gt;item());  }  ... //省略无关代码}</code></pre><p>我们可以通过调用<code>addListener()</code>和<code>removeListener()</code>来添加、移除监听器（订阅者）；通过调用<code>notifyListeners()</code> 可以触发所有监听器回调。</p><p>现在，我们将要共享的状态放到一个 Model 类中，然后让它继承自<code>ChangeNotifier</code>，这样当共享的状态改变时，我们只需要调用<code>notifyListeners()</code> 来通知订阅者，然后由订阅者来重新构建<code>InheritedProvider</code>，这也是第二个问题的答案！接下来我们便实现这个订阅者类</p><pre><code>class ChangeNotifierProvider&lt;T extends ChangeNotifier&gt; extends StatefulWidget {  ChangeNotifierProvider({    Key key,    this.data,    this.child,  });  final Widget child;  final T data;  //定义一个便捷方法，方便子树中的widget获取共享数据  static T of&lt;T&gt;(BuildContext context) {    final type = _typeOf&lt;InheritedProvider&lt;T&gt;&gt;();    final provider =  context.dependOnInheritedWidgetOfExactType&lt;InheritedProvider&lt;T&gt;&gt;();    return provider.data;  }  @override  _ChangeNotifierProviderState&lt;T&gt; createState() =&gt; _ChangeNotifierProviderState&lt;T&gt;();}</code></pre><p>该类继承<code>StatefulWidget</code>，然后定义了一个<code>of()</code>静态方法供子类方便获取<code>Widget</code>树中的<code>InheritedProvider</code>中保存的共享状态(model)，下面我们实现该类对应的<code>_ChangeNotifierProviderState</code>类：</p><pre><code>class _ChangeNotifierProviderState&lt;T extends ChangeNotifier&gt; extends State&lt;ChangeNotifierProvider&lt;T&gt;&gt; {  void update() {    //如果数据发生变化（model类调用了notifyListeners），重新构建InheritedProvider    setState(() =&gt; {});  }  @override  void didUpdateWidget(ChangeNotifierProvider&lt;T&gt; oldWidget) {    //当Provider更新时，如果新旧数据不"=="，则解绑旧数据监听，同时添加新数据监听    if (widget.data != oldWidget.data) {      oldWidget.data.removeListener(update);      widget.data.addListener(update);    }    super.didUpdateWidget(oldWidget);  }  @override  void initState() {    // 给model添加监听器    widget.data.addListener(update);    super.initState();  }  @override  void dispose() {    // 移除model的监听器    widget.data.removeListener(update);    super.dispose();  }  @override  Widget build(BuildContext context) {    return InheritedProvider&lt;T&gt;(      data: widget.data,      child: widget.child,    );  }}</code></pre><p>可以看到<code>_ChangeNotifierProviderState</code>类的主要作用就是监听到共享状态（model）改变时重新构建<code>Widget</code>树。注意，在<code>_ChangeNotifierProviderState</code>类中调用<code>setState()</code>方法，<code>widget.child</code>始终是同一个，所以执行 build 时，<code>InheritedProvider</code>的 child 引用的始终是同一个子<code>widget</code>，所以<code>widget.child</code>并不会重新 build，这也就相当于对 child 进行了缓存！当然如果<code>ChangeNotifierProvider</code>父级<code>Widget</code>重新 build 时，则其传入的 child 便有可能会发生变化。</p><h3 id="Scoped-Model-状态管理"><a href="#Scoped-Model-状态管理" class="headerlink" title="Scoped Model 状态管理"></a>Scoped Model 状态管理</h3><p><code>Scoped Model</code> 和 <code>provider</code>类似，原理都是基于<code>InheritedProvider</code>，官方对于 Scoped_Model 的介绍是：</p><pre><code>A set of utilities that allow you to easily pass a data Model from a parent Widget down to it's descendants. In addition, it also rebuilds all of the children that use the model when the model is updated. This library was originally extracted from the Fuchsia codebase.一组实用程序，允许您轻松地将数据模型从父窗口小部件传递给它的后代。此外，它还重建了模型更新时使用模型的所有子代。这个库最初是从 Fuchsia 基代码中提取的。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动技术发展&amp;flutter简介</title>
      <link href="2022/11/03/yi-dong-ji-zhu-fa-zhan-he-flutter-jian-jie/"/>
      <url>2022/11/03/yi-dong-ji-zhu-fa-zhan-he-flutter-jian-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="移动技术发展及-flutter-简介"><a href="#移动技术发展及-flutter-简介" class="headerlink" title="移动技术发展及 flutter 简介"></a>移动技术发展及 flutter 简介</h1><h2 id="移动技术发展"><a href="#移动技术发展" class="headerlink" title="移动技术发展"></a>移动技术发展</h2><p>2008 年 7 月 IPhone 推出第一代手机 IPhone 3G，同年 9 月谷歌正式发布了 Android 1.0 系统，标志着我们正式步入移动端发展期，按照技术开发的历程移动端（目前特指 Android 和 iOS）的发展大致可以分为 4 个阶段：原生阶段-&gt;Hybird 阶段-&gt;RN 阶段-&gt;Flutter 阶段。</p><h3 id="原生阶段"><a href="#原生阶段" class="headerlink" title="原生阶段"></a>原生阶段</h3><p>使用原生语言（Android 使用 Java 或 Kotlin，iOS 使用 Objective-C 或 Swift ）开发应用，称之为原生阶段。<br>在此阶段发现一样的功能需要在 Android 和 iOS 两端开发，开发和维护成本较高，同时无动态化更新能力，紧急问题的修复和添加新功能都需要到相应平台发版，尤其是 iOS 审核的周期非常长，在国内 Android 虽然有动态化方案，但如果上架 Google Play 很有可能审核不通过或者下架，iOS 也有动态化，但苹果官方基本审核不通过，所以原生的动态化更新受政策影响很大。</p><p>从开发者的角度出发，是否有一种方案可以开发一套代码在多个平台运行且可以动态化更新，无需在走平台的审核。基于这个需求 H5 兴起，也就是我们所说的 Hybird 阶段。</p><h3 id="Hybird-阶段"><a href="#Hybird-阶段" class="headerlink" title="Hybird 阶段"></a>Hybird 阶段</h3><p>Hybird 实现的基本原理是通过原生的 WebView 容器加载 H5 网页进行渲染，通过 JavaScript Bridge 调用一部分系统能力，同步更新服务器上的 H5 网页也实现了动态更新，俗称混合应用。</p><p><img src="http://img.laomengit.com/image-20200608113600654.png" alt="Hybird"></p><p>当时大量的公司使用此方案进行开发，最出名的就是 Facebook，早期的 Facebook 在 H5 上投入了大量的精力，一次开发、快速迭代这是使用 H5 技术巨大的优势。</p><p>然而一切看似美好，但很快发现，H5 方案存在致命的缺陷-用户体验极差。</p><p>Facebook 创始人兼 CEO 马克·扎克伯格在接受采访的时候承认：专注在 HTML 5 上面是他有史以来犯过的最大的错误。</p><p>然而福兮祸所伏，虽然在 Facebook 上大量使用 H5 而导致用户体验极差，但 Facebook 基于强大的 H5 技术积累开发出了伟大的 React 框架，此框架是 React Native 框架的基础。</p><h3 id="React-Native-阶段"><a href="#React-Native-阶段" class="headerlink" title="React Native 阶段"></a>React Native 阶段</h3><p>React Native 简称 RN，是 FaceBook 在 2015 年开源，基于 JavaScript，具备动态配置能力跨平台开发框架。React Native 框架原理如下：</p><p><img src="http://img.laomengit.com/image-20200608115921953.png" alt="RN"></p><p>React Native 使用 React 开发，然后生成虚拟 DOM 树，虚拟 DOM 是一个 JavaScript 的树形结构，通过虚拟 DOM 树映射到不同平台的本地控件，最终显示的 UI 是原生控件，因此在性能体验上和原生非常相近。和 React Native 类似的框架还有阿里巴巴的 Weex 框架，Weex 是在 React Native 基础上重新设计了一套开发模式，原理上和 React Native 一样。</p><p>React Native 解决了继承了 H5 的优点，同时解决了性能体验上的问题，2015 年 React Native 一经发布，就在技术圈引起了巨大的反响，在当时看来 React Native 是一个非常完美的跨平台解决方案，很快大量开发者涌入。</p><p>当年使用 React Native 的开发者最担心的不是 React Native 性能如何？体验如何？而是担心苹果会不会封掉 React Native，可想而之 React Native 的火爆程度，当年著名的 JSPatch 事件起初，起初大家都在说苹果开始对 React Native 下手了，虽然后来证实和 React Native 无关，但多多少少都对 React Native 开发者造成了一定的影响。</p><p>随着时间的流逝，发现 React Native 和原生桥接的成本非常高，在复杂场景下会出现严重的性能问题，比如早期的 ListView 滑动卡顿问题。</p><p>React Native 要桥接到原生控件，但 Android 和 IOS 控件的差异导致 React Native 无法统一 API，有的属性 IOS 支持，Android 不支持，有的 Android 支持，IOS 不支持，这就导致经常需要开发 Android 和 IOS 两套插件，随着项目的复杂度提升，也导致维护成本大幅提升。</p><p>还有一个很大的问题就是 React Native 依赖于 Facebook 的维护，而每次 iOS 和 Android 系统版本更新，很大程度上会受到影响。</p><h3 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h3><p>从技术上来说，小程序（指微信小程序，下同）并不是新的跨平台方案，它使用浏览器内核来渲染界面，小部分由原生组件渲染，原理图如下：</p><p><img src="http://img.laomengit.com/image-20200608140924092.png" alt="小程序"></p><p>小程序的运行环境分成渲染层和逻辑层，通信会经由微信客户端（Native）做中转。</p><p>微信小程序目前来看是非常成功的，在我看来微信小程序成功主要原因并不是因为技术，而是生态，当然微信小程序体验也是非常好的。</p><p>对商家来说，微信小程序拥有月活 10 亿的微信用户，获客成本低，这是一个流量极佳的平台，因此很多商家开发了体验极好的小程序，甚至一些商家把主要平台迁移到了微信小程序。</p><p>对于用户来说，无需下载，用完就走，极大的提升了用户体验，微信提供基础服务平台，商家获客成本低，用户体验提升，三方形成完美的平衡，因此微信小程序的生态越来越完善。</p><p>除了小程序外，类似的方案还有百度的轻应用和快应用，但都不温不火。</p><h3 id="Flutter-阶段"><a href="#Flutter-阶段" class="headerlink" title="Flutter 阶段"></a>Flutter 阶段</h3><p>千呼万唤始出来，主角-Flutter 终于登场了，Flutter 是谷歌的移动 UI 框架，可以快速在 iOS 和 Android 上构建高质量的原生用户界面。</p><p><img src="http://img.laomengit.com/image-20200608143242580.png" alt="Flutter"></p><p>Flutter 吸收了前面的经验，它既没有使用 WebView，也没有使用原生控件进行绘制，而是自己实现了一套高性能渲染引擎来绘制 UI，这个引擎就是大名鼎鼎的 Skia，Skia 是一个 2D 绘图引擎库，Chrome 和 Android 都是采用 Skia 作为引擎。Flutter 完美的解决了跨平台代码复用和性能问题，大家都在感叹：似乎 UI 迎来了终极解决方案。</p><p>UI 平台一致性<br>由于 Flutter 使用自己的引擎进行 UI 渲染，而不是用原生控件渲染，导致控件显示效果和原生不是完全一样，虽然肉眼看起来基本一样，但还是有一些细微的差别，尤其当 Android 和 iOS 系统升级导致原生控件效果发生变化时，Flutter 开发的 App 并不会进行相应的变化，如果您的 App 需要原生控件保持完全一致，Flutter 可能并不适合您。</p><p>动态化更新<br>动态化功能在国内来说是一项非常重要的功能，Google 官方已经明确现阶段不会实现动态化功能。<br>此功能并不是技术上无法实现，更多的还是政策和法律上的约束。<br>因此如果您的 App 需要动态化功能，那么 Flutter 可能并不适合您。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>既然 Flutter 已经如此优秀了，那是不是以后使用 Flutter 就可以了呢？答案是否定的，未来很长一段时间应该是原生、Hybird、React Native、Flutter 共存时代。</p><p>原生开发是无法完全避开的，一些硬件（比如蓝牙、传感器等）功能、音视频和 ARVR 等相关功能必须使用原生开发，有人说我开发蓝牙功能没用写原生代码啊，直接引入即可，你没有写，那是因为有人为你封装好了第三方插件。<br>Hybird 虽然有一些缺陷，但依然有其使用的场景，比如京东、天猫 App 中的营销活动都是是 H5 实现的。<br>React Native 可以使用原生控件渲染，因此，如果您需要使用原生控件而又想跨平台，React Native 是不错的选择。</p><h2 id="Flutter-基本原理"><a href="#Flutter-基本原理" class="headerlink" title="Flutter 基本原理"></a>Flutter 基本原理</h2><h3 id="Flutter-高性能（AOT、JIT）"><a href="#Flutter-高性能（AOT、JIT）" class="headerlink" title="Flutter 高性能（AOT、JIT）"></a>Flutter 高性能（AOT、JIT）</h3><p>Flutter 高性能主要靠两点来保证，首先，Flutter APP 采用 Dart 语言开发。Dart 在 JIT（即时编译）模式下，速度与 JavaScript 基本持平。但是 Dart 支持 AOT，当以 AOT 模式运行时，JavaScript 便远远追不上了。速度的提升对高帧率下的视图数据计算很有帮助。其次，Flutter 使用自己的渲染引擎来绘制 UI，布局数据等由 Dart 语言直接控制，所以在布局过程中不需要像 RN 那样要在 JavaScript 和 Native 之间通信，这在一些滑动和拖动的场景下具有明显优势，因为在滑动和拖动过程往往都会引起布局发生变化，所以 JavaScript 需要和 Native 之间不停的同步布局信息，这和在浏览器中要 JavaScript 频繁操作 DOM 所带来的问题是相同的，都会带来比较可观的性能开销。</p><p>在了解 Flutter 为什么选择了 Dart 而不是 JavaScript 之前我们先来介绍两个概念：JIT 和 AOT。</p><p>目前，程序主要有两种运行方式：静态编译与动态解释。静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为 AOT （Ahead of time）即 “提前编译”；而解释执行的则是一句一句边翻译边运行，通常将这种类型称为 JIT（Just-in-time）即“即时编译”。AOT 程序的典型代表是用 C/C++开发的应用，它们必须在执行前编译成机器码，而 JIT 的代表则非常多，如 JavaScript、python 等，事实上，所有脚本语言都支持 JIT 模式。但需要注意的是 JIT 和 AOT 指的是程序运行方式，和编程语言并非强关联的，有些语言既可以以 JIT 方式运行也可以以 AOT 方式运行，如 Java、Python，它们可以在第一次执行时编译成中间字节码、然后在之后执行时可以直接执行字节码，也许有人会说，中间字节码并非机器码，在程序执行时仍然需要动态将字节码转为机器码，是的，这没有错，不过通常我们区分是否为 AOT 的标准就是看代码在执行之前是否需要编译，只要需要编译，无论其编译产物是字节码还是机器码，都属于 AOT。在此，读者不必纠结于概念，概念就是为了传达精神而发明的，只要读者能够理解其原理即可，得其神忘其形。</p><p>现在我们看看 Flutter 为什么选择 Dart 语言？笔者根据官方解释以及自己对 Flutter 的理解总结了以下几条（由于其它跨平台框架都将 JavaScript 作为其开发语言，所以主要将 Dart 和 JavaScript 做一个对比）：</p><ol><li><p>开发效率高</p><p>Dart 运行时和编译器支持 Flutter 的两个关键特性的组合：</p><p>基于 JIT 的快速开发周期：Flutter 在开发阶段采用，采用 JIT 模式，这样就避免了每次改动都要进行编译，极大的节省了开发时间；</p><p>基于 AOT 的发布包: Flutter 在发布时可以通过 AOT 生成高效的 ARM 代码以保证应用性能。而 JavaScript 则不具有这个能力。</p></li><li><p>高性能</p><p>Flutter 旨在提供流畅、高保真的的 UI 体验。为了实现这一点，Flutter 中需要能够在每个动画帧中运行大量的代码。这意味着需要一种既能提供高性能的语言，而不会出现会丢帧的周期性暂停，而 Dart 支持 AOT，在这一点上可以做的比 JavaScript 更好。</p></li></ol><h3 id="Flutter-渲染引擎"><a href="#Flutter-渲染引擎" class="headerlink" title="Flutter 渲染引擎"></a>Flutter 渲染引擎</h3><p>Flutter 与用于构建移动应用程序的其它大多数框架不同，因为 Flutter 既不使用 WebView，也不使用操作系统的原生控件。 相反，Flutter 使用自己的高性能渲染引擎来绘制 widget。这样不仅可以保证在 Android 和 iOS 上 UI 的一致性，而且也可以避免对原生控件依赖而带来的限制及高昂的维护成本。</p><p>Flutter 使用 Skia 作为其 2D 渲染引擎，Skia 是 Google 的一个 2D 图形处理函数库，包含字型、坐标转换，以及点阵图都有高效能且简洁的表现，Skia 是跨平台的，并提供了非常友好的 API，目前 Google Chrome 浏览器和 Android 均采用 Skia 作为其绘图引擎。</p><p>Flutter 渲染引擎在 iOS 上支持三种渲染方式，分别是纯软件（CPU），Metal 和 GL。其中纯软件的方式仅限于特定的构建，需要在编译时开启 TARGET_IPHONE_SIMULATOR 宏，应该是用于在模拟器上的测试，实机运行只会使用 Metal 和 GL。Flutter 会在运行时先判断是否能够使用 Metal，如果设备不支持，才会降级到 GL。iOS 10 以上的版本默认使用 Metal，GL 只用于兼容 iOS 9 的老旧设备。</p><p>Flutter 渲染引擎在 Android 上也支持三种渲染方式，分别是纯软件（CPU），GL 和 Vulkan。其中纯软件模式是运行时由 Settings 的 enable_software_rendering 开关控制，默认为 false，目前只看到是通过命令行开关来控制，猜测是用于特定的测试用途。</p><p>跟 iOS 不一样的是，Flutter 在 Android 上并不是动态判断系统和硬件环境，在运行时来选择 Vulkan 或者 GL，而是需要开发者自行编译一个开启 SHELL_ENABLE_VULKAN 宏的 Flutter Engine，可能 Skia 对 Vulkan 在 Android 上的支持还不够完善的缘故，这个宏是默认关闭的，所以 Flutter 在 Android 上目前还是以 GL 为主。</p><p>Flutter 的渲染流程：</p><ol><li>需要的 GL GPU（Metal GPU）上下文环境是如何完成初始化；</li><li>目标输出 Surface 的设置过程；</li><li>渲染流水线执行光栅化的调用过程。</li></ol><p>总的说来 Flutter 的渲染流水线，整体架构上（包括线程架构）跟 Android 5.x 之后的 Android View Rendering 架构基本一致，跟目前其他主流的 UI Toolkit，如 iOS，Qt QML 也十分类似。但是在内部实现的一些概念和细节上更接近于浏览器，特别是 WebKit/Blink，这跟 Flutter 的几位初期成员都是来自 Chrome 团队，负责 WebKit/Blink 的排版和绘制相关的工作有关。</p><p>跟 Android 5.x View Rendering Pipeline 一样，Flutter 的渲染流水线也包括两个线程 —— UI 线程和 GPU 线程。</p><p>UI 线程主要负责的是根据 UI 界面的描述生成 UI 界面的绘制指令，而 GPU 线程负责光栅化和合成。</p><p>Flutter 以图层树（Layer Tree）的方式对生成的 UI 界面绘制指令进行组织，而从 Android 4.x 开始，Android View Rendering 使用的 View DisplayList 树的方式，虽然组织的方式有所差异，但是其中的主要内容都是 UI 界面的绘制指令。而图层树这种组织方式又非常类似 WebKit/Blink。</p><p><img src="http://api.fly63.com/vue_blog/public/Uploads/20190428/5cc52cdd043ee.jpg" alt="渲染流程"></p><p>上图显示了 Flutter 更新 UI 界面的过程：</p><ol><li>运行动画，动画的结果会导致 Widget State 的改变；</li><li>State Changes 触发 Flutter 生成一棵新的 Widget 树；</li><li>Flutter 根据新/旧 Widget 树的差异更新 Render 树，重新排版更新界面布局；</li><li>Flutter 根据新的 Render 树更新 Composited Layer（合成图层）的 Display List；</li><li>输出新的图层树；</li></ol><h3 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h3><p>在 Flutter 里面 Widget 的定义是 UI 界面的不可变的抽象描述，它跟其他 UI Toolkit 的 Widget 或者 View 有较大差别，相比其他 UI Toolkit 里面的基础 UI 组件，Flutter Widget 的抽象层次更高，涵盖的范围更广，单纯从抽象层次来说，倒是更类似浏览器的 DOM/CSSOM，虽然两者实际上并不相同。给我的感觉就像是混合了各种不同的对 UI 界面进行描述的方式所创造出的一个新概念，采用浏览器渲染里面抽象层次划分的方式对其他 UI Toolkit 的基础 UI 组件进行层次划分得到的一个新的抽象层。</p><h3 id="RenderObject"><a href="#RenderObject" class="headerlink" title="RenderObject"></a>RenderObject</h3><p>Flutter 使用 RenderObject 作为 UI 界面的内部描述方式，基于 RenderObject 计算 UI 的布局和生成 UI 的绘制指令。Flutter 里面 RenderObject 和 Render 树的概念跟浏览器就基本差不多了，连命名都一样。从抽象层次和主要功能来说，RenderObject 跟其他 UI Toolkit 里面的 Widget 和 View 这些基础 UI 组件也比较接近。</p><h3 id="Composited-Layer"><a href="#Composited-Layer" class="headerlink" title="Composited Layer"></a>Composited Layer</h3><p>Flutter 使用 Composited Layer 来对 RenderObject 的绘制进行组织，通常一个 Composited Layer 对应一棵 RenderObject 子树，Composited Layer 的 Display List 记录了这棵 RenderObject 子树的绘制指令，这跟浏览器里面的 RenderObject 和 Composited Layer 基本是一样的。</p><p>不同的 UI Toolkit 对图层的处理方式并不一样，Android 没有一个完整的图层概念，只是间接地允许应用指定为特定的 View 子树生成图层，并且这个图层的概念跟 Flutter 里面的图层相比，Flutter 具备更高的抽象层次，它是绘制指令的一种组织方式，并不一定就需要分配额外的缓存做间接光栅化，Flutter 内部采用一个重复绘制次数阈值来控制是否为图层分配额外的缓存，通过这种方式来平衡内存占用和重复光栅化的性能损失。iOS 有比较完整的图层概念，跟 Flutter 更接近，并允许应用自己控制。</p><h3 id="Flutter-光栅化和合成"><a href="#Flutter-光栅化和合成" class="headerlink" title="Flutter 光栅化和合成"></a>Flutter 光栅化和合成</h3><p>Flutter 光栅化和合成的流水线设计对比浏览器就简单的多了，跟其他 UI Toolkit 基本一样，只需要在 GPU 线程完成全部的光栅化和合成，并且全部由 GPU 实现。Android HWUI 的光栅化和合成将来应该也会改用 Skia 的实现，所以长远来看，Android 和 Flutter，另外也包括 Chrome， 在光栅化和合成的实现上应该会是使用同样的代码。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol><li><p>移动技术发展由原生阶段-&gt;Hybird 阶段-&gt;RN 或小程序的跨平台支持方案-&gt;Flutter 阶段；</p></li><li><p>Flutter 高性能的优势在于采用 Dart，其具有基于 JIT 的快速开发周期发布阶段和基于 AOT 的发布包来提高我们的开发效率和发布的应用的性能；</p></li><li><p>Flutter 的另一大优势在于使用一套高性能渲染引擎 Skia 通过 GL 进行 UI 渲染，来达到跨平台代码复用和兼容性问题，达到 UI 平台一致性。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
